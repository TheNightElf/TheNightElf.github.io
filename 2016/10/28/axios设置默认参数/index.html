<!DOCTYPE html><html lang="zh-CN"><head><meta name="generator" content="Hexo 3.8.0"><meta charset="utf-8"><meta name="X-UA-Compatible" content="IE=edge"><title> Axios设置默认请求参数 · 冷暖我自知</title><meta name="description" content="Axios设置默认请求参数 - 冷暖我自知"><meta name="viewport" content="width=device-width, initial-scale=1"><link rel="icon" href="/blog/favicon.ico"><link rel="stylesheet" href="/blog/css/apollo.css"><link rel="search" type="application/opensearchdescription+xml" href="https://github.com/TheNightElf/atom.xml" title="冷暖我自知"></head><body><div class="wrap"><header><ul class="nav nav-list"><li class="nav-list-item"><a href="/blog/" target="_self" class="nav-list-link">BLOG</a></li><li class="nav-list-item"><a href="/blog/archives/" target="_self" class="nav-list-link">ARCHIVE</a></li><li class="nav-list-item"><a href="https://github.com/TheNightElf" target="_blank" class="nav-list-link">GITHUB</a></li></ul></header><main class="container"><div class="post"><article class="post-block"><h1 class="post-title">Axios设置默认请求参数</h1><div class="post-info">2016年10月28日</div><div class="post-content"><p>在网站建设成行对接 <code>api</code> 接口的时候经常会遇到一个场景——用户的登录验证。<br>大多数的做法都是服务端返回一个 <code>token</code> 给客户端，客户端存储在 <code>cookie</code> 或者 <code>Storage</code> 中。<br>等下次发请求的时候再将 <code>token</code> 携带，传递给服务端。但是这么做会非常的繁琐，每次都要在请求中设置 <code>token</code>。<br><a id="more"></a></p>
<h3 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h3><h4 id="方案一"><a href="#方案一" class="headerlink" title="方案一"></a>方案一</h4><p>使用 <code>axios</code> 官方提供的 <code>Interceptors</code> 拦截器进行配置。<br>假设 <code>token</code> 是储存在 <code>localeStorage</code> 中；<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 请求拦截器</span></span><br><span class="line">axios.interceptors.request.use(<span class="function"><span class="keyword">function</span> (<span class="params">config</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">const</span> token = localStorage.getItem(<span class="string">'token'</span>)</span><br><span class="line">     <span class="comment">// 判断请求的类型</span></span><br><span class="line">     <span class="comment">// 如果是post请求就把默认参数拼到data里面</span></span><br><span class="line">     <span class="comment">// 如果是get请求就拼到params里面</span></span><br><span class="line">    <span class="keyword">if</span>(config.method === <span class="string">'post'</span>) &#123;</span><br><span class="line">        <span class="keyword">let</span> data = qs.parse(config.data)</span><br><span class="line"></span><br><span class="line">        config.data = qs.stringify(&#123;</span><br><span class="line">            token: token,</span><br><span class="line">            ...data</span><br><span class="line">        &#125;)</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span>(config.method === <span class="string">'get'</span>) &#123;</span><br><span class="line">        config.params = &#123;</span><br><span class="line">            token: token,</span><br><span class="line">            ...config.params</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> config;</span><br><span class="line">  &#125;, <span class="function"><span class="keyword">function</span> (<span class="params">error</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">Promise</span>.reject(error);</span><br><span class="line">  &#125;)</span><br></pre></td></tr></table></figure></p>
<p>拦截器会拦截所有的 <code>请求</code> 或者 <code>响应</code>，我们可以在拦截到请求的时候将用户的请求参数中添加 <code>token</code>。<br>这样就不需要每次都在请求中添加一次 <code>token</code> 的操作了。</p>
<p><strong>扩展</strong><br>响应拦截器可以拦截每一次服务端的响应信息，用户的 <code>登录超时</code> 完全可以在这个拦截器中处理。</p>
<h4 id="方案二"><a href="#方案二" class="headerlink" title="方案二"></a>方案二</h4><p>通过更改 <code>request config</code> 的默认配置实现。<br>在上文的介绍中，我们可以看到 <code>request config</code> 中有一项 <code>transformRequest</code> 的配置。该方法会在每个请求发送给服务端之前执行，我们来看下如何使用。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">axios.defaults.transformRequest = [<span class="function"><span class="keyword">function</span> (<span class="params">data, header</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">const</span> token = localStorage.getItem(<span class="string">'token'</span>)</span><br><span class="line">    <span class="comment">//header.post = &#123;</span></span><br><span class="line">      <span class="comment">//  "Content-Type": "application/json;charset=UTF-8"</span></span><br><span class="line">    <span class="comment">//&#125;</span></span><br><span class="line">    <span class="keyword">var</span> obj = <span class="built_in">Object</span>.assign(&#123;&#125;, data, &#123; <span class="attr">token</span>: token &#125;)</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">JSON</span>.stringify(obj)</span><br><span class="line">&#125;]</span><br></pre></td></tr></table></figure></p>
<p>使用这个方法的时候有几个需要注意的地方:</p>
<ol>
<li>该方法的返回值必须是 <code>string</code> 或 <code>Buffer实例</code> 或 <code>ArrayBuffer</code> 或 <code>FormData</code> 或 <code>Stream</code>。</li>
<li>转换完之后请求体的 <code>payload</code> 会变成 <code>FormData</code> 的形式，可以在 <code>header</code> 中重写 <code>Content-Type</code>。</li>
</ol>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p><code>Axios</code> 提供了非常灵活的配置方法供用户使用，我们不需要再自己封装一个类似的 <code>xhr</code> 方法。所有的用法官方都有详细的说明，如果你想了解更多，可以点击<a href="https://github.com/axios/axios">这里</a>。</p>
</div></article></div></main><footer><div class="paginator"><a href="/blog/2016/11/16/逻辑符号/" class="prev">PREV</a><a href="/blog/2016/10/20/Axios使用说明/" class="next">NEXT</a></div><div class="copyright"><p>© 2016 - 2018 <a href="https://github.com/TheNightElf">冷暖我自知</a></p></div></footer></div></body></html>