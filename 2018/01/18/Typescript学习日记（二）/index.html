<!DOCTYPE html><html lang="zh-CN"><head><meta charset="utf-8"><meta name="X-UA-Compatible" content="IE=edge"><title> Typescript学习日记(二) · 冷暖我自知</title><meta name="description" content="Typescript学习日记(二) - 冷暖我自知"><meta name="viewport" content="width=device-width, initial-scale=1"><link rel="icon" href="/favicon.ico"><link rel="stylesheet" href="/css/apollo.css"><link rel="search" type="application/opensearchdescription+xml" href="https://github.com/TheNightElf/atom.xml" title="冷暖我自知"></head><body><div class="wrap"><header><ul class="nav nav-list"><li class="nav-list-item"><a href="/" target="_self" class="nav-list-link">BLOG</a></li><li class="nav-list-item"><a href="/archives/" target="_self" class="nav-list-link">ARCHIVE</a></li><li class="nav-list-item"><a href="https://github.com/TheNightElf" target="_blank" class="nav-list-link">GITHUB</a></li></ul></header><main class="container"><div class="post"><article class="post-block"><h1 class="post-title">Typescript学习日记(二)</h1><div class="post-info">2018年1月18日</div><div class="post-content"><p>本篇介绍 <code>typescript</code> 中接口的使用方式。<br><a id="more"></a></p>
<h3 id="接口-interface"><a href="#接口-interface" class="headerlink" title="接口(interface)"></a>接口(interface)</h3><p><code>TypeScript</code>的核心原则之一是对值所具有的结构进行类型检查。接口的作用就是为这些类型命名和为你的代码或第三方代码定义契约。<br>基础类型是为简单的变量定义类型，<strong>通常的，接口就是为你所定义的对象(参数、函数等)的添加类型的约束。</strong><br>按照 typescript 的默认约定，接口通常是以 <code>驼峰命名方式，大写字母开头</code> 的方式定义。</p>
<h4 id="使用方式"><a href="#使用方式" class="headerlink" title="使用方式"></a>使用方式</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 定义一个接口约束</span></span><br><span class="line">interface T &#123;</span><br><span class="line">    num: number;</span><br><span class="line">    str: string</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 函数的接受的参数中，num必须为number类型，str必须为string类型</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">demo</span>(<span class="params">arg: T</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="keyword">typeof</span> arg.num)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 也可以直接把约束条件写在函数参数中，为了可读性，推荐在外面定义</span></span><br><span class="line"><span class="comment">// eg:</span></span><br><span class="line"><span class="comment">// function demo(arg: &#123; num: number; str: string &#125;) &#123;</span></span><br><span class="line"><span class="comment">//     console.log(typeof arg.num)</span></span><br><span class="line"><span class="comment">// &#125;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> obj1 = &#123;<span class="attr">num</span>: <span class="number">100</span>, <span class="attr">str</span>: <span class="string">'typescript'</span>&#125;</span><br><span class="line">demo(obj1) <span class="comment">// success -&gt; number</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> obj2 = &#123;<span class="attr">num</span>: <span class="string">'123'</span>, <span class="attr">str</span>: <span class="string">'typescript'</span>&#125;</span><br><span class="line">demo(obj2) <span class="comment">// error</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> obj3 = &#123;<span class="attr">num</span>: <span class="number">123</span>&#125;</span><br><span class="line">demo(obj3) <span class="comment">// error 缺少一个 str 参数</span></span><br></pre></td></tr></table></figure>
<p><strong>注意：定义接口的时候不需要使用 <code>=</code>，<code>{}</code> 内部必须使用 <code>分号(;)</code> 分隔。</strong></p>
<h4 id="接口的可选属性"><a href="#接口的可选属性" class="headerlink" title="接口的可选属性"></a>接口的可选属性</h4><p>接口里的属性不全都是必需的。 有些是只在某些条件下存在，或者根本不存在。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">interface T &#123;</span><br><span class="line">    num: number;</span><br><span class="line">    str?: string;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">demo</span>(<span class="params">arg: T</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="keyword">typeof</span> arg.num)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> obj4 = &#123;<span class="attr">num</span>: <span class="number">100</span>, <span class="attr">str</span>: <span class="string">'typescript'</span>&#125;</span><br><span class="line">demo(obj4) <span class="comment">// success</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> obj5 = &#123;<span class="attr">num</span>: <span class="number">100</span>&#125;</span><br><span class="line">demo(obj5) <span class="comment">// success</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> obj6 = &#123;<span class="attr">str</span>: <span class="string">'typescript'</span>&#125;</span><br><span class="line">demo(obj6) <span class="comment">// error</span></span><br></pre></td></tr></table></figure>
<h4 id="接口的只读属性"><a href="#接口的只读属性" class="headerlink" title="接口的只读属性"></a>接口的只读属性</h4><p>这里的 <code>只读属性</code> 类似于原生javascript的 <code>const</code> 关键字，在赋值之后就不能更改了。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">interface Rd &#123;</span><br><span class="line">    readonly x: number;</span><br><span class="line">    readonly y: string</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> r: Rd = &#123; <span class="attr">x</span>: <span class="number">100</span>, <span class="attr">y</span>: <span class="string">'str'</span> &#125;</span><br><span class="line"></span><br><span class="line">r.x = <span class="number">123</span>; <span class="comment">// -&gt; error</span></span><br></pre></td></tr></table></figure>
<h4 id="只读的数组"><a href="#只读的数组" class="headerlink" title="只读的数组"></a>只读的数组</h4><p>TypeScript具有 <code>ReadonlyArray&lt;T&gt;</code> 类型，它与 <code>Array&lt;T&gt;</code> 相似，只是把所有可变方法去掉了，因此可以确保数组创建后再也不能被修改。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> arr: ReadonlyArray&lt;number&gt; = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>];</span><br><span class="line"></span><br><span class="line">arr[<span class="number">0</span>] = <span class="number">2</span>; <span class="comment">// -&gt; error</span></span><br><span class="line">arr.push(<span class="number">5</span>); <span class="comment">// -&gt; error</span></span><br><span class="line">arr.length = <span class="number">10</span>; <span class="comment">// -&gt; error</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> arr1: <span class="built_in">Array</span>&lt;number&gt; = arr;</span><br><span class="line"><span class="comment">// error, arr 是ReadonlyArray，不能赋值给别的数组</span></span><br></pre></td></tr></table></figure>
<h4 id="readonly还是const"><a href="#readonly还是const" class="headerlink" title="readonly还是const"></a>readonly还是const</h4><p>最简单判断该用readonly还是const的方法是看要把它做为变量使用还是做为一个属性。<br>做为变量使用的话用 const，若做为属性则使用readonly。</p>
<h4 id="额外的属性检查"><a href="#额外的属性检查" class="headerlink" title="额外的属性检查"></a>额外的属性检查</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">interface Pc &#123;</span><br><span class="line">    x?: number;</span><br><span class="line">    y?: string</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">demo</span>(<span class="params">arg: Pc</span>) </span>&#123;</span><br><span class="line">    <span class="comment">// ..</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">demo(&#123;<span class="attr">x</span>: <span class="number">100</span>, <span class="attr">z</span>: <span class="number">110</span>&#125;)</span><br><span class="line"><span class="comment">// error，因为 z 并没有在接口 Pc 中定义</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用类型断言改写</span></span><br><span class="line">demo(&#123;<span class="attr">x</span>: <span class="number">100</span>, <span class="attr">z</span>: <span class="number">110</span>&#125; <span class="keyword">as</span> Pc)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 告诉 ts 入参 '&#123;x: 100, z: 110&#125;' 都是来自于 Pc 接口的，你别 tmd 再帮我检查了</span></span><br><span class="line"><span class="comment">// ts： 好吧，既然你这么确定，我就听你的。</span></span><br></pre></td></tr></table></figure>
<p>然后上面的这种做法并不是最佳的做法，最佳的做法是添加一个 <code>占位用的签名</code>。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">// 我不知道我后面还会传什么属性进来，所以我先用个 propsName 占个位置</span></span><br><span class="line">interface Pc &#123;</span><br><span class="line">    x?: number;</span><br><span class="line">    y?: string;</span><br><span class="line">    [propName: string]: any;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">demo(&#123;<span class="attr">x</span>: <span class="number">100</span>, <span class="attr">z</span>: <span class="number">110</span>&#125;)</span><br><span class="line"><span class="comment">// success</span></span><br></pre></td></tr></table></figure>
<h4 id="函数类型"><a href="#函数类型" class="headerlink" title="函数类型"></a>函数类型</h4><p>为了使用接口表示函数类型，我们需要给接口定义一个调用签名。 它就像是一个 <code>只有参数列表和返回值类型</code> 的函数定义。<br><strong>参数列表里的每个参数都需要名字和类型。</strong></p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">interface Fn &#123;</span><br><span class="line">    (a: number, <span class="attr">b</span>: string): boolean</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 定义一个 Fn 函数接口，该函数接受 a: number，b: string 作为参数，返回一个 boolean 值</span></span><br></pre></td></tr></table></figure>
<h4 id="可索引的类型"><a href="#可索引的类型" class="headerlink" title="可索引的类型"></a>可索引的类型</h4><p>可索引类型具有一个 <code>索引签名</code>，它描述了对象 <code>索引的类型</code>，还有相应的索引 <code>返回值类型</code>。<br>共有两种索引签名：字符串和数字。可以同时使用两种类型的索引，但是数字索引的返回值必须是字符串索引返回值类型的子类型。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 1. 指定 索引类型 为 number</span></span><br><span class="line">interface IndexNum &#123;</span><br><span class="line">    [index: number]: string;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> arr: IndexNum = [<span class="string">'hello'</span>, <span class="string">'world'</span>];</span><br><span class="line"><span class="built_in">console</span>.log(arr[<span class="number">0</span>])</span><br><span class="line"></span><br><span class="line"><span class="comment">// 2. 指定 索引类型 为 string</span></span><br><span class="line">interface IndexStr &#123;</span><br><span class="line">    [index: string]: string;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> obj: IndexStr = &#123;<span class="string">'x'</span>: <span class="string">'hello'</span>, <span class="string">'y'</span>: <span class="string">'world'</span>&#125;</span><br><span class="line"><span class="built_in">console</span>.log(obj[<span class="string">'x'</span>])</span><br><span class="line"></span><br><span class="line"><span class="comment">// 3. 同时指定 索引类型 为 number 和 string</span></span><br><span class="line"></span><br><span class="line">interface TotalIndex &#123;</span><br><span class="line">    [index: number]: number;</span><br><span class="line">    at: number; <span class="comment">// success</span></span><br><span class="line">    where: string; <span class="comment">// error 使用 where 获取值时返回的是 string 类型</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 4. 只读的索引类型</span></span><br><span class="line"></span><br><span class="line">interface RdIndex &#123;</span><br><span class="line">    readonly [index: number]: string;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> arr: RdIndex = [<span class="string">'a'</span>,<span class="string">'b'</span>]</span><br><span class="line"></span><br><span class="line">arr[<span class="number">1</span>] = <span class="string">'c'</span>; <span class="comment">// error, arr 为只读的索引类型</span></span><br></pre></td></tr></table></figure>
<h4 id="‘类’类型"><a href="#‘类’类型" class="headerlink" title="‘类’类型"></a>‘类’类型</h4><p>和其它的类型约束相似，类类型使用 <code>implements</code> 实现接口。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 定义方式完全一致</span></span><br><span class="line">interface C &#123;</span><br><span class="line">    date: <span class="built_in">Date</span>;</span><br><span class="line">    setTime(d: <span class="built_in">Date</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// </span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Clock</span> <span class="title">implements</span> <span class="title">C</span> </span>&#123;</span><br><span class="line">     <span class="comment">// 声明一个 date 属性，且约束该属性类型为 Date</span></span><br><span class="line">     <span class="comment">// 这种写法相当于 var date: Date</span></span><br><span class="line">     <span class="comment">// 只是声明并约束值类型，但并不赋值</span></span><br><span class="line">    date: <span class="built_in">Date</span>;</span><br><span class="line">    setTime(d: <span class="built_in">Date</span>) &#123;</span><br><span class="line">        <span class="keyword">this</span>.date = d;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">constructor</span>(h: number, m: number) &#123;</span><br><span class="line">        <span class="comment">// ..</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>关于更多的 <code>implements</code> 的用法我目前也不是特别的清楚，所以下面就不再详细叙述了。<br>等我了解清楚之后再补上这一部分内容，你也可以通过查看<a href="https://www.tslang.cn/docs/handbook/interfaces.html" target="_blank" rel="noopener">官方文档</a>了解。</p>
<h4 id="继承接口"><a href="#继承接口" class="headerlink" title="继承接口"></a>继承接口</h4><p>和 <code>es2015</code> 中的 <code>extends</code> 一样，接口也是可以像类一样用来继承的。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">interface A &#123;</span><br><span class="line">    a: number;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">interface C &#123;</span><br><span class="line">    c: number;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">interface B extends A, C &#123;</span><br><span class="line">    b: string;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> obj = &lt;B&gt;&#123;&#125;;</span><br><span class="line">obj.a = 10;</span><br><span class="line">obj.b = '10';</span><br><span class="line">obj.c = 10;</span><br></pre></td></tr></table></figure>
<h4 id="混合类型"><a href="#混合类型" class="headerlink" title="混合类型"></a>混合类型</h4><p><code>interface</code> 还可以在一个接口中约束 <code>javascript</code> 中多个类型；</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> Counter &#123;</span><br><span class="line">    a: <span class="built_in">number</span>; <span class="comment">// 约束 a 为 number 类型</span></span><br><span class="line">    getStr(): <span class="built_in">void</span>;<span class="comment">// 约束 getStr 无返回值；</span></span><br><span class="line">    (n: <span class="built_in">number</span>): <span class="built_in">string</span>;<span class="comment">// 约束匿名函数接受一个参数 n 为 number 类型，返回值 string 类型</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 函数 getCounter 返回值被 Counter 约束</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getCounter</span>(<span class="params"></span>): <span class="title">Counter</span> </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> counter = &lt;Counter&gt;<span class="function"><span class="keyword">function</span> (<span class="params">start: <span class="built_in">number</span></span>) </span>&#123; &#125;; <span class="comment">// 类型断言</span></span><br><span class="line">    counter.interval = <span class="number">123</span>;</span><br><span class="line">    counter.reset = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123; &#125;;</span><br><span class="line">    <span class="keyword">return</span> counter;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> c = getCounter();</span><br><span class="line">c(<span class="number">10</span>);</span><br><span class="line">c.reset();</span><br><span class="line">c.interval = <span class="number">5.0</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// 这个模版有问题，写 ts 的代码就会出问题</span></span><br><span class="line"><span class="comment">// 只能这样了</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">//</span></span><br></pre></td></tr></table></figure>
<h4 id="接口继承类"><a href="#接口继承类" class="headerlink" title="接口继承类"></a>接口继承类</h4><p>接口继承类时会继承父类所有的属性和方法，包括 <code>private</code> 和 <code>protected</code> 成员。<br>这意味着当你创建了一个接口继承了一个拥有 <code>私有或受保护的成员</code> 的类时，这个接口类型只能被 <code>这个类或其子类</code> 所实现（implement）。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Control</span> </span>&#123;</span><br><span class="line">    private state: any;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// SelectableControl 含有 Control 所有的属性方法</span></span><br><span class="line">interface SelectableControl extends Control &#123;</span><br><span class="line">    select(): <span class="keyword">void</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Button 继承自 Control 含有 Control 所有的属性方法</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Button</span> <span class="keyword">extends</span> <span class="title">Control</span> <span class="title">implements</span> <span class="title">SelectableControl</span> </span>&#123;</span><br><span class="line">    select() &#123; &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// TextBox 继承自 Control 含有 Control 所有的属性方法</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TextBox</span> <span class="keyword">extends</span> <span class="title">Control</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Image 没有继承自 Control，没有 state 属性，无法实现 SelectableControl 接口</span></span><br><span class="line"><span class="comment">// 错误：“Image”类型缺少“state”属性。</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Image</span> <span class="title">implements</span> <span class="title">SelectableControl</span> </span>&#123;</span><br><span class="line">    select() &#123; &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div></article></div></main><footer><div class="paginator"><a href="/2018/01/22/Typescript学习日记（三）/" class="prev">PREV</a><a href="/2018/01/08/Typescript学习日记（一）/" class="next">NEXT</a></div><div class="copyright"><p>© 2017 - 2018 <a href="https://github.com/TheNightElf">冷暖我自知</a></p></div></footer></div></body></html>