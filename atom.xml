<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>冷暖我自知</title>
  
  <subtitle>这个前端有点菜。</subtitle>
  <link href="/blog/atom.xml" rel="self"/>
  
  <link href="https://github.com/TheNightElf/"/>
  <updated>2017-12-26T03:43:08.000Z</updated>
  <id>https://github.com/TheNightElf/</id>
  
  <author>
    <name>冷暖我自知</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>逻辑符号</title>
    <link href="https://github.com/TheNightElf/2017/12/26/%E9%80%BB%E8%BE%91%E7%AC%A6%E5%8F%B7/"/>
    <id>https://github.com/TheNightElf/2017/12/26/逻辑符号/</id>
    <published>2017-12-26T03:13:46.000Z</published>
    <updated>2017-12-26T03:43:08.000Z</updated>
    
    <content type="html"><![CDATA[<p>说起逻辑符号，我们接触的最多的可能就是 <code>&amp;&amp;</code> 和 <code>||</code> 这两个比较符了。本节会介绍一下这两个逻辑运算符的 <code>短路操作</code> 规则以及使用逻辑运算符代替 <code>if</code> 的快速比较赋值操作。<br><a id="more"></a></p><h3 id="amp-amp-的短路运算规则"><a href="#amp-amp-的短路运算规则" class="headerlink" title="&amp;&amp; 的短路运算规则"></a>&amp;&amp; 的短路运算规则</h3><p>当 <code>&amp;&amp;</code> 逻辑比较前面的值为 <code>true</code> 时，则直接返回 <code>&amp;&amp;</code> 后面的值(不论该值为 <code>true</code> 还是 <code>false</code>)。<br>当 <code>&amp;&amp;</code> 逻辑比较前面的值为 <code>false</code> 时，则直接返回 <code>&amp;&amp;</code> 前面的值，不再关心后面的值。<br>下面是例子：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a = <span class="number">5</span> &amp;&amp; <span class="number">6</span>;</span><br><span class="line"><span class="built_in">console</span>.log(a)</span><br><span class="line"><span class="comment">// =&gt; 6</span></span><br></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a = <span class="number">0</span> &amp;&amp; <span class="number">1</span>;</span><br><span class="line"><span class="built_in">console</span>.log(a)</span><br><span class="line"><span class="comment">// =&gt; 0</span></span><br></pre></td></tr></table></figure><h3 id="的短路运算规则"><a href="#的短路运算规则" class="headerlink" title="|| 的短路运算规则"></a>|| 的短路运算规则</h3><p>当 <code>||</code> 逻辑比较前面的值为 <code>false</code> 时，则直接返回 <code>||</code> 后面的值(不论该值为 <code>true</code> 还是 <code>false</code>)。<br>当 <code>||</code> 逻辑比较前面的值为 <code>true</code> 时，则直接返回 <code>||</code> 前面的值，不再关心后面的值。<br>下面是例子：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a = <span class="number">0</span> || <span class="number">1</span>;</span><br><span class="line"><span class="built_in">console</span>.log(a)</span><br><span class="line"><span class="comment">// =&gt; 1</span></span><br></pre></td></tr></table></figure></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a = <span class="number">1</span> || <span class="number">2</span>;</span><br><span class="line"><span class="built_in">console</span>.log(a)</span><br><span class="line"><span class="comment">// =&gt; 1</span></span><br></pre></td></tr></table></figure><h3 id="进阶用法"><a href="#进阶用法" class="headerlink" title="进阶用法"></a>进阶用法</h3><p>使用 <code>&amp;&amp;</code> 的短路规则代替短线 <code>if</code> 判断进行快速赋值操作。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 1</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">demo</span> (<span class="params">param</span>) </span>&#123;</span><br><span class="line">    !param &amp;&amp; (param = &#123;&#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 2</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">demo</span> (<span class="params">param</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(!param) param = &#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面的写法 <code>1</code> 和 <code>2</code> 的实际效果完全相同。</p><h3 id="优缺点"><a href="#优缺点" class="headerlink" title="优缺点"></a>优缺点</h3><h6 id="使用逻辑运算符代替短线-if-的优点"><a href="#使用逻辑运算符代替短线-if-的优点" class="headerlink" title="使用逻辑运算符代替短线 if 的优点:"></a>使用逻辑运算符代替短线 <code>if</code> 的优点:</h6><ol><li>运行速度快；<code>javascript</code> 中，逻辑运算符的执行速度是比 <code>if</code> 语句要快(参考短线操作规则)。</li><li>代码短小精悍，逼格更高(请忽略这点)。</li></ol><h6 id="使用逻辑运算符代替短线-if-的缺点"><a href="#使用逻辑运算符代替短线-if-的缺点" class="headerlink" title="使用逻辑运算符代替短线 if 的缺点:"></a>使用逻辑运算符代替短线 <code>if</code> 的缺点:</h6><ol><li>执行速度是变快了，但是使用的时候必须要注意 <code>操作符优先级</code> 的问题(可以参考<a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Operators/Operator_Precedence" target="_blank" rel="noopener">这里</a>)。</li><li>逼格是更高的，但是代码的可读性变的很差，不了解的人看了之后完全不知道怎么理解。</li></ol><p></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;说起逻辑符号，我们接触的最多的可能就是 &lt;code&gt;&amp;amp;&amp;amp;&lt;/code&gt; 和 &lt;code&gt;||&lt;/code&gt; 这两个比较符了。本节会介绍一下这两个逻辑运算符的 &lt;code&gt;短路操作&lt;/code&gt; 规则以及使用逻辑运算符代替 &lt;code&gt;if&lt;/code&gt; 的快速比较赋值操作。&lt;br&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>Axios设置默认请求参数</title>
    <link href="https://github.com/TheNightElf/2017/12/17/axios%E8%AE%BE%E7%BD%AE%E9%BB%98%E8%AE%A4%E5%8F%82%E6%95%B0/"/>
    <id>https://github.com/TheNightElf/2017/12/17/axios设置默认参数/</id>
    <published>2017-12-17T02:15:40.000Z</published>
    <updated>2017-12-26T03:12:51.000Z</updated>
    
    <content type="html"><![CDATA[<p>在网站建设成行对接 <code>api</code> 接口的时候经常会遇到一个场景——用户的登录验证。<br>大多数的做法都是服务端返回一个 <code>token</code> 给客户端，客户端存储在 <code>cookie</code> 或者 <code>Storage</code> 中。<br>等下次发请求的时候再将 <code>token</code> 携带，传递给服务端。但是这么做会非常的繁琐，每次都要在请求中设置 <code>token</code>。<br><a id="more"></a></p><h3 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h3><h4 id="方案一"><a href="#方案一" class="headerlink" title="方案一"></a>方案一</h4><p>使用 <code>axios</code> 官方提供的 <code>Interceptors</code> 拦截器进行配置。<br>假设 <code>token</code> 是储存在 <code>localeStorage</code> 中；<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 请求拦截器</span></span><br><span class="line">axios.interceptors.request.use(<span class="function"><span class="keyword">function</span> (<span class="params">config</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">const</span> token = localStorage.getItem(<span class="string">'token'</span>)</span><br><span class="line">     <span class="comment">// 判断请求的类型</span></span><br><span class="line">     <span class="comment">// 如果是post请求就把默认参数拼到data里面</span></span><br><span class="line">     <span class="comment">// 如果是get请求就拼到params里面</span></span><br><span class="line">    <span class="keyword">if</span>(config.method === <span class="string">'post'</span>) &#123;</span><br><span class="line">        <span class="keyword">let</span> data = qs.parse(config.data)</span><br><span class="line"></span><br><span class="line">        config.data = qs.stringify(&#123;</span><br><span class="line">            token: token,</span><br><span class="line">            ...data</span><br><span class="line">        &#125;)</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span>(config.method === <span class="string">'get'</span>) &#123;</span><br><span class="line">        config.params = &#123;</span><br><span class="line">            token: token,</span><br><span class="line">            ...config.params</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> config;</span><br><span class="line">  &#125;, <span class="function"><span class="keyword">function</span> (<span class="params">error</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">Promise</span>.reject(error);</span><br><span class="line">  &#125;)</span><br></pre></td></tr></table></figure></p><p>拦截器会拦截所有的 <code>请求</code> 或者 <code>响应</code>，我们可以在拦截到请求的时候将用户的请求参数中添加 <code>token</code>。<br>这样就不需要每次都在请求中添加一次 <code>token</code> 的操作了。</p><p><strong>扩展</strong><br>响应拦截器可以拦截每一次服务端的响应信息，用户的 <code>登录超时</code> 完全可以在这个拦截器中处理。</p><h4 id="方案二"><a href="#方案二" class="headerlink" title="方案二"></a>方案二</h4><p>通过更改 <code>request config</code> 的默认配置实现。<br>在上文的介绍中，我们可以看到 <code>request config</code> 中有一项 <code>transformRequest</code> 的配置。该方法会在每个请求发送给服务端之前执行，我们来看下如何使用。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">axios.defaults.transformRequest = [<span class="function"><span class="keyword">function</span> (<span class="params">data, header</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">const</span> token = localStorage.getItem(<span class="string">'token'</span>)</span><br><span class="line">    <span class="comment">//header.post = &#123;</span></span><br><span class="line">      <span class="comment">//  "Content-Type": "application/json;charset=UTF-8"</span></span><br><span class="line">    <span class="comment">//&#125;</span></span><br><span class="line">    <span class="keyword">var</span> obj = <span class="built_in">Object</span>.assign(&#123;&#125;, data, &#123; <span class="attr">token</span>: token &#125;)</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">JSON</span>.stringify(obj)</span><br><span class="line">&#125;]</span><br></pre></td></tr></table></figure></p><p>使用这个方法的时候有几个需要注意的地方:</p><ol><li>该方法的返回值必须是 <code>string</code> 或 <code>Buffer实例</code> 或 <code>ArrayBuffer</code> 或 <code>FormData</code> 或 <code>Stream</code>。</li><li>转换完之后请求体的 <code>payload</code> 会变成 <code>FormData</code> 的形式，可以在 <code>header</code> 中重写 <code>Content-Type</code>。</li></ol><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p><code>Axios</code> 提供了非常灵活的配置方法供用户使用，我们不需要再自己封装一个类似的 <code>xhr</code> 方法。所有的用法官方都有详细的说明，如果你想了解更多，可以点击<a href="https://github.com/axios/axios">这里</a>。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;在网站建设成行对接 &lt;code&gt;api&lt;/code&gt; 接口的时候经常会遇到一个场景——用户的登录验证。&lt;br&gt;大多数的做法都是服务端返回一个 &lt;code&gt;token&lt;/code&gt; 给客户端，客户端存储在 &lt;code&gt;cookie&lt;/code&gt; 或者 &lt;code&gt;Storage&lt;/code&gt; 中。&lt;br&gt;等下次发请求的时候再将 &lt;code&gt;token&lt;/code&gt; 携带，传递给服务端。但是这么做会非常的繁琐，每次都要在请求中设置 &lt;code&gt;token&lt;/code&gt;。&lt;br&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>Axios使用说明</title>
    <link href="https://github.com/TheNightElf/2017/12/13/Axios%E4%BD%BF%E7%94%A8%E8%AF%B4%E6%98%8E/"/>
    <id>https://github.com/TheNightElf/2017/12/13/Axios使用说明/</id>
    <published>2017-12-13T01:41:40.000Z</published>
    <updated>2017-12-13T02:13:16.000Z</updated>
    
    <content type="html"><![CDATA[<p>Axios是近年来备受推崇的一个网络请求库，它以基于Promise的方式封装了浏览器的XMLHttpRequest和服务器端node http请求，使得我们可以用es6推荐的异步方式处理网络请求。<br><a id="more"></a></p><h3 id="为什么用Axios"><a href="#为什么用Axios" class="headerlink" title="为什么用Axios"></a>为什么用Axios</h3><blockquote><p>官方是这样介绍的：</p><ul><li>从浏览器创建XMLHttpRequest</li><li>从node.js创建http请求</li><li>支持Promise API</li><li>转换请求与响应数据</li><li>取消请求</li><li>自动转换JSON数据</li><li>支持客户端XSRF攻击防护</li></ul></blockquote><p>扩展了诸多功能之后 <code>axios.min.js</code> 文件最终打包出来大小仅有 <code>13kb</code>。</p><h3 id="配置说明"><a href="#配置说明" class="headerlink" title="配置说明"></a>配置说明</h3><p>官方给出了一份详尽的配置说明，供使用者自定义自己的使用方式。详情可以点击<a href="https://github.com/axios/axios">这里</a>。</p><h4 id="全局默认配置"><a href="#全局默认配置" class="headerlink" title="全局默认配置"></a>全局默认配置</h4><p><code>axios</code> 给出了3个全局的配置信息，如下：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">axios.defaults.baseURL = <span class="string">'https://api.example.com'</span>;</span><br><span class="line">axios.defaults.headers.common[<span class="string">'Authorization'</span>] = AUTH_TOKEN;</span><br><span class="line">axios.defaults.headers.post[<span class="string">'Content-Type'</span>] = <span class="string">'application/x-www-form-urlencoded'</span>;</span><br></pre></td></tr></table></figure></p><p><strong>baseURL</strong><br>代表请求的地址，类似于 <code>host</code>。比如：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> baseUrl = <span class="string">'https://api.github.com'</span></span><br><span class="line">axios.defaults.baseURL = baseUrl;</span><br><span class="line">axios.get(<span class="string">'/user'</span>)</span><br><span class="line">    .then(<span class="function"><span class="params">res</span> =&gt;</span> &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(res)</span><br><span class="line">    &#125;)</span><br><span class="line"><span class="comment">// ------------ 与上面的写法作用相同 --------------//</span></span><br><span class="line">axios.get(<span class="string">'https://api.github.com/user'</span>)</span><br><span class="line">    .then(<span class="function"><span class="params">res</span> =&gt;</span> &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(res)</span><br><span class="line">    &#125;)</span><br></pre></td></tr></table></figure></p><p>通过配置 <code>baseUrl</code> 可以简化请求地址。</p><p><strong>Authorization</strong><br>授权信息，一般用于用户验证。如果没有设置，则请求是不会携带 <code>Authorization</code> 信息。</p><p><strong>Content-Type</strong><br>请求默认的 <code>Content-Type</code> 设置为 <code>application/x-www-form-urlencoded</code>，可以在全局更改，也可以在 <code>拦截器</code> 和 <code>请求/响应预处理</code> 中设置(后文中会细说)。</p><h4 id="请求默认配置"><a href="#请求默认配置" class="headerlink" title="请求默认配置"></a>请求默认配置</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  url: <span class="string">'/user'</span>,</span><br><span class="line"></span><br><span class="line">  method: <span class="string">'get'</span>, <span class="comment">// default</span></span><br><span class="line"></span><br><span class="line">  baseURL: <span class="string">'https://some-domain.com/api/'</span>,</span><br><span class="line"></span><br><span class="line">  transformRequest: [<span class="function"><span class="keyword">function</span> (<span class="params">data, headers</span>) </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> data;</span><br><span class="line">  &#125;],</span><br><span class="line"></span><br><span class="line">  transformResponse: [<span class="function"><span class="keyword">function</span> (<span class="params">data</span>) </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> data;</span><br><span class="line">  &#125;],</span><br><span class="line"></span><br><span class="line">  headers: &#123;<span class="string">'X-Requested-With'</span>: <span class="string">'XMLHttpRequest'</span>&#125;,</span><br><span class="line"></span><br><span class="line">  params: &#123;</span><br><span class="line">    ID: <span class="number">12345</span></span><br><span class="line">  &#125;,</span><br><span class="line"></span><br><span class="line">  paramsSerializer: <span class="function"><span class="keyword">function</span>(<span class="params">params</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> Qs.stringify(params, &#123;<span class="attr">arrayFormat</span>: <span class="string">'brackets'</span>&#125;)</span><br><span class="line">  &#125;,</span><br><span class="line"></span><br><span class="line">  data: &#123;</span><br><span class="line">    firstName: <span class="string">'Fred'</span></span><br><span class="line">  &#125;,</span><br><span class="line"></span><br><span class="line">  timeout: <span class="number">1000</span>,</span><br><span class="line"></span><br><span class="line">  withCredentials: <span class="literal">false</span>, <span class="comment">// default</span></span><br><span class="line"></span><br><span class="line">  adapter: <span class="function"><span class="keyword">function</span> (<span class="params">config</span>) </span>&#123;</span><br><span class="line">    <span class="comment">/* ... */</span></span><br><span class="line">  &#125;,</span><br><span class="line"></span><br><span class="line">  auth: &#123;</span><br><span class="line">    username: <span class="string">'janedoe'</span>,</span><br><span class="line">    password: <span class="string">'s00pers3cret'</span></span><br><span class="line">  &#125;,</span><br><span class="line"></span><br><span class="line">  responseType: <span class="string">'json'</span>, <span class="comment">// default</span></span><br><span class="line"></span><br><span class="line">  xsrfCookieName: <span class="string">'XSRF-TOKEN'</span>, <span class="comment">// default</span></span><br><span class="line"></span><br><span class="line">  xsrfHeaderName: <span class="string">'X-XSRF-TOKEN'</span>, <span class="comment">// default</span></span><br><span class="line"></span><br><span class="line">  onUploadProgress: <span class="function"><span class="keyword">function</span> (<span class="params">progressEvent</span>) </span>&#123;</span><br><span class="line"></span><br><span class="line">  &#125;,</span><br><span class="line"></span><br><span class="line">  onDownloadProgress: <span class="function"><span class="keyword">function</span> (<span class="params">progressEvent</span>) </span>&#123;</span><br><span class="line"></span><br><span class="line">  &#125;,</span><br><span class="line"></span><br><span class="line">  maxContentLength: <span class="number">2000</span>,</span><br><span class="line"></span><br><span class="line">  validateStatus: <span class="function"><span class="keyword">function</span> (<span class="params">status</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> status &gt;= <span class="number">200</span> &amp;&amp; status &lt; <span class="number">300</span>; <span class="comment">// default</span></span><br><span class="line">  &#125;,</span><br><span class="line"></span><br><span class="line">  maxRedirects: <span class="number">5</span>, <span class="comment">// default</span></span><br><span class="line"></span><br><span class="line">  httpAgent: <span class="keyword">new</span> http.Agent(&#123; <span class="attr">keepAlive</span>: <span class="literal">true</span> &#125;),</span><br><span class="line">  httpsAgent: <span class="keyword">new</span> https.Agent(&#123; <span class="attr">keepAlive</span>: <span class="literal">true</span> &#125;),</span><br><span class="line"></span><br><span class="line">  proxy: &#123;</span><br><span class="line">    host: <span class="string">'127.0.0.1'</span>,</span><br><span class="line">    port: <span class="number">9000</span>,</span><br><span class="line">    auth: &#123;</span><br><span class="line">      username: <span class="string">'mikeymike'</span>,</span><br><span class="line">      password: <span class="string">'rapunz3l'</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line"></span><br><span class="line">  cancelToken: <span class="keyword">new</span> CancelToken(<span class="function"><span class="keyword">function</span> (<span class="params">cancel</span>) </span>&#123;</span><br><span class="line"></span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>最常用的也就是前面的 <code>10</code> 个配置，而且意思都特别容易理解。<br>具体的用法可以参考<a href="https://github.com/axios/axios">官方说明</a>和<a href="https://github.com/axios/axios/tree/master/examples">examples</a>。</p><h4 id="返回体"><a href="#返回体" class="headerlink" title="返回体"></a>返回体</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  data: &#123;&#125;, <span class="comment">// 服务端对于请求返回的具体信息</span></span><br><span class="line"></span><br><span class="line">  status: <span class="number">200</span>,<span class="comment">// 服务端 http 的状态码</span></span><br><span class="line"></span><br><span class="line">  statusText: <span class="string">'OK'</span>, <span class="comment">// 服务端 http 文本的响应状态</span></span><br><span class="line"></span><br><span class="line">  headers: &#123;&#125;, <span class="comment">// 响应头部</span></span><br><span class="line"></span><br><span class="line">  config: &#123;&#125;, <span class="comment">// axios 请求时的配置信息</span></span><br><span class="line"></span><br><span class="line">  request: &#123;&#125; <span class="comment">// 请求的详细信息(XMLHttpRequest)</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>由于内容实在太多，本文暂时就讲这么多。其它关于 <code>axios</code> 的方法的用法和说明都会在后文中讲解。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Axios是近年来备受推崇的一个网络请求库，它以基于Promise的方式封装了浏览器的XMLHttpRequest和服务器端node http请求，使得我们可以用es6推荐的异步方式处理网络请求。&lt;br&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>EventEmitter</title>
    <link href="https://github.com/TheNightElf/2017/12/12/EventEmitter/"/>
    <id>https://github.com/TheNightElf/2017/12/12/EventEmitter/</id>
    <published>2017-12-12T08:08:10.000Z</published>
    <updated>2017-12-13T03:12:54.000Z</updated>
    
    <content type="html"><![CDATA[<p>自己编写一个简单的 <code>EventEmitter</code> 实现 <code>观察者模式</code>。</p><a id="more"></a><h3 id="观察者模式"><a href="#观察者模式" class="headerlink" title="观察者模式"></a>观察者模式</h3><blockquote><p>观察者模式面向的需求是：A对象（观察者）对B对象（被观察者）的某种变化高度敏感，需要在B变化的一瞬间做出反应。<br>举个例子，新闻里喜闻乐见的警察抓小偷，警察需要在小偷伸手作案的时候实施抓捕。<br>在这个例子里，警察是观察者、小偷是被观察者，警察需要时刻盯着小偷的一举一动，才能保证不会错过任何瞬间。<br>程序里的观察者和这种真正的【观察】略有不同，观察者不需要时刻盯着被观察者(例如A不需要每隔1ms就检查一次B的状态)；<br>二是采用注册(Register)或者成为订阅(Subscribe)的方式告诉被观察者：<br>我需要你的某某状态，你要在它变化时通知我。采取这样被动的观察方式，既省去了反复检索状态的资源消耗，也能够得到最高的反馈速度。</p></blockquote><h3 id="观察者模式的优缺点"><a href="#观察者模式的优缺点" class="headerlink" title="观察者模式的优缺点"></a>观察者模式的优缺点</h3><h4 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h4><ul><li>观察者模式在被观察者和观察者之间建立一个抽象的耦合。被观察者角色所知道的只是一个具体观察者列表，每一个具体观察者都符合一个抽象观察者的接口。被观察者并不认识任何一个具体观察者，它只知道它们都有一个共同的接口。</li><li>由于被观察者和观察者没有紧密地耦合在一起，因此它们可以属于不同的抽象化层次。如果被观察者和观察者都被扔到一起，那么这个对象必然跨越抽象化和具体化层次。</li><li>观察者模式支持广播通讯。被观察者会向所有的登记过的观察者发出通知。</li></ul><h4 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h4><ul><li>如果一个被观察者对象有很多的直接和间接的观察者的话，将所有的观察者都通知到会花费很多时间。</li><li>如果在被观察者之间有循环依赖的话，被观察者会触发它们之间进行循环调用，导致系统崩溃。</li><li>如果对观察者的通知是通过另外的线程进行异步投递的话，系统必须保证投递是以自恰的方式进行的。</li><li>虽然观察者模式可以随时使观察者知道所观察的对象发生了变化，但是观察者模式没有相应的机制使观察者知道所观察的对象是怎么发生变化的。</li></ul><h3 id="实现方法"><a href="#实现方法" class="headerlink" title="实现方法"></a>实现方法</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">EventEmitter</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.events = &#123;&#125;;</span><br><span class="line">&#125;</span><br><span class="line">    <span class="comment">//绑定事件函数</span></span><br><span class="line">EventEmitter.prototype.on = <span class="function"><span class="keyword">function</span>(<span class="params">eventName, callback</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.events[eventName] = <span class="keyword">this</span>.events[eventName] || [];</span><br><span class="line">    <span class="keyword">this</span>.events[eventName].push(callback); <span class="comment">// 1</span></span><br><span class="line">&#125;;</span><br><span class="line">    <span class="comment">//触发事件函数</span></span><br><span class="line">EventEmitter.prototype.emit = <span class="function"><span class="keyword">function</span>(<span class="params">eventName, _</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> events = <span class="keyword">this</span>.events[eventName],</span><br><span class="line">    args = <span class="built_in">Array</span>.prototype.slice.call(<span class="built_in">arguments</span>, <span class="number">1</span>), <span class="comment">// 2</span></span><br><span class="line">    i, m;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">if</span> (!events) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>, m = events.length; i &lt; m; i++) &#123;</span><br><span class="line">        events[i].apply(<span class="literal">null</span>, args); <span class="comment">// 3</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line">    <span class="comment">// 删除事件函数</span></span><br><span class="line">EventEmitter.prototype.off = <span class="function"><span class="keyword">function</span> (<span class="params">eventName</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">delete</span> <span class="keyword">this</span>.events[eventName]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>以上有3个注意点：<br>1.<code>EventEmitter</code> 接收事件时是以事件名作为 <code>key</code> 执行函数作为 <code>value:array</code>。<br>2.但用户触发 <code>emit</code> 时可以传递多个参数，所以将除 <code>事件名(arg[0])</code> 之外的参数视为传参，缓存供第 <code>3</code> 步时使用。<br>3.遍历事件的执行函数 <code>value</code> 并将 <code>args</code> 传递给每一个事件。</p><p>更多关于 <code>call</code> 和 <code>apply</code> 的介绍请参考<a href="https://developer.mozilla.org/en-US/" target="_blank" rel="noopener">这里</a></p><h3 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">var</span> Person = <span class="function"><span class="keyword">function</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Person.prototype = <span class="keyword">new</span> EventEmitter()</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> p = <span class="keyword">new</span> Person()</span><br><span class="line"></span><br><span class="line">p.on(<span class="string">'hello'</span>, <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'hello world'</span>)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">p.emit(<span class="string">'hello'</span>) <span class="comment">// -&gt; hello world</span></span><br></pre></td></tr></table></figure><p>传递参数时，可以直接在 <code>on</code> 执行函数中获取 <code>emit</code> 中传递的参数；<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">p.on(<span class="string">'hello'</span>, <span class="function"><span class="keyword">function</span> (<span class="params">name</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'hello'</span> + name)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">p.emit(<span class="string">'hello'</span>, <span class="string">'Mark'</span>) <span class="comment">// -&gt; hello Mark</span></span><br></pre></td></tr></table></figure></p><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>以上只是对观察者模式主体的一个简单实现，还有很多可以扩展的方法和优化的方案，这里我就不再继续写了。<br>如果你想了解更加完整的实现方式可以参考 <a href="https://github.com/asyncly/EventEmitter2">EventEmitter2</a>。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;自己编写一个简单的 &lt;code&gt;EventEmitter&lt;/code&gt; 实现 &lt;code&gt;观察者模式&lt;/code&gt;。&lt;/p&gt;
    
    </summary>
    
    
  </entry>
  
</feed>
