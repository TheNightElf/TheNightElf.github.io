---
title: 现代浏览器的类名操作
date: 2016-11-24 11:25:53
tags:
---

在前端 `MV*` 框架还未兴起的时期，绝大部分的前端网站都是基于 `事件驱动` 的。而这种网站总是不可避免的伴随着大量的 `DOM操作`。其中，`类名 - class` 的操作算是其中最平常也是最方便、通用的一种。

<!-- more -->

### 类名操作

说起类名操作，大部分人的第一反应就是 `jquery` 中的 `addClass、removeClass、hasClass、toggleClass` 这几个组合了。
下面我们看下 `jquery` 源码中是怎么实现的。
#### addClass
```js
// addClass
function addClass( value ) {
    var classes, elem, cur, curValue, clazz, j, finalValue,
        i = 0;

    if ( jQuery.isFunction( value ) ) {
        return this.each( function( j ) {
            jQuery( this ).addClass( value.call( this, j, getClass( this ) ) );
        } );
    }

    if ( typeof value === "string" && value ) {
        classes = value.match( rnothtmlwhite ) || [];

        while ( ( elem = this[ i++ ] ) ) {
            curValue = getClass( elem );
            cur = elem.nodeType === 1 && ( " " + stripAndCollapse( curValue ) + " " );

            if ( cur ) {
                j = 0;
                while ( ( clazz = classes[ j++ ] ) ) {
                    if ( cur.indexOf( " " + clazz + " " ) < 0 ) {
                        cur += clazz + " ";
                    }
                }

                // Only assign if different to avoid unneeded rendering.
                finalValue = stripAndCollapse( cur );
                if ( curValue !== finalValue ) {
                    elem.setAttribute( "class", finalValue );
                }
            }
        }
    }

    return this;
}
```

#### removeClass
```js
// removeClass 
function removeClass( value ) {
    var classes, elem, cur, curValue, clazz, j, finalValue,
        i = 0;

    if ( jQuery.isFunction( value ) ) {
        return this.each( function( j ) {
            jQuery( this ).removeClass( value.call( this, j, getClass( this ) ) );
        } );
    }

    if ( !arguments.length ) {
        return this.attr( "class", "" );
    }

    if ( typeof value === "string" && value ) {
        classes = value.match( rnothtmlwhite ) || [];

        while ( ( elem = this[ i++ ] ) ) {
            curValue = getClass( elem );

            // This expression is here for better compressibility (see addClass)
            cur = elem.nodeType === 1 && ( " " + stripAndCollapse( curValue ) + " " );

            if ( cur ) {
                j = 0;
                while ( ( clazz = classes[ j++ ] ) ) {

                    // Remove *all* instances
                    while ( cur.indexOf( " " + clazz + " " ) > -1 ) {
                        cur = cur.replace( " " + clazz + " ", " " );
                    }
                }

                // Only assign if different to avoid unneeded rendering.
                finalValue = stripAndCollapse( cur );
                if ( curValue !== finalValue ) {
                    elem.setAttribute( "class", finalValue );
                }
            }
        }
    }

    return this;
}
```
#### hasClass
```js
// hasClass
function hasClass( selector ) {
    var className, elem,
        i = 0;

    className = " " + selector + " ";
    while ( ( elem = this[ i++ ] ) ) {
        if ( elem.nodeType === 1 &&
            ( " " + stripAndCollapse( getClass( elem ) ) + " " ).indexOf( className ) > -1 ) {
                return true;
        }
    }

    return false;
}
```

#### toggleClass
```js
// toggleClass 
function toggleClass( value, stateVal ) {
    var type = typeof value;

    if ( typeof stateVal === "boolean" && type === "string" ) {
        return stateVal ? this.addClass( value ) : this.removeClass( value );
    }

    if ( jQuery.isFunction( value ) ) {
        return this.each( function( i ) {
            jQuery( this ).toggleClass(
                value.call( this, i, getClass( this ), stateVal ),
                stateVal
            );
        } );
    }

    return this.each( function() {
        var className, i, self, classNames;

        if ( type === "string" ) {

            // Toggle individual class names
            i = 0;
            self = jQuery( this );
            classNames = value.match( rnothtmlwhite ) || [];

            while ( ( className = classNames[ i++ ] ) ) {

                // Check each className given, space separated list
                if ( self.hasClass( className ) ) {
                    self.removeClass( className );
                } else {
                    self.addClass( className );
                }
            }

        // Toggle whole class name
        } else if ( value === undefined || type === "boolean" ) {
            className = getClass( this );
            if ( className ) {

                // Store className if set
                dataPriv.set( this, "__className__", className );
            }

            // If the element has a class name or if we're passed `false`,
            // then remove the whole classname (if there was one, the above saved it).
            // Otherwise bring back whatever was previously saved (if anything),
            // falling back to the empty string if nothing was stored.
            if ( this.setAttribute ) {
                this.setAttribute( "class",
                    className || value === false ?
                    "" :
                    dataPriv.get( this, "__className__" ) || ""
                );
            }
        }
    } );
}
```

内部的代码逻辑我就不再分析了，这种代码最明显的特点：`大量的循环和判断`。
对于以前的前端环境来说，这种写法无可厚非，它能让我们的代码更加的健壮，能兼容几乎所有的浏览器环境了。但是如今，随着 `大前端` 的兴起，浏览器对于 `js - css - html` 的支持能力已经发生了翻天覆地的变化，我们可以用最简单、快速的方式实现上面的操作。

### Element.classList
我们先看下官方对于该属性的介绍：
> Element.classList 是一个只读属性，返回一个元素的类属性的实时 DOMTokenList集合。
使用 classList 是一个方便的替代方法，通过element.className作为空格分隔的字符串访问元素的类列表。

更加通俗的讲：
之前我们获取一个元素类名的集合时，需要先使用 `element.className` 获取类名的字符串，之后在 `split` 成一个集合。而使用 `element.classList` 时，我们能直接获取元素类名的集合(**这里是集合，不是数组**)。

### Element.classList 的类名操作

上面说到，`element.classList` 返回一个类名的集合，该集合是与元素的 `class` 相互映射的。也就是说，我们只要向 `classList` 中添加一个 `class` 这个 `class` 就会映射到真实的元素上。为此`DOMTokenList` 提供了一套操作的方法来允许开发者操作 `classList`。

#### addClass - classList.add
```js
// 添加类名
element.classList.add('added-class')
```

#### removeClass - classList.remove
```js
// 删除类名
element.classList.remove('removed-class')
```

#### hasClass - classList.contains
```js
// 判断是否存在类名
element.classList.contains('contains-class')
```
#### toggleClass - classList.toggle
```js
// 类名切换
element.classList.toggle('toggled-class')

// 类名切换 - while
// 当第二个参数的表达式满足条件时，执行 toggle 操作
// 该方法目前还在 **实验** 阶段
element.classList.toggle('toggled-class', i < 10)
```

上面列举的这些方法已经在 `ie10` 以上的浏览器上普及，可以直接使用。
更多 `classList` 的方法可以参考[这里](https://developer.mozilla.org/en-US/docs/Web/API/DOMTokenList)。