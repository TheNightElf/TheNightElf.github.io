<!DOCTYPE html><html lang="zh-CN"><head><meta charset="utf-8"><meta name="X-UA-Compatible" content="IE=edge"><title> 冷暖我自知</title><meta name="description" content="a Font-End developer website."><meta name="viewport" content="width=device-width, initial-scale=1"><link rel="icon" href="/favicon.ico"><link rel="stylesheet" href="/css/apollo.css"><link rel="search" type="application/opensearchdescription+xml" href="https://github.com/TheNightElf/atom.xml" title="冷暖我自知"></head><body><div class="wrap"><header><ul class="nav nav-list"><li class="nav-list-item"><a href="/" target="_self" class="nav-list-link active">BLOG</a></li><li class="nav-list-item"><a href="/archives/" target="_self" class="nav-list-link">ARCHIVE</a></li><li class="nav-list-item"><a href="https://github.com/TheNightElf" target="_blank" class="nav-list-link">GITHUB</a></li></ul></header><main class="container"><ul class="home post-list"><li class="post-list-item"><article class="post-block"><h2 class="post-title"><a href="/2017/12/27/现代浏览器的类名操作/" class="post-title-link">现代浏览器的类名操作</a></h2><div class="post-info">2017年12月27日</div><div class="post-content"><p>在前端 <code>MV*</code> 框架还未兴起的时期，绝大部分的前端网站都是基于 <code>事件驱动</code> 的。而这种网站总是不可避免的伴随着大量的 <code>DOM操作</code>。其中，<code>类名 - class</code> 的操作算是其中最平常也是最方便、通用的一种。</p></div><a href="/2017/12/27/现代浏览器的类名操作/" class="read-more">...more</a></article></li><li class="post-list-item"><article class="post-block"><h2 class="post-title"><a href="/2017/12/26/逻辑符号/" class="post-title-link">逻辑符号</a></h2><div class="post-info">2017年12月26日</div><div class="post-content"><p>说起逻辑符号，我们接触的最多的可能就是 <code>&amp;&amp;</code> 和 <code>||</code> 这两个比较符了。本节会介绍一下这两个逻辑运算符的 <code>短路操作</code> 规则以及使用逻辑运算符代替 <code>if</code> 的快速比较赋值操作。<br></div><a href="/2017/12/26/逻辑符号/" class="read-more">...more</a></article></li><li class="post-list-item"><article class="post-block"><h2 class="post-title"><a href="/2017/12/17/axios设置默认参数/" class="post-title-link">Axios设置默认请求参数</a></h2><div class="post-info">2017年12月17日</div><div class="post-content"><p>在网站建设成行对接 <code>api</code> 接口的时候经常会遇到一个场景——用户的登录验证。<br>大多数的做法都是服务端返回一个 <code>token</code> 给客户端，客户端存储在 <code>cookie</code> 或者 <code>Storage</code> 中。<br>等下次发请求的时候再将 <code>token</code> 携带，传递给服务端。但是这么做会非常的繁琐，每次都要在请求中设置 <code>token</code>。<br></div><a href="/2017/12/17/axios设置默认参数/" class="read-more">...more</a></article></li><li class="post-list-item"><article class="post-block"><h2 class="post-title"><a href="/2017/12/13/Axios使用说明/" class="post-title-link">Axios使用说明</a></h2><div class="post-info">2017年12月13日</div><div class="post-content"><p>Axios是近年来备受推崇的一个网络请求库，它以基于Promise的方式封装了浏览器的XMLHttpRequest和服务器端node http请求，使得我们可以用es6推荐的异步方式处理网络请求。<br></div><a href="/2017/12/13/Axios使用说明/" class="read-more">...more</a></article></li><li class="post-list-item"><article class="post-block"><h2 class="post-title"><a href="/2017/12/12/EventEmitter/" class="post-title-link">EventEmitter</a></h2><div class="post-info">2017年12月12日</div><div class="post-content"><p>自己编写一个简单的 <code>EventEmitter</code> 实现 <code>观察者模式</code>。</p></div><a href="/2017/12/12/EventEmitter/" class="read-more">...more</a></article></li></ul></main><footer><div class="paginator"></div><div class="copyright"><p>© 2017 <a href="https://github.com/TheNightElf">冷暖我自知</a></p></div></footer></div></body></html>