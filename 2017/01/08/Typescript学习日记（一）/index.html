<!DOCTYPE html><html lang="zh-CN"><head><meta charset="utf-8"><meta name="X-UA-Compatible" content="IE=edge"><title> Typescript学习日记(一) · 冷暖我自知</title><meta name="description" content="Typescript学习日记(一) - 冷暖我自知"><meta name="viewport" content="width=device-width, initial-scale=1"><link rel="icon" href="/favicon.ico"><link rel="stylesheet" href="/css/apollo.css"><link rel="search" type="application/opensearchdescription+xml" href="https://github.com/TheNightElf/atom.xml" title="冷暖我自知"></head><body><div class="wrap"><header><ul class="nav nav-list"><li class="nav-list-item"><a href="/" target="_self" class="nav-list-link">BLOG</a></li><li class="nav-list-item"><a href="/archives/" target="_self" class="nav-list-link">ARCHIVE</a></li><li class="nav-list-item"><a href="https://github.com/TheNightElf" target="_blank" class="nav-list-link">GITHUB</a></li></ul></header><main class="container"><div class="post"><article class="post-block"><h1 class="post-title">Typescript学习日记(一)</h1><div class="post-info">2017年1月8日</div><div class="post-content"><p><code>javascript</code> 是运行在浏览器中的一门脚本语言，为了尽可能的减少内存的开支所以在设计之初它就是一门 <code>弱类型</code> 的语言。这在开发小而简单的应用时是可以为我们带来性能的提升，但是随着项目的扩大 <code>状态</code> 变的难以追踪将会引发很多的 <code>bug</code> 出现。<br>例子：<br><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> test;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typeof</span> test;</span><br><span class="line"><span class="comment">// -&gt; 'undefined'</span></span><br><span class="line"></span><br><span class="line">test = <span class="string">'str'</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typeof</span> test;</span><br><span class="line"><span class="comment">// -&gt; 'string'</span></span><br><span class="line"></span><br><span class="line">test = <span class="number">123</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typeof</span> test;</span><br><span class="line"><span class="comment">// -&gt; 'number'</span></span><br></pre></td></tr></table></figure></p>
<a id="more"></a>
<h3 id="Typescript"><a href="#Typescript" class="headerlink" title="Typescript"></a>Typescript</h3><p><code>typescript</code> 是 <code>javascript</code> 的强类型版本。它会在编译期去掉类型和特有语法生成 <code>javascript</code> 代码。<code>typescript</code> 是 <code>javascript</code> 的超集，它支持所有 <code>javascript语法</code>，与此同时它又为 <code>javascript</code> 添加了 <code>静态类型检查</code> 使得 <code>javacript</code> 也拥有了 <code>强类型语言</code> 的特性。</p>
<h3 id="Typescript-基础类型"><a href="#Typescript-基础类型" class="headerlink" title="Typescript 基础类型"></a>Typescript 基础类型</h3><h4 id="布尔值-boolean"><a href="#布尔值-boolean" class="headerlink" title="布尔值(boolean)"></a>布尔值(boolean)</h4><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> bool: <span class="built_in">boolean</span> = <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">bool = <span class="number">123</span>;</span><br><span class="line"><span class="comment">// 报错，123是number类型而非boolean类型</span></span><br><span class="line"></span><br><span class="line">bool = <span class="literal">true</span>;</span><br><span class="line"><span class="comment">// ok，true是一个boolean类型</span></span><br></pre></td></tr></table></figure>
<h4 id="数值-number"><a href="#数值-number" class="headerlink" title="数值(number)"></a>数值(number)</h4><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> num: <span class="built_in">number</span> = <span class="number">123</span>;</span><br><span class="line"></span><br><span class="line">num = <span class="string">'str'</span>;</span><br><span class="line"><span class="comment">// error</span></span><br><span class="line"></span><br><span class="line">num = <span class="number">456</span>;</span><br><span class="line"><span class="comment">// success</span></span><br></pre></td></tr></table></figure>
<h4 id="字符串-string"><a href="#字符串-string" class="headerlink" title="字符串(string)"></a>字符串(string)</h4><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> str: <span class="built_in">string</span> = <span class="string">'str'</span>;</span><br><span class="line"><span class="comment">// ...</span></span><br></pre></td></tr></table></figure>
<h4 id="数组-array"><a href="#数组-array" class="headerlink" title="数组(array)"></a>数组(array)</h4><p><strong>定义方式：</strong><br>第一种，可以在 <code>元素类型</code> 后面接上 <code>[]</code>。<br><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> arr: <span class="built_in">number</span>[] = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>];</span><br></pre></td></tr></table></figure></p>
<p>第二种，使用 <code>数组泛型</code> 定义。<br><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> arr: <span class="built_in">Array</span>&lt;<span class="built_in">number</span>&gt; = [<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>];</span><br></pre></td></tr></table></figure></p>
<h4 id="元组-tuple"><a href="#元组-tuple" class="headerlink" title="元组(tuple)"></a>元组(tuple)</h4><p>元组类型允许表示一个已知元素数量和类型的数组(其实就是一个数组内包含多个类型的值)。<br><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> tup: [<span class="built_in">number</span>, <span class="built_in">string</span>] = [<span class="number">123</span>,<span class="string">'str'</span>];</span><br></pre></td></tr></table></figure></p>
<h4 id="枚举-enum"><a href="#枚举-enum" class="headerlink" title="枚举(enum)"></a>枚举(enum)</h4><p><code>enum</code> 类型是对JavaScript标准数据类型的一个补充。 像C#等其它语言一样，使用枚举类型可以为一组数值赋予友好的名字。<br><strong>用人话说就是：把一组值放到一个可迭代的对象中，然后给这个对象起了个名字。</strong></p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">enum</span> animal &#123;dog,cat,pig&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 对象取值</span></span><br><span class="line"><span class="keyword">let</span> a: animal = animal.dog</span><br><span class="line"></span><br><span class="line"><span class="comment">// 数组取值</span></span><br><span class="line"><span class="keyword">let</span> b = animal[<span class="number">0</span>] <span class="comment">// -&gt; dog</span></span><br><span class="line"><span class="keyword">let</span> b = animal[<span class="number">1</span>] <span class="comment">// -&gt; cat</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 可以手动更改索引</span></span><br><span class="line"><span class="comment">// enum animal &#123;dog = 1, cat, pig&#125;</span></span><br><span class="line"><span class="comment">// let b = animal[1] // -&gt; dog</span></span><br><span class="line"><span class="comment">// let b = animal[2] // -&gt; cat</span></span><br></pre></td></tr></table></figure>
<h4 id="任何类型-any"><a href="#任何类型-any" class="headerlink" title="任何类型(any)"></a>任何类型(any)</h4><p>若是不清楚变量的具体类型可以指定为 <code>any</code>。</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> a: <span class="built_in">any</span> = <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">a = <span class="string">'str'</span>; <span class="comment">// success</span></span><br><span class="line">a = <span class="number">123</span>; <span class="comment">// success</span></span><br></pre></td></tr></table></figure>
<h4 id="无类型-void"><a href="#无类型-void" class="headerlink" title="无类型(void)"></a>无类型(void)</h4><p>与 <code>any</code> 相反。一个函数没有返回值的时候通常指定其返回值类型为 <code>void</code>。<br>一个 <code>void</code> 类型的变量只能赋值为 <code>undefined</code> | <code>null</code>。<br><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">noReturn</span>(<span class="params"></span>): <span class="title">void</span> </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'这个函数没有返回值'</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> n: <span class="built_in">void</span> = <span class="literal">null</span>;</span><br><span class="line"><span class="comment">// let n: void = undefined;</span></span><br></pre></td></tr></table></figure></p>
<h4 id="null和undefined"><a href="#null和undefined" class="headerlink" title="null和undefined"></a>null和undefined</h4><p><code>undefined</code>和<code>null</code>两者各自有自己的类型还是叫做<code>undefined</code>和<code>null</code>。</p>
<p><strong>默认情况下null和undefined是所有类型的子类型。 就是说你可以把 null和undefined赋值给number类型的变量。</strong></p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> u: <span class="literal">undefined</span> = <span class="literal">undefined</span>;</span><br><span class="line"><span class="keyword">let</span> n: <span class="literal">null</span> = <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> num: <span class="built_in">number</span> = <span class="number">123</span>;</span><br><span class="line">num = <span class="literal">undefined</span>; <span class="comment">// success</span></span><br></pre></td></tr></table></figure>
<h4 id="永远不存在的值-never"><a href="#永远不存在的值-never" class="headerlink" title="永远不存在的值(never)"></a>永远不存在的值(never)</h4><p>例如， never类型是那些总是会抛出异常或根本就不会有返回值的函数表达式或箭头函数表达式的返回值类型；<br><strong>never类型是任何类型的子类型，也可以赋值给任何类型；然而，没有类型是never的子类型或可以赋值给never类型（除了never本身之外）。 即使 any也不可以赋值给never。</strong></p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> n: never; <span class="comment">// never 不能被赋值</span></span><br><span class="line"><span class="keyword">let</span> num: <span class="built_in">number</span> = <span class="number">123</span>;</span><br><span class="line"><span class="keyword">let</span> a: <span class="built_in">any</span>;</span><br><span class="line"></span><br><span class="line">num = n; <span class="comment">// success，never类型是任何类型的子类型</span></span><br><span class="line"></span><br><span class="line">n = <span class="number">123</span>; <span class="comment">// error</span></span><br><span class="line">n = a; <span class="comment">// error</span></span><br></pre></td></tr></table></figure>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 返回never的函数必须存在无法达到的终点</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">error</span>(<span class="params">message: <span class="built_in">string</span></span>): <span class="title">never</span> </span>&#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(message);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="类型断言"><a href="#类型断言" class="headerlink" title="类型断言"></a>类型断言</h4><p>有时候你会遇到这样的情况，你会比TypeScript更了解某个值的详细信息。 通常这会发生在你清楚地知道一个实体具有比它现有类型更确切的类型。</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> str: <span class="built_in">any</span> = <span class="string">"this is a string"</span>;</span><br><span class="line"><span class="keyword">let</span> strLength1: <span class="built_in">number</span>;</span><br><span class="line"><span class="keyword">let</span> strLength2: <span class="built_in">number</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用 as 断言语法</span></span><br><span class="line">strLength1 = (str <span class="keyword">as</span> <span class="built_in">string</span>).length;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用 &lt;&gt; 断言语法</span></span><br><span class="line">strLength2 = (&lt;<span class="built_in">string</span>&gt;str).length;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 上面这两种断言方式得到的效果完全一致，下面增加的内容是因为模版出了点bug</span></span><br><span class="line"><span class="comment">// 对于语法的解析已经不是js的语法了，不填充以下内容，整块js都无法展示</span></span><br><span class="line">strLength1 === strLength2; <span class="comment">// -&gt; true</span></span><br><span class="line">strLength1 === strLength2; <span class="comment">// -&gt; true</span></span><br><span class="line">strLength1 === strLength2; <span class="comment">// -&gt; true</span></span><br><span class="line">strLength1 === strLength2; <span class="comment">// -&gt; true</span></span><br><span class="line">strLength1 === strLength2; <span class="comment">// -&gt; true</span></span><br><span class="line">strLength1 === strLength2; <span class="comment">// -&gt; true</span></span><br><span class="line">strLength1 === strLength2; <span class="comment">// -&gt; true</span></span><br></pre></td></tr></table></figure>
<p>以上是 <code>typescript</code> 所有的基础类型。</p>
</div></article></div></main><footer><div class="paginator"><a href="/2017/01/18/Typescript学习日记（二）/" class="prev">上一篇</a><a href="/2016/12/13/XSS和CSRF防御/" class="next">下一篇</a></div><div class="copyright"><p>© 2016 - 2018 <a href="https://github.com/TheNightElf">冷暖我自知</a></p></div></footer></div></body></html>