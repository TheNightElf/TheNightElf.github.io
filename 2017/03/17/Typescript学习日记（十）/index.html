<!DOCTYPE html><html lang="zh-CN"><head><meta charset="utf-8"><meta name="X-UA-Compatible" content="IE=edge"><title> Typescript学习日记(十) · 冷暖我自知</title><meta name="description" content="Typescript学习日记(十) - 冷暖我自知"><meta name="viewport" content="width=device-width, initial-scale=1"><link rel="icon" href="/favicon.ico"><link rel="stylesheet" href="/css/apollo.css"><link rel="search" type="application/opensearchdescription+xml" href="https://github.com/TheNightElf/atom.xml" title="冷暖我自知"></head><body><div class="wrap"><header><ul class="nav nav-list"><li class="nav-list-item"><a href="/" target="_self" class="nav-list-link">BLOG</a></li><li class="nav-list-item"><a href="/archives/" target="_self" class="nav-list-link">ARCHIVE</a></li><li class="nav-list-item"><a href="https://github.com/TheNightElf" target="_blank" class="nav-list-link">GITHUB</a></li></ul></header><main class="container"><div class="post"><article class="post-block"><h1 class="post-title">Typescript学习日记(十)</h1><div class="post-info">2017年3月17日</div><div class="post-content"><p><code>symbol</code> 是 <code>ECMAScript 2015</code> 提出的一种行的原生类型，就像 <code>number</code> 和 <code>string</code> 一样。实现了 <code>Symbol.iterator</code> 方法就可以使用 <code>for-of</code> 遍历。<br><a id="more"></a></p>
<h3 id="Symbols"><a href="#Symbols" class="headerlink" title="Symbols"></a>Symbols</h3><h4 id="创建"><a href="#创建" class="headerlink" title="创建"></a>创建</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 注意，Symbol() 并不是一个构造函数，所以不需要 new 关键字</span></span><br><span class="line"><span class="keyword">let</span> sy = <span class="built_in">Symbol</span>(<span class="string">'key'</span>);</span><br></pre></td></tr></table></figure>
<h4 id="Symbols是不可改变且唯一的"><a href="#Symbols是不可改变且唯一的" class="headerlink" title="Symbols是不可改变且唯一的"></a>Symbols是不可改变且唯一的</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> sy1 = <span class="built_in">Symbol</span>(<span class="string">'a'</span>);</span><br><span class="line"><span class="keyword">let</span> sy2 = <span class="built_in">Symbol</span>(<span class="string">'a'</span>);</span><br><span class="line"></span><br><span class="line">sy1 === sy2;  <span class="comment">// -&gt; false</span></span><br></pre></td></tr></table></figure>
<h4 id="像字符串一样，symbols也可以被用做对象属性的键"><a href="#像字符串一样，symbols也可以被用做对象属性的键" class="headerlink" title="像字符串一样，symbols也可以被用做对象属性的键"></a>像字符串一样，symbols也可以被用做对象属性的键</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> sy = <span class="built_in">Symbol</span>(<span class="string">'key'</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> obj = &#123;</span><br><span class="line">    [sy]: <span class="string">"value"</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(obj[sym]); <span class="comment">// "value"</span></span><br></pre></td></tr></table></figure>
<h4 id="Symbols也可以与计算出的-属性名声明相结合-来-声明对象的属性和类成员"><a href="#Symbols也可以与计算出的-属性名声明相结合-来-声明对象的属性和类成员" class="headerlink" title="Symbols也可以与计算出的 属性名声明相结合 来 声明对象的属性和类成员"></a>Symbols也可以与计算出的 <code>属性名声明相结合</code> 来 <code>声明对象的属性和类成员</code></h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> getClassNameSymbol = <span class="built_in">Symbol</span>();</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">C</span> </span>&#123;</span><br><span class="line">    [getClassNameSymbol]()&#123;</span><br><span class="line">       <span class="keyword">return</span> <span class="string">"C"</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> c = <span class="keyword">new</span> C();</span><br><span class="line"><span class="keyword">let</span> className = c[getClassNameSymbol](); <span class="comment">// "C"</span></span><br></pre></td></tr></table></figure>
<h4 id="内置属性"><a href="#内置属性" class="headerlink" title="内置属性"></a>内置属性</h4><p><strong><code>Symbol.hasInstance</code></strong><br>方法，会被 <code>instanceof</code> 运算符调用。构造器对象用来识别一个对象是否是其实例。</p>
<p><strong><code>Symbol.isConcatSpreadable</code></strong><br>布尔值，表示当在一个对象上调用 <code>Array.prototype.concat</code> 时，这个对象的数组元素是否可展开。</p>
<p><strong><code>Symbol.iterator</code></strong><br>方法，被for-of语句调用。返回对象的默认迭代器。</p>
<p><strong><code>Symbol.match</code></strong><br>方法，被 <code>String.prototype.match</code> 调用。正则表达式用来匹配字符串。</p>
<p><strong><code>Symbol.replace</code></strong><br>方法，被 <code>String.prototype.replace</code> 调用。正则表达式用来替换字符串中匹配的子串。</p>
<p><strong><code>Symbol.search</code></strong><br>方法，被 <code>String.prototype.search</code> 调用。正则表达式返回被匹配部分在字符串中的索引。</p>
<p><strong><code>Symbol.species</code></strong><br>函数值，为一个构造函数。用来创建派生对象。</p>
<p><strong><code>Symbol.split</code></strong><br>方法，被 <code>String.prototype.split</code> 调用。正则表达式来用分割字符串。</p>
<p><strong><code>Symbol.toPrimitive</code></strong><br>方法，被 <code>ToPrimitive</code> 抽象操作调用。把对象转换为相应的原始值。</p>
<p><strong><code>Symbol.toStringTag</code></strong><br>方法，被内置方法 <code>Object.prototype.toString</code> 调用。返回创建对象时默认的字符串描述。</p>
<p><strong><code>Symbol.unscopables</code></strong><br>对象，它自己拥有的属性会被 <code>with</code> 作用域排除在外。</p>
<p>更多关于 <code>Symbols</code> 的介绍可以查看<a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Symbol" target="_blank" rel="noopener">这里</a>。</p>
<h3 id="迭代器-iterator-和生成器"><a href="#迭代器-iterator-和生成器" class="headerlink" title="迭代器(iterator)和生成器"></a>迭代器(iterator)和生成器</h3><p>当一个对象实现了 <code>Symbol.iterator</code> 属性时，我们认为它是可迭代的。目前一些内置的类型如 <code>Array</code>，<code>Map</code>，<code>Set</code>，<code>String</code>，<code>Int32Array</code>，<code>Uint32Array</code> 等都已经实现了各自的 <code>Symbol.iterator</code>。 对象上的 <code>Symbol.iterator</code> 函数负责返回供迭代的值。</p>
<h4 id="for-of-语句"><a href="#for-of-语句" class="headerlink" title="for-of 语句"></a><code>for-of</code> 语句</h4><p><code>for-of</code> 会遍历可迭代的对象，调用对象上的 <code>Symbol.iterator</code> 方法。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> arr = [<span class="number">1</span>, <span class="string">"string"</span>, <span class="literal">false</span>];</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> val <span class="keyword">of</span> arr) &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(val); <span class="comment">// 1, "string", false</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="for-of-vs-for-in"><a href="#for-of-vs-for-in" class="headerlink" title="for-of vs for-in"></a><code>for-of</code> vs <code>for-in</code></h4><p><code>for-of</code> 和 <code>for-in</code> 均可迭代一个列表；但是用于迭代的值却不同，<code>for-in</code> 迭代的是对象的 <code>键</code> 的列表，而<code>for-of</code> 则迭代对象的键对应的值。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> arr = [<span class="number">1</span>, <span class="string">"string"</span>, <span class="literal">false</span>];</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">let</span> key <span class="keyword">in</span> arr) &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(key); <span class="comment">// 0, 1, 2</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> val <span class="keyword">of</span> arr) &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(val); <span class="comment">// 1, "string", false</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>另一个区别是 <code>for-in</code> 可以操作任何对象；它提供了查看对象属性的一种方法。 但是 <code>for-of</code> 关注于迭代对象的值。内置对象 <code>Map</code> 和 <code>Set</code> 已经实现了 <code>Symbol.iterator</code> 方法，让我们可以访问它们保存的值。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> pets = <span class="keyword">new</span> <span class="built_in">Set</span>([<span class="string">"Cat"</span>, <span class="string">"Dog"</span>, <span class="string">"Hamster"</span>]);</span><br><span class="line">pets[<span class="string">"species"</span>] = <span class="string">"mammals"</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> pet <span class="keyword">in</span> pets) &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(pet); <span class="comment">// "species"</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> pet <span class="keyword">of</span> pets) &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(pet); <span class="comment">// "Cat", "Dog", "Hamster"</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="三斜线指令"><a href="#三斜线指令" class="headerlink" title="三斜线指令"></a>三斜线指令</h3><p>三斜线指令是包含单个XML标签的单行注释。 注释的内容会做为编译器指令使用。</p>
<p>三斜线指令仅可放在包含它的文件的最顶端。 一个三斜线指令的前面只能出现单行或多行注释，这包括其它的三斜线指令。 如果它们出现在 <code>一个语句或声明</code> 之后，那么它们会被当做普通的单行注释，并且不具有特殊的涵义。</p>
<h4 id="lt-reference-path-quot-quot-gt"><a href="#lt-reference-path-quot-quot-gt" class="headerlink" title="/// &lt;reference path=&quot;...&quot; /&gt;"></a><code>/// &lt;reference path=&quot;...&quot; /&gt;</code></h4><p><code>/// &lt;reference path=&quot;...&quot; /&gt;</code> 指令是三斜线指令中最常见的一种。 它用于声明文件间的 <code>依赖</code>。三斜线引用告诉编译器在编译过程中要引入的额外的文件。</p>
<h4 id="使用-noResolve"><a href="#使用-noResolve" class="headerlink" title="使用 --noResolve"></a>使用 <code>--noResolve</code></h4><p>如果指定了 <code>--noResolve</code> 编译选项，三斜线引用会被忽略；它们不会增加新文件，也不会改变给定文件的顺序。</p>
<h4 id="lt-reference-types-quot-quot-gt"><a href="#lt-reference-types-quot-quot-gt" class="headerlink" title="/// &lt;reference types=&quot;...&quot; /&gt;"></a><code>/// &lt;reference types=&quot;...&quot; /&gt;</code></h4><p>与 <code>/// &lt;reference path=&quot;...&quot; /&gt;</code> 指令相似，这个指令是用来声明依赖的； 一个 <code>/// &lt;reference path=&quot;...&quot; /&gt;</code> 指令声明了对 <code>@types</code> 包的一个依赖。</p>
<p>在声明文件里包含 <code>/// &lt;reference types=&quot;node&quot; /&gt;</code>，表明这个文件使用了 <code>@types/node/index.d.ts</code> 里面声明的名字； 并且，这个包要在编译阶段与声明文件一起被包含进来。</p>
<p>解析 <code>@types</code> 包的名字的过程与解析 <code>import</code> 语句里模块名的过程类似。 所以可以简单的把三斜线类型引用指令想像成针对包的 <code>import</code> 声明。</p>
<p>仅当在你需要写一个 <code>d.ts</code> 文件时才使用这个指令。</p>
<p>对于那些在编译阶段生成的声明文件，编译器会自动地添加 <code>/// &lt;reference types=&quot;...&quot; /&gt;</code>； 当且仅当结果文件中使用了引用的@types包里的声明时才会在生成的声明文件里添加 <code>/// &lt;reference types=&quot;...&quot; /&gt;</code> 语句。</p>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>大致看了下，后面的内容都是一些需要记忆的内容，不会牵扯到太多的代码；这里就不再继续往下写了，有想阅读后面内容的朋友可以进入<a href="https://www.tslang.cn/index.html" target="_blank" rel="noopener">Typescript中文文档</a>继续学习。</p>
</div></article></div></main><footer><div class="paginator"><a href="/2017/04/25/Javascript中那些你不知道的运算符/" class="prev">上一篇</a><a href="/2017/03/02/Typescript学习日记（九）/" class="next">下一篇</a></div><div class="copyright"><p>© 2016 - 2018 <a href="https://github.com/TheNightElf">冷暖我自知</a></p></div></footer></div></body></html>